package com.example.app;

import android.annotation.SuppressLint;
import android.app.Activity;
import android.os.Bundle;
import android.webkit.WebSettings;
import android.webkit.WebView;
import android.webkit.WebChromeClient;
import android.webkit.WebViewClient;
import android.content.SharedPreferences;
import android.content.Context;
import android.webkit.JavascriptInterface;
import android.graphics.Bitmap;

public class MainActivity extends Activity {

    private WebView mWebView;
    private SharedPreferences sharedPreferences;

    @Override
    @SuppressLint("SetJavaScriptEnabled")
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        mWebView = findViewById(R.id.activity_main_webview);
        WebSettings webSettings = mWebView.getSettings();
        mWebView.setWebContentsDebuggingEnabled(true);
        webSettings.setJavaScriptEnabled(true);
        webSettings.setUserAgentString("Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36");
        mWebView.setWebChromeClient(new WebChromeClient());
        mWebView.setWebViewClient(new WebViewClient() {
            @Override
            public void onPageStarted(WebView view, String url, Bitmap favicon) {
                if (url.matches("^(https?://(www|m)\\.youtube\\.com/.*)|(https?://.*\\.youtube-nocookie\\.com/embed/.*)|(https?://youtube\\.googleapis\\.com/embed/.*)|(https?://raingart\\.github\\.io/options\\.html.*)$") &&
                    !url.matches("^(https?://.*\\.youtube\\.com/.*\\.xml.*)|(https?://.*\\.youtube\\.com/error.*)|(https?://music\\.youtube\\.com/.*)|(https?://accounts\\.youtube\\.com/.*)|(https?://studio\\.youtube\\.com/.*)|(https?://.*\\.youtube\\.com/redirect\\?.*)$")) {
                    
                    String script = "/*jshint esversion: 6 */\r\n\r\nwindow.nova_plugins = [];\r\nwindow.nova_plugins.push({\r\n   id: \'comments-sort\',\r\n   title: \'Comments sort\',\r\n   run_on_pages: \'watch, -mobile\',\r\n   opt_api_key_warn: true,\r\n   section: \'comments\',\r\n   desc: \'add modal\',\r\n   _runtime: user_settings => {\r\n      const\r\n         MODAL_NAME_SELECTOR_ID = \'nova-modal-comments\',\r\n         MODAL_CONTENT_SELECTOR_ID = \'modal-content\';\r\n      insertButton();\r\n      function insertButton() {\r\n         NOVA.waitSelector(\r\n            user_settings[\'comments-popup\']\r\n               ? \'#masthead-container\'\r\n               : \'#comments ytd-comments-header-renderer #title\'\r\n         )\r\n            .then(menu => {\r\n               const btn = document.createElement(\'span\');\r\n               btn.setAttribute(\'data-open-modal\', MODAL_NAME_SELECTOR_ID);\r\n               btn.title = \'Nova Comments\';\r\n               btn.textContent = \'►\';\r\n               btn.addEventListener(\'click\', () => {\r\n                  if (!document.body.querySelector(`#${MODAL_CONTENT_SELECTOR_ID} table`)) {\r\n                     genTable();\r\n                  }\r\n                  btn.dispatchEvent(new CustomEvent(MODAL_NAME_SELECTOR_ID, { bubbles: true, detail: \'test\' }));\r\n               });\r\n               Object.assign(btn.style,\r\n                  user_settings[\'comments-popup\']\r\n                     ? {\r\n                        position: \'fixed\',\r\n                        right: \'0\',\r\n                        top: \'var(--ytd-masthead-height)\',\r\n                        visibility: \'visible\',\r\n                        \'z-index\':\r\n                           1 + Math.max(\r\n                              NOVA.css.getValue(\'.ytp-chrome-top\', \'z-index\'),\r\n                              60),\r\n                        \'font-size\': \'18px\',\r\n                     }\r\n                     : {\r\n                        \'font-size\': \'24px\',\r\n                        \'text-decoration\': \'none\',\r\n                        padding: \'0 10px\',\r\n                        background: \'transparent\',\r\n                        border: \'none\',\r\n                     },\r\n                  {\r\n                     color: \'orange\',\r\n                     cursor: \'pointer\',\r\n                  });\r\n               user_settings[\'comments-popup\']\r\n                  ? menu.append(btn)\r\n                  : menu.prepend(btn);\r\n               insertModal();\r\n               connectSortable();\r\n               NOVA.runOnPageInitOrTransition(() => {\r\n                  if (NOVA.currentPage == \'watch\') {\r\n                     document.getElementById(MODAL_CONTENT_SELECTOR_ID).innerHTML = \'<pre>Loading data...</pre>\';\r\n                  }\r\n               });\r\n            });\r\n      }\r\n      function genTable() {\r\n         NOVA.request.API({\r\n            request: \'commentThreads\',\r\n            params: {\r\n               \'videoId\': NOVA.queryURL.get(\'v\') || movie_player.getVideoData().video_id,\r\n               \'part\': \'snippet\',\r\n               \'maxResults\': 100,\r\n               \'order\': \'relevance\',\r\n            },\r\n            api_key: user_settings[\'user-api-key\'],\r\n         })\r\n            .then(res => {\r\n               if (res?.error) {\r\n                  if (res.reason) {\r\n                     document.getElementById(MODAL_NAME_SELECTOR_ID)\r\n                        .dispatchEvent(new CustomEvent(MODAL_NAME_SELECTOR_ID, { bubbles: true, detail: \'test\' }));\r\n                     return alert(`Error [${res.code}]: ${res.reason}`);\r\n                  }\r\n                  else {\r\n                     return document.getElementById(MODAL_CONTENT_SELECTOR_ID).innerHTML =\r\n                        `<pre>Error [${res.code}]: ${res.reason}</pre>\r\n                        <pre>${res.error}</pre>`;\r\n                  }\r\n               }\r\n               let commentList = []\r\n               res?.items?.forEach(item => {\r\n                  if (comment = item.snippet?.topLevelComment?.snippet) {\r\n                     commentList.push(\r\n                        Object.assign(\r\n                           { \'totalReplyCount\': item.snippet.totalReplyCount },\r\n                           { \'id\': item.id },\r\n                           comment,\r\n                        )\r\n                     );\r\n                  }\r\n                  else {\r\n                     console.warn(\'API is change\', item);\r\n                  }\r\n               });\r\n               if (!commentList.length) {\r\n                  return document.getElementById(MODAL_CONTENT_SELECTOR_ID).innerHTML =\r\n                     `<pre>Total number of comments: ${res.pageInfo.totalResults}</pre>`;\r\n               }\r\n               const ul = document.createElement(\'tbody\');\r\n               commentList\r\n                  .sort((a, b) => b.likeCount - a.likeCount)\r\n                  .forEach(comment => {\r\n                     try {\r\n                        const li = document.createElement(\'tr\');\r\n                        li.className = \'item\';\r\n                        li.innerHTML =\r\n                           `<td>${comment.likeCount}</td>\r\n                           <td>${+comment.totalReplyCount ?\r\n                              `<a href=\"https://www.youtube.com/watch?v=${comment.videoId}&lc=${comment.id}\" target=\"_blank\" title=\"Open\">${comment.totalReplyCount}</a>` : comment.totalReplyCount}\r\n                           </td>\r\n                           <td sorttable_customkey=\"${new Date(comment.updatedAt).getTime()}\">${NOVA.timeFormatTo.ago(new Date(comment.updatedAt))}</td>\r\n                           <td>\r\n                              <a href=\"${comment.authorChannelUrl}\" target=\"_blank\" title=\"${comment.authorDisplayName}\">\r\n                                 <img src=\"${comment.authorProfileImageUrl}\" alt=\"${comment.authorDisplayName}\" />\r\n                              </a>\r\n                           </td>\r\n                           <td sorttable_customkey=\"${comment.textDisplay.length}\">\r\n                              <span class=\"text-overflow-dynamic-ellipsis\">${comment.textDisplay}</span>\r\n                           </td>`;\r\n                        ul.append(li);\r\n                     } catch (error) {\r\n                        console.error(\'Error comment generate:\\n\', error.stack + \'\\n\', comment);\r\n                     }\r\n                  });\r\n               const MODAL_CONTENT_FILTER_SELECTOR_ID = \'nova-search-comment\';\r\n               document.getElementById(MODAL_CONTENT_SELECTOR_ID).innerHTML =\r\n                  `<table class=\"sortable\" border=\"0\" cellspacing=\"0\" cellpadding=\"0\">\r\n                     <thead id=\"${MODAL_CONTENT_FILTER_SELECTOR_ID}\">\r\n                        <tr>\r\n                           <th class=\"sorttable_numeric\">likes</th>\r\n                           <th class=\"sorttable_numeric\">replys</th>\r\n                           <th class=\"sorttable_numeric\">date</th>\r\n                           <th class=\"sorttable_nosort\">avatars</th>\r\n                           <th class=\"sorttable_numeric\">comments (${res.pageInfo.totalResults})</th>\r\n                        </tr>\r\n                     </thead>\r\n                     ${ul.innerHTML}\r\n                  </table>`;\r\n               sorttable.makeSortable(document.body.querySelector(\'.sortable\'));\r\n               insertFilterInput(MODAL_CONTENT_FILTER_SELECTOR_ID);\r\n            });\r\n      }\r\n      function insertFilterInput(parent_selector_id = required()) {\r\n         if (typeof parent_selector_id !== \'string\') {\r\n            return console.error(\'typeof \"parent_selector_id\":\', (typeof parent_selector_id));\r\n         }\r\n         NOVA.css.push(\r\n            `#${parent_selector_id} {\r\n               position: relative;\r\n            }\r\n            #${parent_selector_id} input {\r\n              position: absolute;\r\n              top: 0;\r\n              right: 0;\r\n              \r\n              \r\n            }\r\n            #${parent_selector_id} input[type=search]:focus,\r\n            #${parent_selector_id} input[type=text]:focus {\r\n               outline: 1px solid #00b7fc;\r\n            }`);\r\n         const searchInput = document.createElement(\'input\');\r\n         searchInput.setAttribute(\'type\', \'search\');\r\n         searchInput.setAttribute(\'placeholder\', \'Filter\');\r\n         [\'change\', \'keyup\'].forEach(evt => {\r\n            searchInput\r\n               .addEventListener(evt, function () {\r\n                  NOVA.searchFilterHTML({\r\n                     \'keyword\': this.value,\r\n                     \'filter_selectors\': \'tr\',\r\n                     \'highlight_selector\': \'.text-overflow-dynamic-ellipsis\',\r\n                  });\r\n               });\r\n            searchInput\r\n               .addEventListener(\'click\', () => {\r\n                  searchInput.value = \'\';\r\n                  searchInput.dispatchEvent(new Event(\'change\'));\r\n               });\r\n         });\r\n         document.getElementById(parent_selector_id).append(searchInput);\r\n      };\r\n      function insertModal() {\r\n         NOVA.css.push(\r\n            `.modal {\r\n               --animation-time: .2s;\r\n               z-index: 9999;\r\n               position: fixed;\r\n               top: 0;\r\n               left: 0;\r\n               background: rgba(0, 0, 0, .8);\r\n               display: flex;\r\n               align-items: center;\r\n               justify-content: center;\r\n               width: 100%;\r\n               height: 100%;\r\n               box-sizing: border-box;\r\n               visibility: hidden;\r\n               opacity: 0;\r\n               \r\n            }\r\n            .modal.modal-visible {\r\n               animation: microModalFadeIn var(--animation-time) cubic-bezier(0, 0, .2, 1);\r\n               visibility: visible;\r\n               opacity: 1;\r\n            }\r\n            @keyframes microModalFadeIn {\r\n               from { opacity: 0; }\r\n               to { opacity: 1; }\r\n            }\r\n            .modal-container {\r\n               border-radius: 4px;\r\n               background-color: silver;\r\n               position: relative;\r\n               display: flex;\r\n               box-sizing: border-box;\r\n               overflow-y: auto;\r\n               max-width: 70%;\r\n               max-height: 100vh;\r\n               transform: scale(0.9);\r\n               transition: all var(--animation-time) ease-out;\r\n            }\r\n            .modal.modal-visible .modal-container {\r\n               transform: scale(1);\r\n            }\r\n            .modal-close {\r\n               position: absolute;\r\n               top: 0;\r\n               right: 0;\r\n               cursor: pointer;\r\n               font-size: 2em;\r\n               padding: 0 5px;\r\n               transition: background-color var(--animation-time) ease-out;\r\n            }\r\n            .modal-close:before { content: \"\\\\2715\"; }\r\n            .modal-close:hover {\r\n               background-color: #ea3c3c;\r\n            }\r\n            .modal-content {\r\n               padding: 2rem;\r\n            }`);\r\n         NOVA.css.push(\r\n            `.modal {}\r\n            .modal-container {\r\n               \r\n               background-color: var(--yt-spec-base-background);\r\n               background-color: var(--yt-spec-raised-background);\r\n            }\r\n            .modal-content {\r\n               font-size: 12px;\r\n               color: var(--yt-spec-text-primary);\r\n            }`);\r\n         document.body\r\n            .insertAdjacentHTML(\'beforeend\',\r\n               `<div id=\"${MODAL_NAME_SELECTOR_ID}\" class=\"modal\" data-modal>\r\n                  <div class=\"modal-container\">\r\n                     <div class=\"modal-close\" data-close-modal></div>\r\n                     <div class=\"modal-content\" id=\"${MODAL_CONTENT_SELECTOR_ID}\"></div>\r\n                  </div>\r\n               </div>`);\r\n         const modalShowClass = \'modal-visible\';\r\n         document.getElementById(MODAL_NAME_SELECTOR_ID)\r\n            .addEventListener(\'click\', ({ target }) => {\r\n               target.dispatchEvent(new CustomEvent(MODAL_NAME_SELECTOR_ID, { bubbles: true, detail: \'test\' }));\r\n            });\r\n         document.addEventListener(MODAL_NAME_SELECTOR_ID, ({ target }) => {\r\n            const\r\n               attrModal = target.hasAttribute(\'data-modal\'),\r\n               attrOpen = target.getAttribute(\'data-open-modal\'),\r\n               attrClose = target.hasAttribute(\'data-close-modal\');\r\n            if (attrModal) {\r\n               target.classList.remove(modalShowClass);\r\n            }\r\n            else if (attrOpen && (modal = document.getElementById(attrOpen))) {\r\n               modal.classList.add(modalShowClass);\r\n            }\r\n            else if (attrClose && (modal = target.closest(\'[data-modal]\'))) {\r\n               modal.classList.remove(modalShowClass);\r\n            }\r\n         });\r\n      }\r\n      function connectSortable() {\r\n         NOVA.css.push(\r\n            `table.sortable table {\r\n               width: 100%;\r\n            }\r\n            table.sortable thead {}\r\n            table.sortable thead th {\r\n               text-transform: uppercase;\r\n               cursor: pointer;\r\n            }\r\n            thead, th, td {\r\n               text-align: center;\r\n            }\r\n            table tbody {\r\n               counter-reset: sortabletablescope;\r\n            }\r\n            \r\n            \r\n            #${MODAL_CONTENT_SELECTOR_ID} td .text-overflow-dynamic-ellipsis {\r\n               display: block;\r\n               max-height: 25vh;\r\n               overflow-y: auto;\r\n               text-align: left;\r\n               font-size: 1.2em;\r\n               line-height: 1.4;\r\n               padding: 10px 5px;\r\n               max-width: 600px;\r\n            }\r\n            #${MODAL_CONTENT_SELECTOR_ID} td a {\r\n               text-decoration: none;\r\n               color: var(--yt-spec-call-to-action);\r\n            }`);\r\n//         function dean_addEvent(t, e, r) { if (t.addEventListener) t.addEventListener(e, r, !1); else { r.$$guid || (r.$$guid = dean_addEvent.guid++), t.events || (t.events = {}); var o = t.events[e]; o || (o = t.events[e] = {}, t[\"on\" + e] && (o[0] = t[\"on\" + e])), o[r.$$guid] = r, t[\"on\" + e] = handleEvent } } function handleEvent(t) { var e = !0; t = t || fixEvent(((this.ownerDocument || this.document || this).parentWindow || window).event); var r = this.events[t.type]; for (var o in r) this.$$handleEvent = r[o], !1 === this.$$handleEvent(t) && (e = !1); return e } function fixEvent(t) { return t.preventDefault = fixEvent.preventDefault, t.stopPropagation = fixEvent.stopPropagation, t } sorttable = { makeSortable: function (t) { if (0 == t.getElementsByTagName(\"thead\").length && (the = document.createElement(\"thead\"), the.appendChild(t.rows[0]), t.insertBefore(the, t.firstChild)), null == t.tHead && (t.tHead = t.getElementsByTagName(\"thead\")[0]), 1 == t.tHead.rows.length) { sortbottomrows = []; for (var e = 0; e < t.rows.length; e++)-1 != t.rows[e].className.search(/\\bsortbottom\\b/) && (sortbottomrows[sortbottomrows.length] = t.rows[e]); if (sortbottomrows) { null == t.tFoot && (tfo = document.createElement(\"tfoot\"), t.appendChild(tfo)); for (e = 0; e < sortbottomrows.length; e++)tfo.appendChild(sortbottomrows[e]); delete sortbottomrows } headrow = t.tHead.rows[0].cells; for (e = 0; e < headrow.length; e++)headrow[e].className.match(/\\bsorttable_nosort\\b/) || (mtch = headrow[e].className.match(/\\bsorttable_([a-z0-9]+)\\b/), mtch && (override = mtch[1]), mtch && \"function\" == typeof sorttable[\"sort_\" + override] ? headrow[e].sorttable_sortfunction = sorttable[\"sort_\" + override] : headrow[e].sorttable_sortfunction = sorttable.guessType(t, e), headrow[e].sorttable_columnindex = e, headrow[e].sorttable_tbody = t.tBodies[0], dean_addEvent(headrow[e], \"click\", sorttable.innerSortFunction = function (t) { if (-1 != this.className.search(/\\bsorttable_sorted\\b/)) return sorttable.reverse(this.sorttable_tbody), this.className = this.className.replace(\"sorttable_sorted\", \"sorttable_sorted_reverse\"), this.removeChild(document.getElementById(\"sorttable_sortfwdind\")), sortrevind = document.createElement(\"span\"), sortrevind.id = \"sorttable_sortrevind\", sortrevind.innerHTML = \"&nbsp;&#x25B4;\", void this.appendChild(sortrevind); if (-1 != this.className.search(/\\bsorttable_sorted_reverse\\b/)) return sorttable.reverse(this.sorttable_tbody), this.className = this.className.replace(\"sorttable_sorted_reverse\", \"sorttable_sorted\"), this.removeChild(document.getElementById(\"sorttable_sortrevind\")), sortfwdind = document.createElement(\"span\"), sortfwdind.id = \"sorttable_sortfwdind\", sortfwdind.innerHTML = \"&nbsp;&#x25BE;\", void this.appendChild(sortfwdind); theadrow = this.parentNode, forEach(theadrow.childNodes, (function (t) { 1 == t.nodeType && (t.className = t.className.replace(\"sorttable_sorted_reverse\", \"\"), t.className = t.className.replace(\"sorttable_sorted\", \"\")) })), sortfwdind = document.getElementById(\"sorttable_sortfwdind\"), sortfwdind && sortfwdind.parentNode.removeChild(sortfwdind), sortrevind = document.getElementById(\"sorttable_sortrevind\"), sortrevind && sortrevind.parentNode.removeChild(sortrevind), this.className += \" sorttable_sorted\", sortfwdind = document.createElement(\"span\"), sortfwdind.id = \"sorttable_sortfwdind\", sortfwdind.innerHTML = \"&nbsp;&#x25BE;\", this.appendChild(sortfwdind), row_array = [], col = this.sorttable_columnindex, rows = this.sorttable_tbody.rows; for (var e = 0; e < rows.length; e++)row_array[row_array.length] = [sorttable.getInnerText(rows[e].cells[col]), rows[e]]; row_array.sort(this.sorttable_sortfunction).reverse(), tb = this.sorttable_tbody; for (e = 0; e < row_array.length; e++)tb.appendChild(row_array[e][1]); delete row_array })) } }, guessType: function (t, e) { sortfn = sorttable.sort_alpha; for (var r = 0; r < t.tBodies[0].rows.length; r++)if (text = sorttable.getInnerText(t.tBodies[0].rows[r].cells[e]), \"\" != text && text.match(/^-?[£$¤]?[\\d,.]+%?$/)) return sorttable.sort_numeric; return sortfn }, getInnerText: function (t) { if (!t) return \"\"; if (hasInputs = \"function\" == typeof t.getElementsByTagName && t.getElementsByTagName(\"input\").length, null != t.getAttribute(\"sorttable_customkey\")) return t.getAttribute(\"sorttable_customkey\"); if (void 0 !== t.textContent && !hasInputs) return t.textContent.replace(/^\\s+|\\s+$/g, \"\"); if (void 0 !== t.innerText && !hasInputs) return t.innerText.replace(/^\\s+|\\s+$/g, \"\"); if (void 0 !== t.text && !hasInputs) return t.text.replace(/^\\s+|\\s+$/g, \"\"); switch (t.nodeType) { case 3: if (\"input\" == t.nodeName.toLowerCase()) return t.value.replace(/^\\s+|\\s+$/g, \"\"); case 4: return t.nodeValue.replace(/^\\s+|\\s+$/g, \"\"); case 1: case 11: for (var e = \"\", r = 0; r < t.childNodes.length; r++)e += sorttable.getInnerText(t.childNodes[r]); return e.replace(/^\\s+|\\s+$/g, \"\"); default: return \"\" } }, reverse: function (t) { newrows = []; for (var e = 0; e < t.rows.length; e++)newrows[newrows.length] = t.rows[e]; for (e = newrows.length - 1; e >= 0; e--)t.appendChild(newrows[e]); delete newrows }, sort_numeric: function (t, e) { return aa = parseFloat(t[0].replace(/[^0-9.-]/g, \"\")), isNaN(aa) && (aa = 0), bb = parseFloat(e[0].replace(/[^0-9.-]/g, \"\")), isNaN(bb) && (bb = 0), aa - bb }, sort_alpha: function (t, e) { return t[0].localeCompare(e[0]) } }, dean_addEvent.guid = 1, fixEvent.preventDefault = function () { this.returnValue = !1 }, fixEvent.stopPropagation = function () { this.cancelBubble = !0 }, Function.prototype.forEach = function (t, e, r) { for (var o in t) void 0 === this.prototype[o] && e.call(r, t[o], o, t) }, String.forEach = function (t, e, r) { Array.forEach(t.split(\"\"), (function (o, n) { e.call(r, o, n, t) })) }; var forEach = function (t, e, r) { if (t) { var o = Object; if (t instanceof Function) o = Function; else { if (t.forEach instanceof Function) return void t.forEach(e, r); \"string\" == typeof t ? o = String : \"number\" == typeof t.length && (o = Array) } o.forEach(t, e, r) } };\r\n      }\r\n   },\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'comments-popup\',\r\n   title: \'Comments section in popup\',\r\n   run_on_pages: \'watch, -mobile\',\r\n   section: \'comments\',\r\n   _runtime: user_settings => {\r\n      if (user_settings[\'comments_visibility_mode\'] == \'disable\') return;\r\n      const\r\n         COMMENTS_SELECTOR = \'html:not(:fullscreen) #page-manager #comments:not([hidden]):not(:empty)\',\r\n         counterAttrName = \'data-counter\';\r\n      NOVA.runOnPageInitOrTransition(() => {\r\n         if (NOVA.currentPage == \'watch\') {\r\n            NOVA.waitSelector(\'ytd-comments-header-renderer #title #count\', { stop_on_page_change: true })\r\n               .then(count => {\r\n                  document.body.querySelector(COMMENTS_SELECTOR)\r\n                     ?.setAttribute(counterAttrName,\r\n                        NOVA.prettyRoundInt(parseInt(count.textContent.replace(/,/g, \'\')))\r\n                     );\r\n               });\r\n         }\r\n      });\r\n      NOVA.waitSelector(\'#masthead-container\')\r\n         .then(masthead => {\r\n            NOVA.css.push(\r\n               `${COMMENTS_SELECTOR},\r\n               ${COMMENTS_SELECTOR}:before {\r\n                  position: fixed;\r\n                  top: ${masthead.offsetHeight || 56}px;\r\n                  right: 0;\r\n                  z-index: ${1 + Math.max(getComputedStyle(masthead || movie_player)[\'z-index\'], 601)};\r\n               }\r\n               \r\n               ${COMMENTS_SELECTOR}:not(:hover):before {\r\n                  content: attr(${counterAttrName}) \" comments ▼\";\r\n                  cursor: pointer;\r\n                  visibility: visible;\r\n                  \r\n                  right: 3em;\r\n                  padding: 0 6px 2px;\r\n                  line-height: normal;\r\n                  font-family: Roboto, Arial, sans-serif;\r\n                  font-size: 11px;\r\n                  color: #eee;\r\n                  background: rgba(0,0,0,0.3);\r\n               }\r\n               \r\n               ${COMMENTS_SELECTOR} {\r\n                  ${(user_settings.comments_popup_width === 100) ? \'margin: 0 1%;\' : \'\'}\r\n                  padding: 0 15px;\r\n                  background-color: #222;\r\n                  border: 1px solid #333;\r\n                  max-width: ${user_settings.comments_popup_width || 40}%;\r\n               }\r\n               ${COMMENTS_SELECTOR}:not(:hover) {\r\n                  visibility: collapse;\r\n               }\r\n               \r\n               ${COMMENTS_SELECTOR}:hover {\r\n                  visibility: visible !important;\r\n               }\r\n               \r\n               ${COMMENTS_SELECTOR} > #sections > #contents {\r\n                  overflow-y: auto;\r\n                  max-height: 88vh;\r\n                  padding-top: 1em;\r\n               }\r\n               #expander.ytd-comment-renderer {\r\n                  overflow-x: hidden;\r\n               }\r\n               \r\n               ${COMMENTS_SELECTOR} #sections {\r\n                  min-width: 500px;\r\n               }\r\n               \r\n               ${COMMENTS_SELECTOR} #contents::-webkit-scrollbar {\r\n                  height: 8px;\r\n                  width: 10px;\r\n               }\r\n               ${COMMENTS_SELECTOR} #contents::-webkit-scrollbar-button {\r\n                  height: 0;\r\n                  width: 0;\r\n               }\r\n               ${COMMENTS_SELECTOR} #contents::-webkit-scrollbar-corner {\r\n                  background: transparent;\r\n               }\r\n               ${COMMENTS_SELECTOR} #contents::-webkit-scrollbar-thumb {\r\n                  background: #e1e1e1;\r\n                  border: 0;\r\n                  border-radius: 0;\r\n               }\r\n               ${COMMENTS_SELECTOR} #contents::-webkit-scrollbar-track {\r\n                  background: #666;\r\n                  border: 0;\r\n                  border-radius: 0;\r\n               }\r\n               ${COMMENTS_SELECTOR} #contents::-webkit-scrollbar-track:hover {\r\n                  background: #666;\r\n               }`);\r\n            if (user_settings.comments_popup_hide_textarea) {\r\n               NOVA.css.push(\r\n                  `${COMMENTS_SELECTOR} > #sections > #contents {\r\n                     overflow-y: auto;\r\n                     max-height: 88vh;\r\n                     border-top: 1px solid #333;\r\n                     padding-top: 1em;\r\n                  }\r\n                  ${COMMENTS_SELECTOR} #header #simple-box {\r\n                     display: none;\r\n                  }\r\n                  \r\n                  ytd-comments-header-renderer {\r\n                     height: 0;\r\n                     margin-top: 10px;\r\n                  }`);\r\n            }\r\n            else {\r\n               NOVA.css.push(\r\n                  `\r\n                  ytd-comments-header-renderer {\r\n                     margin: 10px 0;\r\n                  }`);\r\n            }\r\n         });\r\n   },\r\n   options: {\r\n      comments_popup_width: {\r\n         _tagName: \'input\',\r\n         label: \'Width\',\r\n         \'label:ua\': \'Ширина\',\r\n         type: \'number\',\r\n         title: \'% of the screen width\',\r\n         placeholder: \'%\',\r\n         step: 5,\r\n         min: 10,\r\n         max: 100,\r\n         value: 40,\r\n      },\r\n      comments_popup_hide_textarea: {\r\n         _tagName: \'input\',\r\n         label: \'Hide textarea\',\r\n         \'label:ua\': \'Приховати поле вводу\',\r\n         type: \'checkbox\',\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'comments-expand\',\r\n   title: \'Expand comments\',\r\n   run_on_pages: \'watch, -mobile\',\r\n   section: \'comments\',\r\n   _runtime: user_settings => {\r\n      NOVA.css.push(\r\n         `#expander.ytd-comment-renderer {\r\n            overflow-x: hidden;\r\n         }`);\r\n      NOVA.watchElements({\r\n         selectors: [\'#comment #expander[collapsed] #more:not([hidden])\'],\r\n         attr_mark: \'nova-comment-expanded\',\r\n         callback: btn => {\r\n            const moreExpand = () => btn.click();\r\n            const comment = btn.closest(\'#expander[collapsed]\');\r\n            switch (user_settings.comments_expand_mode) {\r\n               case \'onhover\':\r\n                  comment.addEventListener(\'mouseenter\', moreExpand, { capture: true, once: true });\r\n                  break;\r\n               case \'always\':\r\n                  moreExpand();\r\n                  break;\r\n            }\r\n         },\r\n      });\r\n      NOVA.watchElements({\r\n         selectors: [\'#replies #more-replies button\'],\r\n         attr_mark: \'nova-replies-expanded\',\r\n         callback: btn => {\r\n            const moreExpand = () => btn.click();\r\n            switch (user_settings.comments_view_reply) {\r\n               case \'onhover\':\r\n                  btn.addEventListener(\'mouseenter\', moreExpand, { capture: true, once: true });\r\n                  break;\r\n               case \'always\':\r\n                  moreExpand();\r\n                  break;\r\n            }\r\n         },\r\n      });\r\n      if (NOVA.queryURL.has(\'lc\')) {\r\n         NOVA.waitSelector(\'#comment #linked-comment-badge + #body #expander[collapsed] #more:not([hidden])\')\r\n            .then(btn => btn.click());\r\n         NOVA.waitSelector(\'ytd-comment-thread-renderer:has(#linked-comment-badge) #replies #more-replies button\')\r\n            .then(btn => btn.click());\r\n      }\r\n   },\r\n   options: {\r\n      comments_expand_mode: {\r\n         _tagName: \'select\',\r\n         label: \'Expand comment\',\r\n         options: [\r\n            {\r\n               label: \'always\', value: \'always\', selected: true,\r\n            },\r\n            {\r\n               label: \'on hover\', value: \'onhover\',\r\n            },\r\n            {\r\n               label: \'disable\', value: false,\r\n            },\r\n         ],\r\n      },\r\n      comments_view_reply: {\r\n         _tagName: \'select\',\r\n         label: \'Expand reply\',\r\n         options: [\r\n            {\r\n               label: \'always\', value: \'always\',\r\n            },\r\n            {\r\n               label: \'on hover\', value: \'onhover\', selected: true,\r\n            },\r\n            {\r\n               label: \'disable\', value: false,\r\n            },\r\n         ],\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'square-avatars\',\r\n   title: \'Square avatars\',\r\n   run_on_pages: \'*, -live_chat\',\r\n   section: \'comments\',\r\n   desc: \'Make user images squared\',\r\n   _runtime: user_settings => {\r\n      NOVA.css.push(\r\n         [\r\n            \'yt-img-shadow\',\r\n            \'.ytp-title-channel-logo\',\r\n            \'#player .ytp-title-channel\',\r\n            \'ytm-profile-icon\',\r\n            \'a.ytd-thumbnail\',\r\n         ]\r\n            .join(\',\\n\') + ` {\r\n               border-radius: 0 !important;\r\n            }`);\r\n      NOVA.waitUntil(() => {\r\n         if (window.yt && (obj = yt?.config_?.EXPERIMENT_FLAGS) && Object.keys(obj).length) {\r\n            yt.config_.EXPERIMENT_FLAGS.web_rounded_thumbnails = false;\r\n            return true;\r\n         }\r\n      });\r\n   },\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'comments-visibility\',\r\n   title: \'Collapse comments section\',\r\n   run_on_pages: \'watch, -mobile\',\r\n   restart_on_location_change: true,\r\n   section: \'comments\',\r\n   _runtime: user_settings => {\r\n      NOVA.collapseElement({\r\n         selector: \'#comments\',\r\n         title: \'comments\',\r\n         remove: (user_settings.comments_visibility_mode == \'disable\') ? true : false,\r\n      });\r\n   },\r\n   options: {\r\n      comments_visibility_mode: {\r\n         _tagName: \'select\',\r\n         label: \'Mode\',\r\n         options: [\r\n            {\r\n               label: \'collapse\', value: \'hide\', selected: true,\r\n            },\r\n            {\r\n               label: \'remove\', value: \'disable\',\r\n            },\r\n         ],\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'metadata-hide\',\r\n   title: \'Hide metadata\',\r\n   run_on_pages: \'watch\',\r\n   section: \'details\',\r\n   desc: \'Cover link to games, movies, etc.\',\r\n   _runtime: user_settings => {\r\n      NOVA.css.push(\r\n         `ytd-watch-metadata > ytd-metadata-row-container-renderer {\r\n            display: none;\r\n         }`);\r\n   },\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'description-expand\',\r\n   title: \'Expand description\',\r\n   run_on_pages: \'watch, -mobile\',\r\n   section: \'details\',\r\n   _runtime: user_settings => {\r\n      if (user_settings[\'description-popup\']) return;\r\n      NOVA.watchElements({\r\n         selectors: [\r\n            \'#meta [collapsed] #more\',\r\n            \'[description-collapsed] #description #expand\',\r\n         ],\r\n         callback: btn => {\r\n            if (user_settings.description_expand_mode == \'onhover\') {\r\n               btn.addEventListener(\'mouseenter\', ({ target }) => btn.click(), { capture: true, once: true });\r\n            }\r\n            else {\r\n               btn.click();\r\n            }\r\n         }\r\n      });\r\n   },\r\n   options: {\r\n      description_expand_mode: {\r\n         _tagName: \'select\',\r\n         label: \'Mode\',\r\n         options: [\r\n            {\r\n               label: \'always\', value: \'always\', selected: true,\r\n            },\r\n            {\r\n               label: \'on hover\', value: \'onhover\',\r\n            },\r\n         ],\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'description-timestamps-scroll\',\r\n   title: \'No scroll to top when clicking timestamps\',\r\n   run_on_pages: \'watch, -mobile\',\r\n   section: \'details\',\r\n   desc: \'Disable scrolling to player when clicking on timestamps\',\r\n   _runtime: user_settings => {\r\n      document.addEventListener(\'click\', evt => {\r\n         if (evt.isTrusted && !evt.target.matches(\'a[href*=\"&t=\"]\')) return;\r\n         if (sec = parseInt(NOVA.queryURL.get(\'t\', evt.target.href))) {\r\n            evt.preventDefault();\r\n            evt.stopPropagation();\r\n            evt.stopImmediatePropagation();\r\n            movie_player.seekTo(sec);\r\n         }\r\n      }, { capture: true });\r\n   },\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'redirect-disable\',\r\n   title: \'Clear links from redirect\',\r\n   run_on_pages: \'watch, channel\',\r\n   section: \'details\',\r\n   desc: \'Direct external links\',\r\n   _runtime: user_settings => {\r\n      document.addEventListener(\'click\', ({ target }) => patchLink(target), { capture: true });\r\n      document.addEventListener(\'auxclick\', evt => evt.button === 1 && patchLink(evt.target), { capture: true });\r\n      function patchLink(target = required()) {\r\n         const linkSelector = \'a[href*=\"/redirect?\"]\';\r\n         if (!target.matches(linkSelector)) {\r\n            if (!(target = target.closest(linkSelector))) return;\r\n         }\r\n         if (q = NOVA.queryURL.get(\'q\', target.href)) {\r\n            target.href = decodeURIComponent(q);\r\n         }\r\n      }\r\n   },\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'details-buttons\',\r\n   title: \'Buttons\',\r\n   run_on_pages: \'watch, -mobile\',\r\n   section: \'details\',\r\n   _runtime: user_settings => {\r\n      if (user_settings.details_buttons_hide?.includes(\'subscribe\')) {\r\n         stylesList.push(\'#below #subscribe-button\');\r\n      }\r\n      if (user_settings.details_buttons_hide?.includes(\'all\')) {\r\n         return NOVA.css.push(\r\n            `ytd-watch-metadata #actions button {\r\n               display: none !important;\r\n            }`);\r\n      }\r\n      let styles = \'\';\r\n      if (user_settings.details_button_no_labels) {\r\n         styles +=\r\n            `ytd-watch-metadata #actions button .cbox {\r\n               display: none;\r\n            }\r\n            ytd-watch-metadata #actions button .yt-spec-button-shape-next__icon {\r\n               margin: 0 !important;\r\n            }\r\n            \r\n            ytd-watch-metadata #actions ytd-segmented-like-dislike-button-renderer ~ * button,\r\n            ytd-watch-metadata #actions #top-level-buttons-computed ~ * button.yt-spec-button-shape-next--size-m {\r\n               padding: 0 7px;\r\n            }`;\r\n      }\r\n      if (+user_settings.details_button_no_labels_opacity) {\r\n         styles +=\r\n            `#subscribe-button:not(:hover),\r\n            ytd-watch-metadata #actions #menu:not(:hover) {\r\n               transition: opacity .2s ease-in-out;\r\n               opacity: ${user_settings.details_button_no_labels_opacity || .1};\r\n            }`;\r\n      }\r\n      if (styles) {\r\n         NOVA.css.push(styles);\r\n      }\r\n      if (user_settings.details_buttons_hide?.length) {\r\n         const buttonSelectors = [\r\n            \'ytd-watch-metadata #menu ytd-button-renderer\',\r\n            \'ytd-watch-metadata #menu button\',\r\n            \'ytd-popup-container ytd-menu-service-item-renderer\',\r\n         ];\r\n         let stylesList = [];\r\n         if (user_settings.details_buttons_hide.includes(\'join\')) {\r\n            stylesList.push(\'#below #sponsor-button\');\r\n         }\r\n         if (user_settings.details_buttons_hide.includes(\'like_dislike\')) {\r\n            stylesList.push(\'ytd-watch-metadata #menu ytd-segmented-like-dislike-button-renderer\');\r\n         }\r\n         if (user_settings.details_buttons_hide.includes(\'dislike\')) {\r\n            stylesList.push(\'ytd-watch-metadata #menu #segmented-dislike-button\');\r\n            NOVA.css.push(\r\n               `ytd-watch-metadata #menu ytd-segmented-like-dislike-button-renderer button {\r\n                  border-radius: 100%;\r\n                  width: 40px;\r\n                  border: 0;\r\n               }`);\r\n         }\r\n         if (user_settings.details_buttons_hide.includes(\'download\')) {\r\n            stylesList.push(\'ytd-watch-metadata #menu ytd-download-button-renderer\');\r\n         }\r\n         if (user_settings.details_buttons_hide.includes(\'share\')) {\r\n            stylesList.push(buttonSelectors.map(e => `\\n${e}:has(path[d^=\"M15,5.63L20.66,12L15\"])`));\r\n         }\r\n         if (user_settings.details_buttons_hide.includes(\'thanks\')) {\r\n            stylesList.push(buttonSelectors.map(e => `\\n${e}:has(path[d^=\"M16.5,3C19.02,3,21,5.19,21\"])`));\r\n         }\r\n         if (user_settings.details_buttons_hide.includes(\'clip\')) {\r\n            stylesList.push(buttonSelectors.map(e => `\\n${e}:has(path[d^=\"M8,7c0,0.55-0.45\"])`));\r\n         }\r\n         if (user_settings.details_buttons_hide.includes(\'save\')) {\r\n            stylesList.push(buttonSelectors.map(e => `\\n${e}:has(path[d$=\"M2,16h8v-1H2V16z\"])`));\r\n         }\r\n         if (user_settings.details_buttons_hide.includes(\'report\')) {\r\n            stylesList.push(buttonSelectors.map(e => `\\n${e}:has(path[d$=\"L14,3z\"])`));\r\n         }\r\n         if (user_settings.details_buttons_hide.includes(\'transcript\')) {\r\n            stylesList.push(buttonSelectors.map(e => `\\n${e}:has(path[d^=\"M5,11h2v2H5V11z\"])`));\r\n         }\r\n         if (stylesList.length) {\r\n            NOVA.css.push(\r\n               stylesList.join(\',\\n\').trim() + ` {\r\n                  display: none !important;\r\n               }`);\r\n         }\r\n      }\r\n   },\r\n   options: {\r\n      details_button_no_labels: {\r\n         _tagName: \'input\',\r\n         label: \'Buttons without labels\',\r\n         type: \'checkbox\',\r\n         title: \'Requires support for css tag \":has()\"\',\r\n      },\r\n      details_button_no_labels_opacity: {\r\n         _tagName: \'input\',\r\n         label: \'Opacity\',\r\n         type: \'number\',\r\n         title: \'0 - disable\',\r\n         placeholder: \'0-1\',\r\n         step: .05,\r\n         min: 0,\r\n         max: 1,\r\n         value: .1,\r\n      },\r\n      details_buttons_hide: {\r\n         _tagName: \'select\',\r\n         label: \'Hide items\',\r\n         title: \'[Ctrl+Click] to select several\',\r\n         multiple: null,\r\n         size: 8,\r\n         options: [\r\n            {\r\n               label: \'subscribe\', value: \'subscribe\',\r\n            },\r\n            {\r\n               label: \'all (below)\', value: \'all\',\r\n            },\r\n            {\r\n               label: \'join\', value: \'join\',\r\n            },\r\n            {\r\n               label: \'like/dislike\', value: \'like_dislike\',\r\n            },\r\n            {\r\n               label: \'dislike\', value: \'dislike\',\r\n            },\r\n            {\r\n               label: \'share\', value: \'share\',\r\n            },\r\n            {\r\n               label: \'clip\', value: \'clip\',\r\n            },\r\n            {\r\n               label: \'save\', value: \'save\',\r\n            },\r\n            {\r\n               label: \'download\', value: \'download\',\r\n            },\r\n            {\r\n               label: \'thanks\', value: \'thanks\',\r\n            },\r\n            {\r\n               label: \'report\', value: \'report\',\r\n            },\r\n            {\r\n               label: \'transcript\', value: \'transcript\',\r\n            },\r\n         ],\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'description-popup\',\r\n   title: \'Description section in popup\',\r\n   run_on_pages: \'watch, -mobile\',\r\n   section: \'details\',\r\n   _runtime: user_settings => {\r\n      const\r\n         DESCRIPTION_SELECTOR = \'html:not(:fullscreen) ytd-watch-metadata #description.ytd-watch-metadata:not([hidden]):not(:empty)\',\r\n         DATE_SELECTOR_ID = \'nova-description-date\';\r\n      NOVA.waitSelector(\'#masthead-container\')\r\n         .then(masthead => {\r\n            NOVA.css.push(\r\n               `${DESCRIPTION_SELECTOR},\r\n               ${DESCRIPTION_SELECTOR}:before {\r\n                  position: fixed;\r\n                  top: ${masthead.offsetHeight || 56}px;\r\n                  right: 0;\r\n                  z-index: ${1 + Math.max(getComputedStyle(masthead || movie_player)[\'z-index\'], 601)};\r\n               }\r\n               \r\n               ${DESCRIPTION_SELECTOR}:not(:hover):before {\r\n                  content: \"info ▼\";\r\n                  cursor: pointer;\r\n                  visibility: visible;\r\n                  \r\n                  right: 12.5em;\r\n                  padding: 0 8px 2px;\r\n                  line-height: normal;\r\n                  font-family: Roboto, Arial, sans-serif;\r\n                  font-size: 11px;\r\n                  color: #eee;\r\n                  background: rgba(0,0,0,0.3);\r\n               }\r\n               \r\n               ${DESCRIPTION_SELECTOR} {\r\n                  margin: 0 1%;\r\n                  overflow-y: auto;\r\n                  max-height: 88vh;\r\n                  max-width: 55%;\r\n                  background-color: #222;\r\n                  border: 1px solid #333;\r\n                  border-radius: 0 !important;\r\n               }\r\n               ${DESCRIPTION_SELECTOR}:not(:hover) {\r\n                  visibility: collapse;\r\n                  overflow: hidden;\r\n               }\r\n               \r\n               ${DESCRIPTION_SELECTOR}:hover {\r\n                  visibility: visible !important;\r\n               }\r\n               \r\n               ${DESCRIPTION_SELECTOR}::-webkit-scrollbar {\r\n                  height: 8px;\r\n                  width: 10px;\r\n               }\r\n               ${DESCRIPTION_SELECTOR}::-webkit-scrollbar-button {\r\n                  height: 0;\r\n                  width: 0;\r\n               }\r\n               ${DESCRIPTION_SELECTOR}::-webkit-scrollbar-corner {\r\n                  background: transparent;\r\n               }\r\n               ${DESCRIPTION_SELECTOR}::-webkit-scrollbar-thumb {\r\n                  background: #e1e1e1;\r\n                  border: 0;\r\n                  border-radius: 0;\r\n               }\r\n               ${DESCRIPTION_SELECTOR}::-webkit-scrollbar-track {\r\n                  background: #666;\r\n                  border: 0;\r\n                  border-radius: 0;\r\n               }\r\n               ${DESCRIPTION_SELECTOR}::-webkit-scrollbar-track:hover {\r\n                  background: #666;\r\n               }`);\r\n         });\r\n      NOVA.runOnPageInitOrTransition(() => (NOVA.currentPage == \'watch\') && restoreDateLine());\r\n      NOVA.waitSelector(DESCRIPTION_SELECTOR)\r\n         .then(descriptionEl => {\r\n            descriptionEl.addEventListener(\'mouseenter\', evt => {\r\n               document.body.querySelector(\'#meta [collapsed] #more, [description-collapsed] #description #expand\')\r\n                  ?.click();\r\n            });\r\n         });\r\n      let oldDateText;\r\n      function restoreDateLine() {\r\n         NOVA.waitSelector(\'#title h1\')\r\n            .then(container => {\r\n               NOVA.waitSelector(\'ytd-watch-metadata #description.ytd-watch-metadata\')\r\n                  .then(async textDateEl => {\r\n                     await NOVA.waitUntil(() => {\r\n                        if ((text = [...textDateEl.querySelectorAll(\'span.bold.yt-formatted-string:not(:empty)\')]\r\n                           .map(e => e.textContent)\r\n                           ?.join(\'\').trim()\r\n                        )\r\n                           && text != oldDateText\r\n                        ) {\r\n                           oldDateText = text;\r\n                           insertToHTML({ \'text\': oldDateText, \'container\': container });\r\n                           return true;\r\n                        }\r\n                     }, 1000);\r\n                  });\r\n            });\r\n         function insertToHTML({ text = \'\', container = required() }) {\r\n            if (!(container instanceof HTMLElement)) return console.error(\'container not HTMLElement:\', container);\r\n            (document.getElementById(DATE_SELECTOR_ID) || (function () {\r\n               container.insertAdjacentHTML(\'afterend\',\r\n                  `<span id=\"${DATE_SELECTOR_ID}\" class=\"style-scope yt-formatted-string bold\" style=\"font-size: 1.35rem; line-height: 2rem; font-weight:400;\">${text}</span>`);\r\n               return document.getElementById(DATE_SELECTOR_ID);\r\n            })())\r\n               .textContent = text;\r\n         }\r\n      }\r\n   },\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'save-to-playlist\',\r\n   title: \'Add sort/filter to \"Save to playlist\" menu\',\r\n   run_on_pages: \'home, feed, channel, results, watch, -mobile\',\r\n   section: \'details\',\r\n   _runtime: user_settings => {\r\n      NOVA.waitSelector(\'tp-yt-paper-dialog #playlists\')\r\n         .then(playlists => {\r\n            const container = playlists.closest(\'tp-yt-paper-dialog\');\r\n            new IntersectionObserver(([entry]) => {\r\n               const searchInput = container.querySelector(\'input[type=search]\')\r\n               if (entry.isIntersecting) {\r\n                  if (user_settings.save_to_playlist_sort) sortPlaylistsMenu(playlists);\r\n                  if (!searchInput) insertFilterInput(playlists);\r\n               }\r\n               else if (searchInput) {\r\n                  searchInput.value = \'\';\r\n                  searchInput.dispatchEvent(new Event(\'change\'));\r\n               }\r\n            })\r\n               .observe(container);\r\n         });\r\n      function sortPlaylistsMenu(playlists = required()) {\r\n         if (!(playlists instanceof HTMLElement)) return console.error(\'playlists not HTMLElement:\', playlists);\r\n         playlists.append(\r\n            ...Array.from(playlists.childNodes)\r\n               .sort(sortByLabel)\r\n         );\r\n         function sortByLabel(a, b) {\r\n            const getLabel = el => el.innerText.trim();\r\n            return stringLocaleCompare(getLabel(a), getLabel(b));\r\n            function stringLocaleCompare(a = required(), b = required()) {\r\n               return a.localeCompare(b, undefined, { numeric: true, sensitivity: \'base\' });\r\n            }\r\n         }\r\n      }\r\n      function insertFilterInput(container = required()) {\r\n         if (!(container instanceof HTMLElement)) return console.error(\'container not HTMLElement:\', container);\r\n         const searchInput = document.createElement(\'input\');\r\n         searchInput.setAttribute(\'type\', \'search\');\r\n         searchInput.setAttribute(\'placeholder\', \'Playlist Filter\');\r\n         Object.assign(searchInput.style, {\r\n            padding: \'.4em .6em\',\r\n            border: 0,\r\n            outline: 0,\r\n            width: \'100%\',\r\n            \'margin-bottom\': \'1.5em\',\r\n            height: \'2.5em\',\r\n            color: \'var(--ytd-searchbox-text-color)\',\r\n            \'background-color\': \'var(--ytd-searchbox-background)\',\r\n         });\r\n         [\'change\', \'keyup\'].forEach(evt => {\r\n            searchInput\r\n               .addEventListener(evt, function () {\r\n                  NOVA.searchFilterHTML({\r\n                     \'keyword\': this.value,\r\n                     \'filter_selectors\': \'#playlists #checkbox\',\r\n                     \'highlight_selector\': \'#label\',\r\n                  });\r\n               });\r\n            searchInput\r\n               .addEventListener(\'click\', () => {\r\n                  searchInput.value = \'\';\r\n                  searchInput.dispatchEvent(new Event(\'change\'));\r\n               });\r\n         });\r\n         container.prepend(searchInput);\r\n      };\r\n   },\r\n   options: {\r\n      save_to_playlist_sort: {\r\n         _tagName: \'input\',\r\n         label: \'Default sorting alphabetically\',\r\n         type: \'checkbox\',\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'channel-videos-count\',\r\n   title: \'Show channel videos count\',\r\n   run_on_pages: \'watch, -mobile\',\r\n   restart_on_location_change: true,\r\n   section: \'details\',\r\n   opt_api_key_warn: true,\r\n   desc: \'Display uploaded videos on channel\',\r\n   _runtime: user_settings => {\r\n      const\r\n         CACHE_PREFIX = \'nova-channel-videos-count:\',\r\n         SELECTOR_ID = \'nova-video-count\';\r\n      NOVA.waitSelector(\'#upload-info #owner-sub-count, ytm-slim-owner-renderer .subhead\', { stop_on_page_change: true })\r\n         .then(el => setVideoCount(el));\r\n      async function setVideoCount(container = required()) {\r\n         await NOVA.delay(500);\r\n         const channelId = NOVA.getChannelId();\r\n         if (!channelId) return console.error(\'setVideoCount channelId: empty\', channelId);\r\n         if (storage = sessionStorage.getItem(CACHE_PREFIX + channelId)) {\r\n            insertToHTML({ \'text\': storage, \'container\': container });\r\n         }\r\n         else {\r\n            NOVA.request.API({\r\n               request: \'channels\',\r\n               params: { \'id\': channelId, \'part\': \'statistics\' },\r\n               api_key: user_settings[\'user-api-key\'],\r\n            })\r\n               .then(res => {\r\n                  if (res?.error) return alert(`Error [${res.code}]: ${res.reason}\\n` + res.error);\r\n                  res?.items?.forEach(item => {\r\n                     if (videoCount = NOVA.prettyRoundInt(item.statistics.videoCount)) {\r\n                        insertToHTML({ \'text\': videoCount, \'container\': container });\r\n                        sessionStorage.setItem(CACHE_PREFIX + channelId, videoCount);\r\n                     } else console.warn(\'API is change\', item);\r\n                  });\r\n               });\r\n         }\r\n         function insertToHTML({ text = \'\', container = required() }) {\r\n            if (!(container instanceof HTMLElement)) return console.error(\'container not HTMLElement:\', container);\r\n            (document.getElementById(SELECTOR_ID) || (function () {\r\n               container.insertAdjacentHTML(\'beforeend\',\r\n                  `<span class=\"date style-scope ytd-video-secondary-info-renderer\" style=\"margin-right:5px;\"> • <span id=\"${SELECTOR_ID}\">${text}</span> videos</span>`);\r\n               return document.getElementById(SELECTOR_ID);\r\n            })())\r\n               .textContent = text;\r\n            container.title = `${text} videos`;\r\n         }\r\n      }\r\n   },\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'video-date-format\',\r\n   title: \'Show date format\',\r\n   run_on_pages: \'watch, -mobile\',\r\n   section: \'details\',\r\n   opt_api_key_warn: true,\r\n   _runtime: user_settings => {\r\n      if (user_settings[\'description-popup\']) return\r\n      const\r\n         CACHE_PREFIX = \'nova-video-date:\',\r\n         DATE_SELECTOR_ID = \'nova-video-published-date\';\r\n      NOVA.runOnPageInitOrTransition(() => {\r\n         if (NOVA.currentPage == \'watch\') {\r\n            NOVA.waitSelector(\'#title h1\', { stop_on_page_change: true })\r\n               .then(el => setVideoDate(el));\r\n         }\r\n      });\r\n      function setVideoDate(container = required()) {\r\n         const videoId = movie_player.getVideoData().video_id || NOVA.queryURL.get(\'v\');\r\n         if (storage = sessionStorage.getItem(CACHE_PREFIX + videoId)) {\r\n            insertToHTML({ \'text\': storage, \'container\': container });\r\n         }\r\n         NOVA.request.API({\r\n            request: \'videos\',\r\n            params: { \'id\': videoId, \'part\': \'snippet,liveStreamingDetails\' },\r\n            api_key: user_settings[\'user-api-key\'],\r\n         })\r\n            .then(res => {\r\n               if (res?.error) return alert(`Error [${res.code}]: ${res.reason}\\n` + res.error);\r\n               res?.items?.forEach(item => {\r\n                  let innerHTML = \'\';\r\n                  if (item.snippet.publishedAt) {\r\n                     innerHTML = NOVA.dateformat.apply(new Date(item.snippet.publishedAt), [user_settings.video_date_format]);\r\n                  }\r\n                  if (item.liveStreamingDetails) {\r\n                     const\r\n                        ACTIVE_LIVE_START = \'Active Livestream since \',\r\n                        ENDED_STREAM_START = `${movie_player.getVideoData().isLive ? \'Livestream\' : \'Premiere\'} from `,\r\n                        DATETIME_UNTIL_PATTERN = \' until \';\r\n                     if (item.liveStreamingDetails.actualStartTime && item.liveStreamingDetails.actualEndTime) {\r\n                        const\r\n                           timeStart = new Date(item.liveStreamingDetails.actualStartTime),\r\n                           timeEnd = new Date(item.liveStreamingDetails.actualEndTime);\r\n                        innerHTML = ENDED_STREAM_START\r\n                           + NOVA.dateformat.apply(timeStart, [user_settings.video_date_format]);\r\n                        innerHTML += DATETIME_UNTIL_PATTERN\r\n                           + NOVA.dateformat.apply(timeEnd, [\r\n                              timeStart.getDay() === timeEnd.getDay()\r\n                                 ? user_settings.video_date_format.split(\' at \')[1]\r\n                                 : user_settings.video_date_format\r\n                           ]);\r\n                     }\r\n                     else if (item.liveStreamingDetails.scheduledStartTime) {\r\n                        innerHTML = ACTIVE_LIVE_START\r\n                           + NOVA.dateformat.apply(new Date(item.liveStreamingDetails.scheduledStartTime), [user_settings.video_date_format]);\r\n                     }\r\n                  }\r\n                  if (innerHTML) {\r\n                     insertToHTML({ \'text\': innerHTML, \'container\': container });\r\n                     sessionStorage.setItem(CACHE_PREFIX + videoId, innerHTML);\r\n                  }\r\n               });\r\n            });\r\n         function insertToHTML({ text = \'\', container = required() }) {\r\n            if (!(container instanceof HTMLElement)) return console.error(\'container not HTMLElement:\', container);\r\n            (document.getElementById(DATE_SELECTOR_ID) || (function () {\r\n               container.insertAdjacentHTML(\'afterend\',\r\n                  `<span id=\"${DATE_SELECTOR_ID}\" class=\"style-scope yt-formatted-string bold\" style=\"font-size: 1.35rem; line-height: 2rem; font-weight:400;\">${text}</span>`);\r\n               return document.getElementById(DATE_SELECTOR_ID);\r\n            })())\r\n               .textContent = text;\r\n         }\r\n      }\r\n   },\r\n   options: {\r\n      video_date_format: {\r\n         _tagName: \'select\',\r\n         label: \'Date pattern\',\r\n         options: [\r\n            { label: \'D MMM Y\', value: \'D MMM YYYY\' },\r\n            { label: \'D MMM Y HH:mm:ss\', value: \'D MMM YYYY at HH:mm:ss\', selected: true },\r\n            { label: \'DDD DD/MM/YYYY\', value: \'DDD DD/MM/YYYY HH:mm:ss\' },\r\n            { label: \'DDDD DD/MM/YYYY\', value: \'DDDD DD/MM/YYYY HH:mm:ss\' },\r\n            { label: \'Y/MM/DD\', value: \'YYYY/MM/DD\' },\r\n            { label: \'Y-MM-D\', value: \'YYYY-MM-D\' },\r\n            { label: \'Y.MM.D\', value: \'YYYY.MM.D\' },\r\n            { label: \'MM/DD/Y\', value: \'MM/DD/YYYY\' },\r\n            { label: \'MM/DD/Y HH:mm:ss\', value: \'MM/DD/YYYY at HH:mm:ss\' },\r\n            { label: \'MM-D-Y\', value: \'MM-D-YYYY\' },\r\n            { label: \'MM-D-Y HH:mm:ss\', value: \'MM-D-YYYY at HH:mm:ss\' },\r\n            { label: \'MM.D.Y\', value: \'MM.D.YYYY\' },\r\n            { label: \'MM.D.Y HH:mm:ss\', value: \'MM.D.YYYY at HH:mm:ss\' },\r\n         ],\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'return-dislike\',\r\n   title: \'Show dislike count\',\r\n   run_on_pages: \'watch, -mobile\',\r\n   section: \'details\',\r\n   _runtime: user_settings => {\r\n      if (user_settings.details_button_no_labels\r\n         || user_settings.details_buttons_hide?.includes(\'like_dislike\')\r\n      ) {\r\n         return;\r\n      }\r\n      const\r\n         CACHE_PREFIX = \'nova-dislikes-count:\',\r\n         SELECTOR_ID = \'nova-dislikes-count\';\r\n      NOVA.runOnPageInitOrTransition(() => {\r\n         if (NOVA.currentPage == \'watch\') {\r\n            NOVA.waitSelector(\'ytd-watch-metadata #menu #segmented-dislike-button button\', { stop_on_page_change: true })\r\n               .then(el => setDislikeCount(el));\r\n         }\r\n      });\r\n      async function setDislikeCount(container = required()) {\r\n         const videoId = movie_player.getVideoData().video_id || NOVA.queryURL.get(\'v\');\r\n         if (!videoId) return console.error(\'return-dislike videoId: empty\', videoId);\r\n         container.style.width = \'auto\';\r\n         if (storage = sessionStorage.getItem(CACHE_PREFIX + videoId)) {\r\n            insertToHTML({ \'text\': storage, \'container\': container });\r\n         }\r\n         else if (dislikeCount = await getDislikeCount()) {\r\n            insertToHTML({ \'text\': dislikeCount, \'container\': container });\r\n         }\r\n         async function getDislikeCount() {\r\n            const videoId = movie_player.getVideoData().video_id || NOVA.queryURL.get(\'v\');\r\n            const fetchAPI = () => fetch(`https://returnyoutubedislikeapi.com/votes?videoId=${videoId}`,\r\n               {\r\n                  method: \'GET\',\r\n                  headers: { \'Content-Type\': \'application/json\' }\r\n               }\r\n            )\r\n               .then(response => response.json())\r\n               .then(json => json.dislikes)\r\n               .catch(error => {\r\n               });\r\n            if (result = await fetchAPI()) {\r\n               sessionStorage.setItem(CACHE_PREFIX + videoId, JSON.stringify(result));\r\n               return result;\r\n            }\r\n         }\r\n         function insertToHTML({ text = \'\', container = required() }) {\r\n            if (!(container instanceof HTMLElement)) return console.error(\'container not HTMLElement:\', container);\r\n            (document.getElementById(SELECTOR_ID) || (function () {\r\n               container.insertAdjacentHTML(\'beforeend\',\r\n                  `<span id=\"${SELECTOR_ID}\" style=\"text-overflow:ellipsis; overflow:visible; white-space:nowrap; padding-left:3px;\">${text}</span>`);\r\n               return document.getElementById(SELECTOR_ID);\r\n            })())\r\n               .textContent = text;\r\n            container.title = text;\r\n         }\r\n      }\r\n   },\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'page-logo\',\r\n   title: \'YouTube logo link\',\r\n   \'title:zh\': \'YouTube 徽标\',\r\n   \'title:ja\': \'YouTubeロゴ\',\r\n   \'title:ko\': \'유튜브 로고\',\r\n   \'title:ua\': \'YouTube лого\',\r\n   run_on_pages: \'*, -embed, -mobile, -live_chat\',\r\n   section: \'header\',\r\n   _runtime: user_settings => {\r\n      NOVA.waitSelector(\'#masthead a#logo\')\r\n         .then(a => a.href = new URL(user_settings.page_logo_url_mode)?.href);\r\n   },\r\n   options: {\r\n      page_logo_url_mode: {\r\n         _tagName: \'input\',\r\n         label: \'URL\',\r\n         type: \'url\',\r\n         pattern: \"https://.*\",\r\n         placeholder: \'https://youtube.com/...\',\r\n         value: \'https://youtube.com/feed/subscriptions\',\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'search-query\',\r\n   title: \'Search filter\',\r\n   \'title:zh\': \'搜索过滤器\',\r\n   \'title:ja\': \'検索フィルター\',\r\n   \'title:ko\': \'검색 필터\',\r\n   \'title:id\': \'Filter pencarian\',\r\n   \'title:es\': \'Filtros de búsqueda\',\r\n   \'title:pt\': \'Filtros de pesquisa\',\r\n   \'title:fr\': \'Filtres de recherche\',\r\n   \'title:it\': \'Filtri di ricerca\',\r\n   \'title:de\': \'Suchfilter\',\r\n   \'title:pl\': \'Filtry wyszukiwania\',\r\n   \'title:ua\': \'Фільтр пошуку\',\r\n   run_on_pages: \'results\',\r\n   restart_on_location_change: true,\r\n   section: \'header\',\r\n   _runtime: user_settings => {\r\n      if (!NOVA.queryURL.has(\'sp\')\r\n         && (sp = user_settings.search_query_date || user_settings.search_query_sort)\r\n      ) {\r\n         location.href = NOVA.queryURL.set({ \'sp\': sp });\r\n      }\r\n   },\r\n   options: {\r\n      search_query_sort: {\r\n         _tagName: \'select\',\r\n         label: \'Sort by\',\r\n         \'label:zh\': \'排序方式\',\r\n         \'label:ja\': \'並び替え\',\r\n         \'label:ko\': \'정렬 기준\',\r\n         \'label:id\': \'Sortir dengan\',\r\n         \'label:es\': \'Ordenar por\',\r\n         \'label:pt\': \'Ordenar por\',\r\n         \'label:fr\': \'Trier par\',\r\n         \'label:it\': \'Ordina per\',\r\n         \'label:de\': \'Sortieren nach\',\r\n         \'label:pl\': \'Sortuj według\',\r\n         \'label:ua\': \'Сортувати за\',\r\n         options: [\r\n            {\r\n               label: \'relevance\', value: false, selected: true,\r\n               \'label:ua\': \'актуальність\',\r\n            },\r\n            {\r\n               label: \'upload date\', value: \'cai%253d\',\r\n               \'label:ua\': \'дата завантаження\',\r\n            },\r\n            {\r\n               label: \'view count\', value: \'cam%253d\',\r\n               \'label:ua\': \'кількість переглядів\',\r\n            },\r\n            {\r\n               label: \'rating\', value: \'cae%253d\',\r\n               \'label:ua\': \'вподобайки\',\r\n            },\r\n         ],\r\n         \'data-dependent\': { \'search_query_date\': false },\r\n      },\r\n      search_query_date: {\r\n         _tagName: \'select\',\r\n         label: \'Upload date\',\r\n         \'label:zh\': \'上传日期\',\r\n         \'label:ja\': \'アップロード日\',\r\n         \'label:ko\': \'업로드 날짜\',\r\n         \'label:id\': \'Tanggal unggah\',\r\n         \'label:es\': \'Fecha de carga\',\r\n         \'label:pt\': \'data de upload\',\r\n         \'label:fr\': \'Date de dépôt\',\r\n         \'label:it\': \'data di caricamento\',\r\n         \'label:de\': \'Datum des Hochladens\',\r\n         \'label:pl\': \'Data przesłania\',\r\n         \'label:ua\': \'Дата завантаження\',\r\n         options: [\r\n            {\r\n               label: \'all time\', value: false, selected: true,\r\n               \'label:ua\': \'за увесь час\',\r\n            },\r\n            {\r\n               label: \'last hour\', value: \'egiiaq%253d%253d\',\r\n               \'label:ua\': \'за останню годину\',\r\n            },\r\n            {\r\n               label: \'today\', value: \'egiiag%253d%253d\',\r\n               \'label:ua\': \'сьогодні\',\r\n            },\r\n            {\r\n               label: \'this week\', value: \'egiiaw%253d%253d\',\r\n               \'label:ua\': \'цього тижня\',\r\n            },\r\n            {\r\n               label: \'this month\', value: \'egiiba%253d%253d\',\r\n               \'label:ua\': \'цього місяця\',\r\n            },\r\n            {\r\n               label: \'this year\', value: \'egiibq%253d%253d\',\r\n               \'label:ua\': \'цього року\',\r\n            },\r\n         ],\r\n         \'data-dependent\': { \'search_query_sort\': false },\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'header-compact\',\r\n   title: \'Header compact\',\r\n   \'title:zh\': \'标题紧凑\',\r\n   \'title:ja\': \'ヘッダーコンパクト\',\r\n   \'title:ko\': \'헤더 컴팩트\',\r\n   \'title:id\': \'Kompak tajuk\',\r\n   \'title:es\': \'Encabezado compacto\',\r\n   \'title:pt\': \'Cabeçalho compacto\',\r\n   \'title:fr\': \'En-tête compact\',\r\n   \'title:it\': \'Testata compatta\',\r\n   \'title:de\': \'Header kompakt\',\r\n   \'title:pl\': \'Kompaktowy nagłówek\',\r\n   \'title:ua\': \'Компактна шапка сайту\',\r\n   run_on_pages: \'*, -embed, -mobile, -live_chat\',\r\n   section: \'header\',\r\n   _runtime: user_settings => {\r\n      const height = \'36px\';\r\n      NOVA.css.push(\r\n         `#masthead #container.ytd-masthead {\r\n            max-height: ${height} !important;\r\n         }\r\n         \r\n         #masthead #background {\r\n            max-height: ${height} !important;\r\n         }\r\n         #search-form, #search-icon-legacy {\r\n            max-height: ${height} !important;\r\n         }\r\n         body,\r\n         html:not(:fullscreen) #page-manager {\r\n            --ytd-masthead-height: ${height};\r\n         }\r\n         #chips-wrapper.ytd-feed-filter-chip-bar-renderer {\r\n            --ytd-rich-grid-chips-bar-top: ${height};\r\n         }`);\r\n   },\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'header-unfixed\',\r\n   title: \'Header unpinned\',\r\n   \'title:zh\': \'标题未固定\',\r\n   \'title:ja\': \'ヘッダーは固定されていません\',\r\n   \'title:ko\': \'헤더가 고정되지 않음\',\r\n   \'title:id\': \'Tajuk tidak diperbaiki\',\r\n   \'title:es\': \'Encabezado sin arreglar\',\r\n   \'title:pt\': \'Cabeçalho não corrigido\',\r\n   \'title:fr\': \'En-tête non corrigé\',\r\n   \'title:it\': \'Intestazione non fissata\',\r\n   \'title:de\': \'Kopfleiste nicht fixiert\',\r\n   \'title:pl\': \'Przewijany nagłówek\',\r\n   \'title:ua\': \'Відкріпити шапку сайту\',\r\n   run_on_pages: \'*, -embed, -mobile, -live_chat\',\r\n   section: \'header\',\r\n   desc: \'Prevent header from sticking\',\r\n   \'desc:zh\': \'防止头部粘连\',\r\n   \'desc:ja\': \'ヘッダーがくっつくのを防ぎます\',\r\n   \'desc:ko\': \'헤더가 달라붙는 것을 방지\',\r\n   \'desc:id\': \'Mencegah header menempel\',\r\n   \'desc:es\': \'Evita que el cabezal se pegue\',\r\n   \'desc:pt\': \'Impede que o cabeçalho grude\',\r\n   \'desc:fr\': \"Empêcher l\'en-tête de coller\",\r\n   \'desc:it\': \"Impedisci che l\'intestazione si attacchi\",\r\n   \'desc:de\': \'Verhindert das Ankleben des Headers\',\r\n   \'desc:pl\': \'Nagłówek będzie przewijany wraz ze stroną\',\r\n   \'desc:ua\': \'Відкріпляє шапку при прокрутці сайту\',\r\n   _runtime: user_settings => {\r\n      const\r\n         CLASS_NAME_TOGGLE = \'nova-header-unfixed\',\r\n         SELECTOR = \'html.\' + CLASS_NAME_TOGGLE;\r\n      NOVA.css.push(\r\n         `${SELECTOR} #masthead-container {\r\n            position: absolute !important;\r\n         }\r\n         ${SELECTOR} #chips-wrapper {\r\n            position: sticky !important;\r\n         }\r\n         ${SELECTOR} #header {\r\n            margin-top: 0 !important;\r\n         }`);\r\n      document.documentElement.classList.add(CLASS_NAME_TOGGLE);\r\n      if (user_settings.header_unfixed_hotkey) {\r\n         const hotkey = user_settings.header_unfixed_hotkey || \'v\';\r\n         document.addEventListener(\'keyup\', evt => {\r\n            if ([\'input\', \'textarea\', \'select\'].includes(evt.target.localName) || evt.target.isContentEditable) return;\r\n            if (evt.key === hotkey) {\r\n               document.documentElement.classList.toggle(CLASS_NAME_TOGGLE);\r\n            }\r\n         });\r\n      }\r\n      if (user_settings.header_unfixed_scroll) {\r\n         createArrowButton();\r\n         document.addEventListener(\'yt-action\', evt => {\r\n            if (evt.detail?.actionName == \'yt-store-grafted-ve-action\'\r\n            ) {\r\n               scrollAfter();\r\n            }\r\n         });\r\n         function scrollAfter() {\r\n            if ((masthead = document.getElementById(\'masthead\'))\r\n               && (topOffset = masthead.offsetHeight)\r\n               && NOVA.isInViewport(masthead)\r\n            ) {\r\n               window.scrollTo({ top: topOffset });\r\n            }\r\n         }\r\n         function createArrowButton() {\r\n            const scrollDownButton = document.createElement(\'button\');\r\n            scrollDownButton.textContent = \'▼\';\r\n            scrollDownButton.title = \'Scroll down\';\r\n            Object.assign(scrollDownButton.style, {\r\n               cursor: \'pointer\',\r\n               background: \'transparent\',\r\n               color: \'deepskyblue\',\r\n               border: \'none\',\r\n            });\r\n            scrollDownButton.onclick = scrollAfter;\r\n            if (endnode = document.getElementById(\'end\')) {\r\n               endnode.parentElement.insertBefore(scrollDownButton, endnode);\r\n            }\r\n         }\r\n      }\r\n   },\r\n   options: {\r\n      header_unfixed_scroll: {\r\n         _tagName: \'input\',\r\n         label: \'Scroll after header\',\r\n         \'label:zh\': \'在标题后滚动\',\r\n         \'label:ja\': \'ヘッダーの後にスクロール\',\r\n         \'label:ko\': \'헤더 뒤 스크롤\',\r\n         \'label:id\': \'Gulir setelah tajuk\',\r\n         \'label:es\': \'Desplazarse después del encabezado\',\r\n         \'label:pt\': \'Role após o cabeçalho\',\r\n         \'label:fr\': \"Faire défiler après l\'en-tête\",\r\n         \'label:it\': \"Scorri dopo l\'intestazione\",\r\n         \'label:de\': \'Nach der Kopfzeile scrollen\',\r\n         \'label:pl\': \'Przewiń nagłówek\',\r\n         \'label:ua\': \'Прокручувати після шапки сайту\',\r\n         title: \'Makes sense on a small screen\',\r\n         \'title:zh\': \'在小屏幕上有意义\',\r\n         \'title:ja\': \'小さな画面で意味があります\',\r\n         \'title:ko\': \'작은 화면에서 이해하기\',\r\n         \'title:id\': \'Masuk akal di layar kecil\',\r\n         \'title:es\': \'Tiene sentido en una pantalla pequeña\',\r\n         \'title:pt\': \'Faz sentido em uma tela pequena\',\r\n         \'title:fr\': \'A du sens sur un petit écran\',\r\n         \'title:it\': \'Ha senso su un piccolo schermo\',\r\n         \'title:de\': \'Macht auf einem kleinen Bildschirm Sinn\',\r\n         \'title:pl\': \'Przydatne na małym ekranie\',\r\n         \'title:ua\': \'Ефективно на малому екрані\',\r\n         type: \'checkbox\',\r\n      },\r\n      header_unfixed_hotkey: {\r\n         _tagName: \'select\',\r\n         label: \'Hotkey toggle\',\r\n         \'label:ua\': \'Перемикання гарячою клавішею\',\r\n         options: [\r\n            { label: \'V\', value: \'v\', selected: true },\r\n            \'a\', \'b\', \'c\', \'d\', \'e\', \'f\', \'g\', \'h\', \'i\', \'j\', \'k\', \'l\', \'m\', \'n\', \'o\', \'p\', \'q\', \'r\', \'s\', \'t\', \'u\', \'w\', \'x\', \'y\', \'z\', \']\', \'[\', \'+\', \'-\', \',\', \'.\', \'/\', \'<\', \';\', \'\\\\\'\r\n         ],\r\n      },\r\n   },\r\n});\r\nconst NOVA = {\r\n   waitSelector(selector = required(), limit_data) {\r\n      if (typeof selector !== \'string\') return console.error(\'wait > selector:\', typeof selector);\r\n      if (limit_data?.container && !(limit_data.container instanceof HTMLElement)) return console.error(\'wait > container not HTMLElement:\', limit_data.container);\r\n      if (selector.includes(\':has(\') && !CSS.supports(\'selector(:has(*))\')) {\r\n         return new Promise((resolve, reject) => {\r\n            console.warn(\'CSS \":has()\" unsupported\');\r\n            reject(\'CSS \":has()\" unsupported\');\r\n         });\r\n      }\r\n      return new Promise(resolve => {\r\n         if (element = (limit_data?.container || document.body || document).querySelector(selector)) {\r\n            return resolve(element);\r\n         }\r\n         const observer1 = new MutationObserver((mutationRecordsArray, observer) => {\r\n            for (const record of mutationRecordsArray) {\r\n               for (const node of record.addedNodes) {\r\n                  if (![1, 3, 8].includes(node.nodeType) || !(node instanceof HTMLElement)) continue;\r\n                  if (node.matches && node.matches(selector)) {\r\n                     observer.disconnect();\r\n                     return resolve(node);\r\n                  }\r\n                  else if (\r\n                     (parentEl = node.parentElement || node)\r\n                     && (parentEl instanceof HTMLElement)\r\n                     && (element = parentEl.querySelector(selector))\r\n                  ) {\r\n                     observer.disconnect();\r\n                     return resolve(element);\r\n                  }\r\n               }\r\n            }\r\n            if (document?.readyState != \'loading\'\r\n               && (element = (limit_data?.container || document?.body || document).querySelector(selector))\r\n            ) {\r\n               observer.disconnect();\r\n               return resolve(element);\r\n            }\r\n         })\r\n         observer1\r\n            .observe(limit_data?.container || document.body || document.documentElement || document, {\r\n               childList: true,\r\n               subtree: true,\r\n               attributes: true,\r\n            });\r\n         if (limit_data?.stop_on_page_change) {\r\n            isURLChange();\r\n            window.addEventListener(\'transitionend\', ({ target }) => {\r\n               if (isURLChange()) {\r\n                  observer1.disconnect();\r\n               }\r\n            });\r\n            function isURLChange() {\r\n               return (this.prevURL === location.href) ? false : this.prevURL = location.href;\r\n            }\r\n         }\r\n      });\r\n   },\r\n   waitUntil(condition = required(), timeout = 100) {\r\n      if (typeof condition !== \'function\') return console.error(\'waitUntil > condition is not fn:\', typeof condition);\r\n      return new Promise((resolve) => {\r\n         if (result = condition()) {\r\n            resolve(result);\r\n         }\r\n         else {\r\n            const interval = setInterval(() => {\r\n               if (result = condition()) {\r\n                  clearInterval(interval);\r\n                  resolve(result);\r\n               }\r\n            }, timeout);\r\n         }\r\n      });\r\n   },\r\n   delay(ms = 100) {\r\n      return new Promise(resolve => setTimeout(resolve, ms));\r\n   },\r\n   watchElements_list: {},\r\n   watchElements({ selectors = required(), attr_mark, callback = required() }) {\r\n      if (!Array.isArray(selectors) && typeof selectors !== \'string\') return console.error(\'watch > selector:\', typeof selectors);\r\n      if (typeof callback !== \'function\') return console.error(\'watch > callback:\', typeof callback);\r\n      this.waitSelector((typeof selectors === \'string\') ? selectors : selectors.join(\',\'))\r\n         .then(video => {\r\n            !Array.isArray(selectors) && (selectors = selectors.split(\',\').map(s => s.trim()));\r\n            process();\r\n            this.watchElements_list[attr_mark] = setInterval(() =>\r\n               document.visibilityState == \'visible\' && process(), 1000 * 1.5);\r\n            function process() {\r\n               selectors\r\n                  .forEach(selectorItem => {\r\n                     if (selectorItem.includes(\':has(\') && !CSS.supports(\'selector(:has(*))\')) {\r\n                        return console.warn(\'CSS \":has()\" unsupported\');\r\n                     }\r\n                     if (attr_mark) selectorItem += `:not([${attr_mark}])`;\r\n                     document.body.querySelectorAll(selectorItem)\r\n                        .forEach(el => {\r\n                           if (attr_mark) el.setAttribute(attr_mark, true);\r\n                           callback(el);\r\n                        });\r\n                  });\r\n            }\r\n         });\r\n   },\r\n   runOnPageInitOrTransition(callback) {\r\n      if (!callback || typeof callback !== \'function\') {\r\n         return console.error(\'runOnPageInitOrTransition > callback not function:\', ...arguments);\r\n      }\r\n      let prevURL = location.href;\r\n      const isURLChange = () => (prevURL === location.href) ? false : prevURL = location.href;\r\n      isURLChange() || callback();\r\n      document.addEventListener(\'yt-navigate-finish\', () => isURLChange() && callback());\r\n   },\r\n   css: {\r\n      push(css = required(), selector, important) {\r\n         if (typeof css === \'object\') {\r\n            if (!selector) return console.error(\'injectStyle > empty json-selector:\', ...arguments);\r\n            injectCss(selector + json2css(css));\r\n            function json2css(obj) {\r\n               let css = \'\';\r\n               Object.entries(obj)\r\n                  .forEach(([key, value]) => {\r\n                     css += key + \':\' + value + (important ? \' !important\' : \'\') + \';\';\r\n                  });\r\n               return `{ ${css} }`;\r\n            }\r\n         }\r\n         else if (css && typeof css === \'string\') {\r\n            if (document.head) {\r\n               injectCss(css);\r\n            }\r\n            else {\r\n               window.addEventListener(\'load\', () => injectCss(css), { capture: true, once: true });\r\n            }\r\n         }\r\n         else {\r\n            console.error(\'addStyle > css:\', typeof css);\r\n         }\r\n         function injectCss(source = required()) {\r\n            let sheet;\r\n            if (source.endsWith(\'.css\')) {\r\n               sheet = document.createElement(\'link\');\r\n               sheet.rel = \'sheet\';\r\n               sheet.href = source;\r\n            }\r\n            else {\r\n               const sheetId = \'NOVA-style\';\r\n               sheet = document.getElementById(sheetId) || (function () {\r\n                  const style = document.createElement(\'style\');\r\n                  style.type = \'text/css\';\r\n                  style.id = sheetId;\r\n                  return (document.head || document.documentElement).appendChild(style);\r\n               })();\r\n            }\r\n            sheet.textContent += \'\\n\' + source\r\n               .replace(/\\n+\\s{2,}/g, \' \')\r\n               + \'\\n\';\r\n         }\r\n      },\r\n      getValue(selector = required(), prop_name = required()) {\r\n         return (el = (selector instanceof HTMLElement) ? selector : document.body?.querySelector(selector))\r\n            ? getComputedStyle(el).getPropertyValue(prop_name) : null;\r\n      },\r\n   },\r\n   prettyRoundInt(num) {\r\n      num = +num;\r\n      if (num === 0) return \'\';\r\n      if (num < 1000) return num;\r\n      const sizes = [\'\', \'K\', \'M\', \'B\'];\r\n      const i = ~~(Math.log(Math.abs(num)) / Math.log(1000));\r\n      if (!sizes[i]) return num;\r\n      return round(num / 1000 ** i, 1) + sizes[i];\r\n      function round(n, precision = 2) {\r\n         const prec = 10 ** precision;\r\n         return ~~(n * prec) / prec;\r\n      }\r\n   },\r\n   isInViewport(el = required()) {\r\n      if (!(el instanceof HTMLElement)) return console.error(\'el is not HTMLElement type:\', el);\r\n      if (bounding = el.getBoundingClientRect()) {\r\n         return (\r\n            bounding.top >= 0 &&\r\n            bounding.left >= 0 &&\r\n            bounding.bottom <= window.innerHeight &&\r\n            bounding.right <= window.innerWidth\r\n         );\r\n      }\r\n   },\r\n   collapseElement({ selector = required(), title = required(), remove }) {\r\n      const selector_id = `${title.match(/[a-z]+/gi).join(\'\')}-prevent-load-btn`;\r\n      this.waitSelector(selector.toString())\r\n         .then(el => {\r\n            if (remove) el.remove();\r\n            else {\r\n               if (document.getElementById(selector_id)) return;\r\n               el.style.display = \'none\';\r\n               const btn = document.createElement(\'a\');\r\n               btn.textContent = `Load ${title}`;\r\n               btn.id = selector_id;\r\n               btn.className = \'more-button style-scope ytd-video-secondary-info-renderer\';\r\n               Object.assign(btn.style, {\r\n                  cursor: \'pointer\',\r\n                  \'text-align\': \'center\',\r\n                  \'text-transform\': \'uppercase\',\r\n                  display: \'block\',\r\n                  color: \'var(--yt-spec-text-secondary)\',\r\n               });\r\n               btn.addEventListener(\'click\', () => {\r\n                  btn.remove();\r\n                  el.style.display = \'unset\';\r\n                  window.dispatchEvent(new Event(\'scroll\'));\r\n               });\r\n               el.before(btn);\r\n            }\r\n         });\r\n   },\r\n   aspectRatio: {\r\n      sizeToFit({\r\n         srcWidth = 0, srcHeight = 0,\r\n         maxWidth = window.innerWidth, maxHeight = window.innerHeight\r\n      }) {\r\n         const aspectRatio = Math.min(+maxWidth / +srcWidth, +maxHeight / +srcHeight);\r\n         return {\r\n            width: +srcWidth * aspectRatio,\r\n            height: +srcHeight * aspectRatio,\r\n         };\r\n      },\r\n      getAspectRatio({ width = required(), height = required() }) {\r\n         const\r\n            gcd = (a, b) => b ? gcd(b, a % b) : a,\r\n            divisor = gcd(width, height);\r\n         return width / divisor + \':\' + height / divisor;\r\n      },\r\n      chooseAspectRatio({ width = required(), height = required(), layout }) {\r\n         const acceptedRatioList = {\r\n            \'landscape\': {\r\n               \'1:1\': 1,\r\n               \'3:2\': 1.5,\r\n               \'4:3\': 1.33333333333,\r\n               \'5:4\': 1.25,\r\n               \'5:3\': 1.66666666667,\r\n               \'16:9\': 1.77777777778,\r\n               \'16:10\': 1.6,\r\n               \'17:9\': 1.88888888889,\r\n               \'21:9\': 2.33333333333,\r\n               \'24:10\': 2.4,\r\n            },\r\n            \'portrait\': {\r\n               \'1:1\': 1,\r\n               \'2:3\': .66666666667,\r\n               \'3:4\': .75,\r\n               \'3:5\': .6,\r\n               \'4:5\': .8,\r\n               \'9:16\': .5625,\r\n               \'9:17\': .5294117647,\r\n               \'9:21\': .4285714286,\r\n               \'10:16\': .625,\r\n            },\r\n         };\r\n         return choiceRatioFromList(this.getAspectRatio(...arguments)) || acceptedRatioList[\'landscape\'][\'16:9\'];\r\n         function choiceRatioFromList(ratio = required()) {\r\n            const layout_ = layout || ((ratio < 1) ? \'portrait\' : \'landscape\');\r\n            return acceptedRatioList[layout_][ratio];\r\n         }\r\n      },\r\n      calculateHeight: (width = required(), aspectRatio = (16 / 9)) => parseFloat((width / aspectRatio).toFixed(2)),\r\n      calculateWidth: (height = required(), aspectRatio = (16 / 9)) => parseFloat((height * aspectRatio).toFixed(2)),\r\n   },\r\n   bezelTrigger(text) {\r\n      if (!text) return;\r\n      if (typeof this.fateBezel === \'number\') clearTimeout(this.fateBezel);\r\n      const bezelEl = document.body.querySelector(\'.ytp-bezel-text\');\r\n      if (!bezelEl) return console.warn(`bezelTrigger ${text}=>${bezelEl}`);\r\n      const\r\n         bezelContainer = bezelEl.parentElement.parentElement,\r\n         BEZEL_SELECTOR_TOGGLE = \'.ytp-text-root\';\r\n      if (!this.bezel_css_inited) {\r\n         this.bezel_css_inited = true;\r\n         this.css.push(\r\n            `${BEZEL_SELECTOR_TOGGLE} { display: block !important; }\r\n            ${BEZEL_SELECTOR_TOGGLE} .ytp-bezel-text-wrapper {\r\n               pointer-events: none;\r\n               z-index: 40 !important;\r\n            }\r\n            ${BEZEL_SELECTOR_TOGGLE} .ytp-bezel-text { display: inline-block !important; }\r\n            ${BEZEL_SELECTOR_TOGGLE} .ytp-bezel { display: none !important; }`);\r\n      }\r\n      bezelEl.textContent = text;\r\n      bezelContainer.classList.add(BEZEL_SELECTOR_TOGGLE);\r\n      this.fateBezel = setTimeout(() => {\r\n         bezelContainer.classList.remove(BEZEL_SELECTOR_TOGGLE);\r\n         bezelEl.textContent = \'\';\r\n      }, 600);\r\n   },\r\n   getChapterList(video_duration = required()) {\r\n      if (NOVA.currentPage != \'embed\'\r\n         && (chapsCollect = getFromDescriptionText() || getFromDescriptionChaptersBlock())\r\n         && chapsCollect.length\r\n      ) {\r\n         return chapsCollect;\r\n      }\r\n      else {\r\n         chapsCollect = getFromAPI();\r\n      }\r\n      return chapsCollect;\r\n      function getFromDescriptionText() {\r\n         const selectorTimestampLink = \'a[href*=\"&t=\"]\';\r\n         let\r\n            timestampsCollect = [],\r\n            nowComment,\r\n            prevSec = -1;\r\n         [\r\n            (\r\n               document.body.querySelector(\'ytd-watch-flexy\')?.playerData?.videoDetails.shortDescription\r\n               || document.body.querySelector(\'ytd-watch-metadata #description.ytd-watch-metadata\')?.textContent\r\n            ),\r\n            //...[...document.body.querySelectorAll(`#comments #comment #comment-content:has(${selectorTimestampLink})`)]\r\n            ...[...document.body.querySelectorAll(`#comments #comment #comment-content ${selectorTimestampLink} + *:last-child`)]\r\n               .map(el => ({\r\n                  \'source\': \'comment\',\r\n                  \'text\': el.closest(\'#comment-content\')?.textContent,\r\n               })),\r\n         ]\r\n            .forEach(data => {\r\n               if (timestampsCollect.length > 1) return;\r\n               nowComment = Boolean(data?.source);\r\n               (data?.text || data)\r\n                  ?.split(\'\\n\')\r\n                  .forEach(line => {\r\n                     line = line?.toString().trim();\r\n                     if (line.length > 5 && line.length < 200 && (timestamp = /((\\d?\\d:){1,2}\\d{2})/g.exec(line))) {\r\n                        timestamp = timestamp[0];\r\n                        const\r\n                           sec = NOVA.timeFormatTo.hmsToSec(timestamp),\r\n                           timestampPos = line.indexOf(timestamp);\r\n                        if (\r\n                           (nowComment ? true : (sec > prevSec && sec < +video_duration))\r\n                           && (timestampPos < 5 || (timestampPos + timestamp.length) === line.length)\r\n                        ) {\r\n                           if (nowComment) prevSec = sec;\r\n                           timestampsCollect.push({\r\n                              \'sec\': sec,\r\n                              \'time\': timestamp,\r\n                              \'title\': line\r\n                                 .replace(timestamp, \'\')\r\n                                 .trim().replace(/^[:\\-–—|]|(\\[\\])?|[:\\-–—.;|]$/g, \'\')\r\n                                 //.trim().replace(/^([:\\-–—|]|(\\d+[\\.)]))|(\\[\\])?|[:\\-–—.;|]$/g, \'\') \r\n                                 .trim()\r\n                           });\r\n                        }\r\n                     }\r\n                  });\r\n            });\r\n         if (timestampsCollect.length == 1 && timestampsCollect[0].sec < (video_duration / 4)) {\r\n            return timestampsCollect;\r\n         }\r\n         else if (timestampsCollect.length > 1) {\r\n            if (nowComment) {\r\n               timestampsCollect = timestampsCollect.sort((a, b) => a.sec - b.sec);\r\n            }\r\n            return timestampsCollect;\r\n         }\r\n      }\r\n      async function getFromDescriptionChaptersBlock() {\r\n         await NOVA.delay(500);\r\n         const selectorTimestampLink = \'a[href*=\"&t=\"]\';\r\n         let timestampsCollect = [];\r\n         document.body.querySelectorAll(`#structured-description ${selectorTimestampLink}`)\r\n            .forEach(chaperLink => {\r\n               if (sec = parseInt(NOVA.queryURL.get(\'t\', chaperLink.href))) {\r\n                  timestampsCollect.push({\r\n                     \'time\': NOVA.timeFormatTo.HMS.digit(sec),\r\n                     \'sec\': sec,\r\n                     \'title\': chaperLink.textContent.trim().split(\'\\n\')[0].trim(),\r\n                  });\r\n               }\r\n            });\r\n         if (timestampsCollect.length == 1 && timestampsCollect[0].sec < (video_duration / 4)) {\r\n            return timestampsCollect;\r\n         }\r\n         else if (timestampsCollect.length > 1) {\r\n            return timestampsCollect;\r\n         }\r\n      }\r\n      function getFromAPI() {\r\n         if (!window.ytPubsubPubsubInstance) {\r\n            return console.warn(\'ytPubsubPubsubInstance is null:\', ytPubsubPubsubInstance);\r\n         }\r\n         if (ytPubsubPubsubInstance = ytPubsubPubsubInstance.i\r\n            || ytPubsubPubsubInstance.j\r\n            || ytPubsubPubsubInstance.subscriptions_\r\n         ) {\r\n            const data = Object.values(\r\n               ytPubsubPubsubInstance.find(a => a?.player)?.player.app\r\n            )\r\n               .find(a => a?.videoData)\r\n               ?.videoData.multiMarkersPlayerBarRenderer;\r\n            if (data?.markersMap?.length) {\r\n               return data.markersMap[0].value.chapters\r\n                  ?.map(c => {\r\n                     const sec = +c.chapterRenderer.timeRangeStartMillis / 1000;\r\n                     return {\r\n                        \'sec\': sec,\r\n                        \'time\': NOVA.timeFormatTo.HMS.digit(sec),\r\n                        \'title\':\r\n                           c.chapterRenderer.title.simpleText\r\n                           || c.chapterRenderer.title.runs[0].text,\r\n                     };\r\n                  });\r\n            }\r\n         }\r\n      }\r\n   },\r\n   searchFilterHTML({ keyword = required(), filter_selectors = required(), highlight_selector }) {\r\n      keyword = keyword.toString().toLowerCase();\r\n      document.body.querySelectorAll(filter_selectors)\r\n         .forEach(item => {\r\n            const\r\n               text = item.textContent,\r\n               hasText = text?.toLowerCase().includes(keyword),\r\n               highlight = el => {\r\n                  if (el.innerHTML.includes(\'<mark \')) {\r\n                     el.innerHTML = el.innerHTML\r\n                        .replace(/<\\/?mark[^>]*>/g, \'\');\r\n                  }\r\n                  item.style.display = hasText ? \'\' : \'none\';\r\n                  if (hasText && keyword) {\r\n                     highlightTerm({\r\n                        \'target\': el,\r\n                        \'keyword\': keyword,\r\n                     });\r\n                  }\r\n               };\r\n            (highlight_selector ? item.querySelectorAll(highlight_selector) : [item])\r\n               .forEach(highlight);\r\n         });\r\n      function highlightTerm({ target = required(), keyword = required(), highlightClass }) {\r\n         const\r\n            content = target.textContent,\r\n            pattern = new RegExp(\'(>[^<.]*)?(\' + keyword + \')([^<.]*)?\', \'gi\'),\r\n            highlightStyle = highlightClass ? `class=\"${highlightClass}\"` : \'style=\"background-color:#afafaf\"\',\r\n            replaceWith = `$1<mark ${highlightStyle}>$2</mark>$3`,\r\n            marked = content.replaceAll(pattern, replaceWith);\r\n         return (target.innerHTML = marked) !== content;\r\n      }\r\n   },\r\n   isMusic() {\r\n      return checkMusicType();\r\n      function checkMusicType() {\r\n         const\r\n            channelName = movie_player.getVideoData().author,\r\n            titleStr = movie_player.getVideoData().title.toUpperCase(),\r\n            titleWordsList = titleStr?.toUpperCase().match(/\\w+/g),\r\n            playerData = document.body.querySelector(\'ytd-watch-flexy\')?.playerData;\r\n         return [\r\n            titleStr,\r\n            location.href,\r\n            channelName,\r\n            playerData?.microformat?.playerMicroformatRenderer.category,\r\n            playerData?.title,\r\n         ]\r\n            .some(i => i?.toUpperCase().includes(\'MUSIC\'))\r\n            || document.body.querySelector(\'#upload-info #channel-name .badge-style-type-verified-artist\')\r\n            || (channelName && /(VEVO|Topic|Records|RECORDS|AMV)$/.test(channelName))\r\n            || (channelName && /(MUSIC|ROCK|SOUNDS|SONGS)/.test(channelName.toUpperCase()))\r\n            || titleWordsList?.length && [\'🎵\', \'♫\', \'AUDIO\', \'SONG\', \'SOUND\', \'SONGS\', \'SOUNDTRACK\', \'LYRIC\', \'LYRICS\', \'AMBIENT\', \'MIX\', \'VEVO\', \'CLIP\', \'KARAOKE\', \'OPENING\', \'COVER\', \'COVERED\', \'VOCAL\', \'INSTRUMENTAL\', \'ORCHESTRAL\', \'DJ\', \'DNB\', \'BASS\', \'BEAT\', \'HITS\', \'ALBUM\', \'PLAYLIST\', \'DUBSTEP\', \'CHILL\', \'RELAX\', \'CLASSIC\', \'CINEMATIC\']\r\n               .some(i => titleWordsList.includes(i))\r\n            || [\'OFFICIAL VIDEO\', \'OFFICIAL AUDIO\', \'FEAT.\', \'FT.\', \'LIVE RADIO\', \'DANCE VER\', \'HIP HOP\', \'ROCK N ROLL\', \'HOUR VER\', \'HOURS VER\', \'INTRO THEME\']\r\n               .some(i => titleStr.includes(i))\r\n            || titleWordsList?.length && [\'OP\', \'ED\', \'MV\', \'OST\', \'NCS\', \'BGM\', \'EDM\', \'GMV\', \'AMV\', \'MMD\', \'MAD\']\r\n               .some(i => titleWordsList.includes(i));\r\n      }\r\n   },\r\n   timeFormatTo: {\r\n      hmsToSec(str) {\r\n         let\r\n            parts = str?.split(\':\'),\r\n            t = 0;\r\n         switch (parts?.length) {\r\n            case 2: t = (parts[0] * 60); break;\r\n            case 3: t = (parts[0] * 60 * 60) + (parts[1] * 60); break;\r\n            case 4: t = (parts[0] * 24 * 60 * 60) + (parts[1] * 60 * 60) + (parts[2] * 60); break;\r\n         }\r\n         return t + +parts.pop();\r\n      },\r\n      HMS: {\r\n         digit(time_sec = required()) {\r\n            const\r\n               ts = Math.abs(+time_sec),\r\n               d = ~~(ts / 86400),\r\n               h = ~~((ts % 86400) / 3600),\r\n               m = ~~((ts % 3600) / 60),\r\n               s = ~~(ts % 60);\r\n            return (d ? `${d}d ` : \'\')\r\n               + (h ? (d ? h.toString().padStart(2, \'0\') : h) + \':\' : \'\')\r\n               + (h ? m.toString().padStart(2, \'0\') : m) + \':\'\r\n               + s.toString().padStart(2, \'0\');\r\n         },\r\n         abbr(time_sec = required()) {\r\n            const\r\n               ts = Math.abs(+time_sec),\r\n               d = ~~(ts / 86400),\r\n               h = ~~((ts % 86400) / 3600),\r\n               m = ~~((ts % 3600) / 60),\r\n               s = ~~(ts % 60);\r\n            return (d ? `${d}d ` : \'\')\r\n               + (h ? (d ? h.toString().padStart(2, \'0\') : h) + \'h\' : \'\')\r\n               + (m ? (h ? m.toString().padStart(2, \'0\') : m) + \'m\' : \'\')\r\n               + (s ? (m ? s.toString().padStart(2, \'0\') : s) + \'s\' : \'\');\r\n         },\r\n      },\r\n      ago(date = required()) {\r\n         if (!(date instanceof Date)) return console.error(\'\"date\" is not Date type:\', date);\r\n         const samples = [\r\n            { label: \'year\', seconds: 31536000 },\r\n            { label: \'month\', seconds: 2592000 },\r\n            { label: \'day\', seconds: 86400 },\r\n            { label: \'hour\', seconds: 3600 },\r\n            { label: \'minute\', seconds: 60 },\r\n            { label: \'second\', seconds: 1 }\r\n         ];\r\n         const\r\n            now = date.getTime(),\r\n            seconds = ~~((Date.now() - Math.abs(now)) / 1000),\r\n            interval = samples.find(i => i.seconds < seconds),\r\n            time = ~~(seconds / interval.seconds);\r\n         return `${(now < 0 ? \'-\' : \'\') + time} ${interval.label}${time !== 1 ? \'s\' : \'\'}`;\r\n      },\r\n   },\r\n   dateformat(format = \'YYYY/MM/DD\') {\r\n      if (!(date instanceof Date)) return console.error(\'dateformat - is not Date type:\', this);\r\n      const\r\n         twoDigit = n => n.toString().padStart(2, \'0\'),\r\n         date = this.getDate(),\r\n         year = this.getFullYear(),\r\n         month = this.getMonth(),\r\n         day = this.getDay(),\r\n         hours = this.getHours(),\r\n         minutes = this.getMinutes(),\r\n         seconds = this.getSeconds();\r\n      return format\r\n         .replace(/A|Z|S(SS)?|ss?|mm?|HH?|hh?|D{1,4}|M{1,4}|YY(YY)?|\'([^\']|\'\')*\'/g, partPattern => {\r\n            let out;\r\n            switch (partPattern) {\r\n               case \'YY\': out = year.substr(2); break;\r\n               case \'YYYY\': out = year; break;\r\n               case \'M\': out = month; break;\r\n               case \'MM\': out = twoDigit(month); break;\r\n               case \'MMM\': out = [\'Jan\', \'Feb\', \'Mar\', \'Apr\', \'May\', \'Jun\', \'Jul\', \'Aug\', \'Sep\', \'Oct\', \'Nov\', \'Dec\'][month]; break;\r\n               case \'MMMM\': out = [\'January\', \'February\', \'March\', \'April\', \'May\', \'June\', \'July\', \'August\', \'September\', \'October\', \'November\', \'December\'][month]; break;\r\n               case \'D\': out = date; break;\r\n               case \'DD\': out = twoDigit(date); break;\r\n               case \'DDD\': out = [\'Sun\', \'Mon\', \'Tue\', \'Wed\', \'Thur\', \'Fri\', \'Sat\'][day]; break;\r\n               case \'DDDD\': out = [\'Sunday\', \'Monday\', \'Tuesday\', \'Wednesday\', \'Thursday\', \'Friday\', \'Saturday\'][day]; break;\r\n               case \'h\': out = (hours % 12) || 12; break;\r\n               case \'H\': out = hours; break;\r\n               case \'HH\': out = twoDigit(hours); break;\r\n               case \'mm\': out = twoDigit(minutes); break;\r\n               case \'s\': out = seconds; break;\r\n               case \'ss\': out = twoDigit(seconds); break;\r\n               case \'SS\': out = twoDigit(seconds); break;\r\n               case \'A\': out = (hours < 12 ? \'AM\' : \'PM\'); break;\r\n               case \'Z\': out = (\'+\' + -this.getTimezoneOffset() / 60)\r\n                  .replace(/^\\D?(\\D)/, \"$1\")\r\n                  .replace(/^(.)(.)$/, \"$10$2\") + \'00\';\r\n                  break;\r\n            }\r\n            return out;\r\n         });\r\n   },\r\n   updateUrl: (new_url = required()) => window.history.replaceState(null, null, new_url),\r\n   queryURL: {\r\n      has: (query = required(), url_string) => new URL(url_string || location).searchParams.has(query.toString()),\r\n      get: (query = required(), url_string) => new URL(url_string || location).searchParams.get(query.toString()),\r\n      set(query_obj = {}, url_string) {\r\n         if (typeof query_obj != \'object\' || !Object.keys(query_obj).length) return console.error(\'query_obj:\', query_obj)\r\n         const url = new URL(url_string || location);\r\n         Object.entries(query_obj).forEach(([key, value]) => url.searchParams.set(key, value));\r\n         return url.toString();\r\n      },\r\n      remove(query = required(), url_string) {\r\n         const url = new URL(url_string || location);\r\n         url.searchParams.delete(query.toString());\r\n         return url.toString();\r\n      },\r\n   },\r\n   request: (() => {\r\n      const API_STORE_NAME = \'YOUTUBE_API_KEYS\';\r\n      async function getKeys() {\r\n         NOVA.log(\'request.API: fetch to youtube_api_keys.json\');\r\n         return await fetch(\'https://gist.githubusercontent.com/raingart/ff6711fafbc46e5646d4d251a79d1118/raw/youtube_api_keys.json\')\r\n            .then(res => res.text())\r\n            .then(keys => {\r\n               NOVA.log(`get and save keys in localStorage`, keys);\r\n               localStorage.setItem(API_STORE_NAME, keys);\r\n               return JSON.parse(keys);\r\n            })\r\n            .catch(error => {\r\n               localStorage.removeItem(API_STORE_NAME);\r\n               throw error;\r\n            })\r\n            .catch(reason => console.error(\'Error get keys:\', reason));\r\n      }\r\n      return {\r\n         async API({ request = required(), params = required(), api_key }) {\r\n            const YOUTUBE_API_KEYS = localStorage.hasOwnProperty(API_STORE_NAME)\r\n               ? JSON.parse(localStorage.getItem(API_STORE_NAME)) : await getKeys();\r\n            if (!api_key && (!Array.isArray(YOUTUBE_API_KEYS) || !YOUTUBE_API_KEYS?.length)) {\r\n               localStorage.hasOwnProperty(API_STORE_NAME) && localStorage.removeItem(API_STORE_NAME);\r\n               return console.error(\'YOUTUBE_API_KEYS empty:\', YOUTUBE_API_KEYS);\r\n            }\r\n            const referRandKey = arr => api_key || \'AIzaSy\' + arr[~~(Math.random() * arr.length)];\r\n            const query = Object.keys(params)\r\n               .map(k => encodeURIComponent(k) + \'=\' + encodeURIComponent(params[k]))\r\n               .join(\'&\');\r\n            const URL = `https://www.googleapis.com/youtube/v3/${request}?${query}&key=` + referRandKey(YOUTUBE_API_KEYS);\r\n            return await fetch(URL)\r\n               .then(response => response.json())\r\n               .then(json => {\r\n                  if (!json?.error && Object.keys(json).length) return json;\r\n                  console.warn(\'used key:\', NOVA.queryURL.get(\'key\', URL));\r\n                  if (json?.error && Object.keys(json.error).length) {\r\n                     throw new Error(JSON.stringify(json?.error));\r\n                  }\r\n               })\r\n               .catch(error => {\r\n                  localStorage.removeItem(API_STORE_NAME);\r\n                  console.error(`Request API failed:${URL}\\n${error}`);\r\n                  if (error?.message && (err = JSON.parse(error?.message))) {\r\n                     return {\r\n                        \'code\': err.code,\r\n                        \'reason\': err.errors?.length && err.errors[0].reason,\r\n                        \'error\': err.message,\r\n                     };\r\n                  }\r\n               });\r\n         },\r\n      };\r\n   })(),\r\n   getPlayerState(state) {\r\n      return {\r\n         \'-1\': \'UNSTARTED\',\r\n         0: \'ENDED\',\r\n         1: \'PLAYING\',\r\n         2: \'PAUSED\',\r\n         3: \'BUFFERING\',\r\n         5: \'CUED\'\r\n      }[state || movie_player.getPlayerState()];\r\n   },\r\n   videoElement: (() => {\r\n      const videoSelector = \'#movie_player:not(.ad-showing) video\';\r\n      document.addEventListener(\'canplay\', ({ target }) => {\r\n         target.matches(videoSelector) && (NOVA.videoElement = target);\r\n      }, { capture: true, once: true });\r\n      document.addEventListener(\'play\', ({ target }) => {\r\n         target.matches(videoSelector) && (NOVA.videoElement = target);\r\n      }, true);\r\n   })(),\r\n   isFullscreen: () => (\r\n      movie_player.classList.contains(\'ytp-fullscreen\')\r\n      || (movie_player.hasOwnProperty(\'isFullscreen\') && movie_player.isFullscreen())\r\n   ),\r\n   getChannelId(api_key) {\r\n      const isChannelId = id => id && /UC([a-z0-9-_]{22})$/i.test(id);\r\n      let result = [\r\n         document.querySelector(\'meta[itemprop=\"channelId\"][content]\')?.content,\r\n         (document.body.querySelector(\'ytd-app\')?.__data?.data?.response\r\n            || document.body.querySelector(\'ytd-app\')?.data?.response\r\n            || window.ytInitialData\r\n         )\r\n            ?.metadata?.channelMetadataRenderer?.externalId,\r\n         document.querySelector(\'link[itemprop=\"url\"][href]\')?.href.split(\'/\')[4],\r\n         location.pathname.split(\'/\')[2],\r\n         document.body.querySelector(\'#video-owner a[href]\')?.href.split(\'/\')[4],\r\n         document.body.querySelector(\'a.ytp-ce-channel-title[href]\')?.href.split(\'/\')[4],\r\n         document.body.querySelector(\'ytd-watch-flexy\')?.playerData?.videoDetails.channelId,\r\n         ((typeof ytcfg === \'object\') && (obj = ytcfg.data_?.PLAYER_VARS?.embedded_player_response)\r\n            && NOVA.seachInObjectBy.key({\r\n               \'obj\': JSON.parse(obj),\r\n               \'keys\': \'channelId\',\r\n            })?.data),\r\n      ]\r\n         .find(i => isChannelId(i));\r\n      return result;\r\n   },\r\n   storage_obj_manager: {\r\n      STORAGE_NAME: \'nova-channels-state\',\r\n      async initStorage() {\r\n         this.channelId = location.search.includes(\'list=\')\r\n            ? (NOVA.queryURL.get(\'list\') || movie_player?.getPlaylistId())\r\n            : await NOVA.waitUntil(NOVA.getChannelId, 1000);\r\n      },\r\n      read(return_all) {\r\n         if (store = JSON.parse(localStorage.getItem(this.STORAGE_NAME))) {\r\n            return return_all ? store : store[this.channelId];\r\n         }\r\n      },\r\n      write(obj_save) {\r\n         if ((storage = this.read(\'all\') || {})) {\r\n            if (Object.keys(obj_save).length) {\r\n               storage = Object.assign(storage, { [this.channelId]: obj_save });\r\n            }\r\n            else {\r\n               delete storage[this.channelId];\r\n            }\r\n         }\r\n         localStorage.setItem(this.STORAGE_NAME, JSON.stringify(storage));\r\n      },\r\n      _getParam(key = required()) {\r\n         if (storage = this.read()) {\r\n            return storage[key];\r\n         }\r\n      },\r\n      async getParam(key = required()) {\r\n         if (!this.channelId) await this.initStorage();\r\n         return this._getParam(...arguments);\r\n      },\r\n      save(obj_save) {\r\n         if (storage = this.read()) {\r\n            obj_save = Object.assign(storage, obj_save);\r\n         }\r\n         this.write(obj_save);\r\n      },\r\n      remove(key) {\r\n         if ((storage = this.read())) {\r\n            delete storage[key];\r\n            this.write(storage);\r\n         }\r\n      },\r\n   },\r\n   seachInObjectBy: {\r\n      key({ obj = required(),\r\n         keys = required(),\r\n         match_fn = data => data.constructor.name !== \'Object\',\r\n         multiple = false,\r\n         path = \'\'\r\n      }) {\r\n         const setPath = d => (path ? path + \'.\' : \'\') + d;\r\n         let hasKey, results = [];\r\n         for (const prop in obj) {\r\n            if (obj.hasOwnProperty(prop) && obj[prop]) {\r\n               hasKey = keys.constructor.name === \'String\' ? (keys === prop) : keys.indexOf(prop) > -1;\r\n               if (hasKey && (!match_fn || match_fn(obj[prop]))) {\r\n                  if (multiple) {\r\n                     results.push({\r\n                        \'path\': setPath(prop),\r\n                        \'data\': obj[prop],\r\n                     });\r\n                  }\r\n                  else {\r\n                     return {\r\n                        \'path\': setPath(prop),\r\n                        \'data\': obj[prop],\r\n                     };\r\n                  }\r\n               }\r\n               else {\r\n                  switch (obj[prop].constructor.name) {\r\n                     case \'Object\':\r\n                        if (result = this.key({\r\n                           \'obj\': obj[prop],\r\n                           \'keys\': keys,\r\n                           \'path\': setPath(prop),\r\n                           \'match_fn\': match_fn,\r\n                        })) {\r\n                           if (multiple) results.push(result);\r\n                           else return result;\r\n                        }\r\n                        break;\r\n                     case \'Array\':\r\n                        for (let i = 0; i < obj[prop].length; i++) {\r\n                           if (result = this.key({\r\n                              \'obj\': obj[prop][i],\r\n                              \'keys\': keys,\r\n                              \'path\': path + `[${i}]`,\r\n                              \'match_fn\': match_fn,\r\n                           })) {\r\n                              if (multiple) results.push(result);\r\n                              else return result;\r\n                           }\r\n                        }\r\n                        break;\r\n                     case \'Function\':\r\n                        if (Object.keys(obj[prop]).length) {\r\n                           for (const j in obj[prop]) {\r\n                              if (typeof obj[prop] !== \'undefined\') {\r\n                                 if (result = this.key({\r\n                                    \'obj\': obj[prop][j],\r\n                                    \'keys\': keys,\r\n                                    \'path\': setPath(prop) + \'.\' + j,\r\n                                    \'match_fn\': match_fn,\r\n                                 })) {\r\n                                    if (multiple) results.push(result);\r\n                                    else return result;\r\n                                 }\r\n                              }\r\n                           }\r\n                        }\r\n                        break;\r\n                  }\r\n               }\r\n            }\r\n         }\r\n         if (multiple) return results;\r\n      },\r\n   },\r\n   log() {\r\n      if (this.DEBUG && arguments.length) {\r\n         console.groupCollapsed(...arguments);\r\n         console.trace();\r\n         console.groupEnd();\r\n      }\r\n   }\r\n}\r\nwindow.nova_plugins.push({\r\n   id: \'scroll-to-top\',\r\n   title: \'Add \"Scroll to top\" button\',\r\n   \'title:zh\': \'滚动到顶部按钮\',\r\n   \'title:ja\': \'トップボタンまでスクロール\',\r\n   \'title:ko\': \'맨 위로 스크롤 버튼\',\r\n   \'title:id\': \'Gulir ke tombol atas\',\r\n   \'title:es\': \'Desplazarse al botón superior\',\r\n   \'title:pt\': \'Role para o botão superior\',\r\n   \'title:fr\': \'Faites défiler vers le haut\',\r\n   \'title:it\': \'Scorri fino al pulsante in alto\',\r\n   \'title:de\': \'Nach oben scrollen\',\r\n   \'title:pl\': \'Przycisk przewijania do góry\',\r\n   \'title:ua\': \'Прокрутити до гори\',\r\n   run_on_pages: \'*, -embed, -mobile, -live_chat\',\r\n   section: \'other\',\r\n   desc: \'Displayed on long pages\',\r\n   \'desc:zh\': \'出现在长页面上\',\r\n   \'desc:ja\': \'長いページに表示されます\',\r\n   \'desc:ko\': \'긴 페이지에 표시됨\',\r\n   \'desc:id\': \'Ditampilkan di halaman panjang\',\r\n   \'desc:es\': \'Mostrado en páginas largas\',\r\n   \'desc:pt\': \'Exibido em páginas longas\',\r\n   \'desc:fr\': \'Affiché sur de longues pages\',\r\n   \'desc:it\': \'Visualizzato su pagine lunghe\',\r\n   \'desc:de\': \'Wird auf langen Seiten angezeigt\',\r\n   \'desc:pl\': \'Wyświetlaj na długich stronach\',\r\n   \'desc:ua\': \'Відображається на довгих сторінках\',\r\n   _runtime: user_settings => {\r\n      document.addEventListener(\'scroll\', insertButton, { capture: true, once: true });\r\n      function insertButton() {\r\n         const SELECTOR_ID = \'nova-scrollTop-btn\';\r\n         const btn = document.createElement(\'button\');\r\n         btn.id = SELECTOR_ID;\r\n         Object.assign(btn.style, {\r\n            position: \'fixed\',\r\n            cursor: \'pointer\',\r\n            bottom: 0,\r\n            left: \'20%\',\r\n            visibility: \'hidden\',\r\n            opacity: .5,\r\n            width: \'40%\',\r\n            height: \'40px\',\r\n            border: \'none\',\r\n            outline: \'none\',\r\n            \'z-index\': 1,\r\n            \'border-radius\': \'100% 100% 0 0\',\r\n            \'font-size\': \'16px\',\r\n            \'background-color\': \'rgba(0,0,0,.3)\',\r\n            \'box-shadow\': \'0 16px 24px 2px rgba(0, 0, 0, .14), 0 6px 30px 5px rgba(0, 0, 0, .12), 0 8px 10px -5px rgba(0, 0, 0, .4)\',\r\n         });\r\n         btn.addEventListener(\'click\', () => {\r\n            window.scrollTo({\r\n               top: 0,\r\n               behavior: user_settings.scroll_to_top_smooth ? \'smooth\' : \'instant\',\r\n            });\r\n            if (user_settings.scroll_to_top_autoplay && NOVA.currentPage == \'watch\'\r\n               && [\'UNSTARTED\', \'PAUSED\'].includes(NOVA.getPlayerState())\r\n            ) {\r\n               movie_player.playVideo();\r\n            }\r\n         });\r\n         const arrow = document.createElement(\'span\');\r\n         Object.assign(arrow.style, {\r\n            border: \'solid white\',\r\n            \'border-width\': \'0 3px 3px 0\',\r\n            display: \'inline-block\',\r\n            padding: \'4px\',\r\n            \'vertical-align\': \'middle\',\r\n            transform: \'rotate(-135deg)\',\r\n         });\r\n         btn.append(arrow);\r\n         document.body.append(btn);\r\n         NOVA.css.push(\r\n            `#${SELECTOR_ID}:hover {\r\n               opacity: 1 !important;\r\n               background-color: rgba(0,0,0,.6) !important;\r\n            }`);\r\n         const scrollTop_btn = document.getElementById(SELECTOR_ID);\r\n         let sOld;\r\n         window.addEventListener(\'scroll\', () => {\r\n            const sCurr = document.documentElement.scrollTop > (window.innerHeight / 2);\r\n            if (sCurr == sOld) return;\r\n            sOld = sCurr;\r\n            scrollTop_btn.style.visibility = sCurr ? \'visible\' : \'hidden\';\r\n         });\r\n      }\r\n   },\r\n   options: {\r\n      scroll_to_top_smooth: {\r\n         _tagName: \'input\',\r\n         label: \'Smooth\',\r\n         \'label:zh\': \'光滑的\',\r\n         \'label:ja\': \'スムーズ\',\r\n         \'label:ko\': \'매끄러운\',\r\n         \'label:id\': \'Mulus\',\r\n         \'label:es\': \'Suave\',\r\n         \'label:pt\': \'Suave\',\r\n         \'label:fr\': \'Lisse\',\r\n         \'label:it\': \'Scorrimento fluido\',\r\n         \'label:de\': \'Glatt\',\r\n         \'label:pl\': \'Płynnie\',\r\n         \'label:ua\': \'Плавно\',\r\n         type: \'checkbox\',\r\n      },\r\n      scroll_to_top_autoplay: {\r\n         _tagName: \'input\',\r\n         label: \'Unpause video\',\r\n         \'label:zh\': \'视频取消暂停\',\r\n         \'label:ja\': \'ビデオの一時停止解除\',\r\n         \'label:ko\': \'비디오 일시 중지 해제\',\r\n         \'label:id\': \'Video batalkan Jeda\',\r\n         \'label:es\': \'Reanudar video\',\r\n         \'label:pt\': \'Retomar vídeo\',\r\n         \'label:fr\': \'Annuler la pause de la vidéo\',\r\n         \'label:it\': \'Annulla pausa video\',\r\n         \'label:de\': \'Video wieder anhalten\',\r\n         \'label:pl\': \'Wyłącz wstrzymanie odtwarzania filmu\',\r\n         \'label:ua\': \'Продовжити програвання відео\',\r\n         type: \'checkbox\',\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'thumbs-title-filter\',\r\n   title: \'Block thumbnails by title\',\r\n   \'title:zh\': \'按标题阻止缩略图\',\r\n   \'title:ja\': \'タイトルでサムネイルをブロックする\',\r\n   \'title:ko\': \'제목으로 축소판 차단\',\r\n   \'title:id\': \'Blokir gambar mini berdasarkan judul\',\r\n   \'title:es\': \'Bloquear miniaturas por título\',\r\n   \'title:pt\': \'Bloquear miniaturas por título\',\r\n   \'title:fr\': \'Bloquer les vignettes par titre\',\r\n   \'title:it\': \'Blocca le miniature per titolo\',\r\n   \'title:de\': \'Thumbnails nach Titel blockieren\',\r\n   \'title:pl\': \'Blokuj miniatury według tytułu\',\r\n   \'title:ua\': \'Блокуйте мініатюри за назвою\',\r\n   run_on_pages: \'*, -embed, -mobile, -live_chat\',\r\n   section: \'other\',\r\n   _runtime: user_settings => {\r\n      const keywords = user_settings.thumb_filter_title_blocklist\r\n         ?.split(/[\\n,;]/)\r\n         .map(e => e.toString().trim().toLowerCase())\r\n         .filter(e => e.length);\r\n      const thumbsSelectors = [\r\n         \'ytd-rich-item-renderer\',\r\n         \'ytd-video-renderer\',\r\n         \'ytd-compact-video-renderer\',\r\n         \'ytm-compact-video-renderer\',\r\n         \'ytm-item-section-renderer\'\r\n      ]\r\n         .join(\',\');\r\n      if (NOVA.isMobile) {\r\n         NOVA.watchElements({\r\n            selectors: [\'#video-title:not(:empty)\'],\r\n            attr_mark: \'nova-thumb-title-filtered\',\r\n            callback: video_title => {\r\n               keywords.forEach(keyword => {\r\n                  if (video_title.textContent.trim().toLowerCase().includes(keyword)\r\n                     && (thumb = channel_name.closest(thumbsSelectors))\r\n                  ) {\r\n                  }\r\n               });\r\n            }\r\n         });\r\n      } else {\r\n         document.addEventListener(\'yt-action\', evt => {\r\n            if ([\r\n               \'yt-append-continuation-items-action\',\r\n               \'ytd-update-grid-state-action\',\r\n               \'yt-service-request\',\r\n               \'ytd-rich-item-index-update-action\',\r\n            ]\r\n               .includes(evt.detail?.actionName)\r\n            ) {\r\n               hideThumb();\r\n            }\r\n         });\r\n         function hideThumb() {\r\n            document.body.querySelectorAll(\'#video-title\')\r\n               .forEach(el => {\r\n                  keywords.forEach(keyword => {\r\n                     if (el.innerText.toLowerCase().includes(keyword)\r\n                        && (thumb = el.closest(thumbsSelectors))\r\n                     ) {\r\n                        thumb.remove();\r\n                     }\r\n                  });\r\n               });\r\n         }\r\n      }\r\n   },\r\n   options: {\r\n      thumb_filter_title_blocklist: {\r\n         _tagName: \'textarea\',\r\n         label: \'Words list\',\r\n         \'label:zh\': \'单词列表\',\r\n         \'label:ja\': \'単語リスト\',\r\n         \'label:ko\': \'단어 목록\',\r\n         \'label:id\': \'Daftar kata\',\r\n         \'label:es\': \'lista de palabras\',\r\n         \'label:pt\': \'Lista de palavras\',\r\n         \'label:fr\': \'Liste de mots\',\r\n         \'label:it\': \'Elenco di parole\',\r\n         \'label:de\': \'Wortliste\',\r\n         \'label:pl\': \'Lista słów\',\r\n         \'label:ua\': \'Список слів\',\r\n         title: \'separator: \",\" or \";\" or \"new line\"\',\r\n         \'title:zh\': \'分隔器： \",\" 或 \";\" 或 \"新队\"\',\r\n         \'title:ja\': \'セパレータ： \",\" または \";\" または \"改行\"\',\r\n         \'title:ko\': \'구분 기호: \",\" 또는 \";\" 또는 \"새 줄\"\',\r\n         \'title:id\': \'pemisah: \",\" atau \";\" atau \"baris baru\"\',\r\n         \'title:es\': \'separador: \",\" o \";\" o \"new line\"\',\r\n         \'title:pt\': \'separador: \",\" ou \";\" ou \"new line\"\',\r\n         \'title:fr\': \'séparateur : \",\" ou \";\" ou \"nouvelle ligne\"\',\r\n         \'title:it\': \'separatore: \",\" o \";\" o \"nuova linea\"\',\r\n         \'title:de\': \'separator: \",\" oder \";\" oder \"new line\"\',\r\n         \'title:pl\': \'separator: \",\" lub \";\" lub \"now linia\"\',\r\n         \'title:ua\': \'розділювач: \",\" або \";\" або \"новий рядок\"\',\r\n         placeholder: \'text1, text2\',\r\n         required: true,\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'scrollbar-hide\',\r\n   title: \'Hide scrollbar in watch page\',\r\n   \'title:ua\': \'Приховати смугу прокрутки на сторінці перегляду\',\r\n   run_on_pages: \'*, -embed, -mobile\',\r\n   section: \'other\',\r\n   _runtime: user_settings => {\r\n      const HIDE_SCROLL_ATTR = \'nova-scrollbar-hide\';\r\n      NOVA.css.push(\r\n         `html[${HIDE_SCROLL_ATTR}] body::-webkit-scrollbar {\r\n            display: none;\r\n         }`);\r\n      NOVA.runOnPageInitOrTransition(() => {\r\n         let hasAttr = document.documentElement.hasAttribute(HIDE_SCROLL_ATTR);\r\n         if ((NOVA.currentPage == \'watch\') && !hasAttr) {\r\n            document.documentElement.toggleAttribute(HIDE_SCROLL_ATTR);\r\n         }\r\n         else if ((NOVA.currentPage != \'watch\') && hasAttr) {\r\n            document.documentElement.removeAttribute(HIDE_SCROLL_ATTR);\r\n         }\r\n      });\r\n      if (user_settings.scrollbar_hide_livechat && NOVA.currentPage == \'live_chat\') {\r\n         return NOVA.css.push(\r\n            `*,\r\n            #item-scroller {\r\n               -ms-overflow-style: none; \r\n               scrollbar-width: none; \r\n            }\r\n            *::-webkit-scrollbar,\r\n            #item-scroller::-webkit-scrollbar {\r\n               display: none; \r\n            }`);\r\n      }\r\n   },\r\n   options: {\r\n      scrollbar_hide_livechat: {\r\n         _tagName: \'input\',\r\n         label: \'In live-chat frame\',\r\n         \'label:ua\': \'У живому чаті\',\r\n         type: \'checkbox\',\r\n         \'data-dependent\': { \'livechat_visibility_mode\': [\'!disable\'] },\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'disable-video-cards\',\r\n   title: \'Hide html garbage\',\r\n   \'title:ua\': \'Приховайте сміття: анотації, кінцеві заставки тощо\',\r\n   run_on_pages: \'results, watch, embed, -mobile\',\r\n   section: \'other\',\r\n   desc: \'Remove the annoying stuff\',\r\n   \'desc:ua\': \'Приховайте набридливий контент\',\r\n   _runtime: user_settings => {\r\n      let selectorsList = [\r\n         \'.ytp-paid-content-overlay\',\r\n         \'.iv-branding\',\r\n         \'#movie_player:not(:hover) > [class^=\"ytp-ce-\"]\',\r\n         \'.ytp-cards-teaser-text\',\r\n         \'ytm-paid-content-overlay-renderer\',\r\n      ];\r\n      switch (NOVA.currentPage) {\r\n         case \'embed\':\r\n            selectorsList.push([\r\n               \'.ytp-pause-overlay\',\r\n               \'.ytp-info-panel-preview\',\r\n            ]);\r\n            break;\r\n         default:\r\n            selectorsList.push([\r\n               \'ytd-search-pyv-renderer\',\r\n               \'[class^=\"ytd-promoted-\"]\',\r\n               \'ytd-video-renderer + ytd-shelf-renderer\',\r\n               \'ytd-video-renderer + ytd-reel-shelf-renderer\',\r\n               \'#clarify-box\',\r\n               \'.ytd-watch-flexy.attached-message\',\r\n               \'ytd-popup-container tp-yt-paper-dialog ytd-single-option-survey-renderer\',\r\n               \'#donation-shelf ytd-donation-unavailable-renderer\',\r\n               \'.sparkles-light-cta\',\r\n               \'ytd-feed-nudge-renderer\',\r\n            ]);\r\n            NOVA.css.push(\r\n               [\r\n                  \'ytd-rich-item-renderer:has(ytd-ad-slot-renderer)\',\r\n                  \'ytd-live-chat-frame#chat[collapsed]:has(iframe#chatframe[src=\"about:blank\"])\',\r\n               ]\r\n                  .join(\',\\n\') + `{ display: none !important;}`);\r\n      }\r\n      if (selectorsList.length) {\r\n         NOVA.css.push(\r\n            selectorsList.join(\',\\n\') + ` {\r\n               display: none !important;\r\n            }`);\r\n      }\r\n   },\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'thumbnails-clear\',\r\n   title: \'Clear thumbnails\',\r\n   \'title:zh\': \'清除缩略图\',\r\n   \'title:ja\': \'サムネイルをクリアする\',\r\n   \'title:ko\': \'썸네일 지우기\',\r\n   \'title:id\': \'Hapus gambar mini\',\r\n   \'title:es\': \'Miniaturas claras\',\r\n   \'title:pt\': \'Limpar miniaturas\',\r\n   \'title:fr\': \'Effacer les vignettes\',\r\n   \'title:it\': \'Cancella miniature\',\r\n   \'title:de\': \'Miniaturansichten löschen\',\r\n   \'title:pl\': \'Wyczyść miniatury\',\r\n   \'title:ua\': \'Очистити мініатюри\',\r\n   run_on_pages: \'home, feed, channel, watch\',\r\n   section: \'other\',\r\n   desc: \'Replaces the predefined clickbait thumbnails\',\r\n   \'desc:zh\': \'替换预定义的缩略图\',\r\n   \'desc:ja\': \'事前定義されたサムネイルを置き換えます\',\r\n   \'desc:ko\': \'미리 정의된 축소판을 대체합니다\',\r\n   \'desc:id\': \'Menggantikan gambar mini yang telah ditentukan sebelumnya\',\r\n   \'desc:es\': \'Reemplaza la miniatura predefinida\',\r\n   \'desc:pt\': \'Substitui a miniatura predefinida\',\r\n   \'desc:it\': \'Sostituisce la miniatura predefinita\',\r\n   \'desc:de\': \'Ersetzt das vordefinierte Thumbnail\',\r\n   \'desc:pl\': \'Zastępuje predefiniowaną miniaturkę\',\r\n   \'desc:ua\': \'Замінює попередньо визначені мініатюри клікбейти\',\r\n   _runtime: user_settings => {\r\n      const\r\n         ATTR_MARK = \'nova-thumb-preview-cleared\',\r\n         thumbsSelectors = [\r\n            \'ytd-rich-item-renderer\',\r\n            \'ytd-video-renderer\',\r\n            \'ytm-compact-video-renderer\',\r\n            \'ytm-item-section-renderer\'\r\n         ];\r\n      let DISABLE_YT_IMG_DELAY_LOADING_default = false;\r\n      NOVA.watchElements({\r\n         selectors: [\r\n            \'#thumbnail:not(.ytd-playlist-thumbnail):not([class*=markers]):not([href*=\"/shorts/\"]) img[src]:not([src*=\"_live.jpg\"])\',\r\n            \'a:not([href*=\"/shorts/\"]) img.video-thumbnail-img[src]:not([src*=\"_live.jpg\"])\'\r\n         ],\r\n         attr_mark: ATTR_MARK,\r\n         callback: async img => {\r\n            if (NOVA.currentPage == \'results\') return;\r\n            if (window.yt?.config_?.DISABLE_YT_IMG_DELAY_LOADING\r\n               && DISABLE_YT_IMG_DELAY_LOADING_default !== window.yt?.config_?.DISABLE_YT_IMG_DELAY_LOADING\r\n            ) {\r\n               DISABLE_YT_IMG_DELAY_LOADING_default = window.yt?.config_?.DISABLE_YT_IMG_DELAY_LOADING;\r\n               await NOVA.delay(100);\r\n               document.body.querySelectorAll(`[${ATTR_MARK}]`).forEach(e => e.removeAttribute(ATTR_MARK));\r\n            }\r\n            if ((thumb = img.closest(thumbsSelectors))\r\n               && thumb.querySelector(\r\n                  `#badges [class*=\"live-now\"],\r\n                  #overlays [aria-label=\"PREMIERE\"],\r\n                  ytd-thumbnail-overlay-time-status-renderer [overlay-style=\"UPCOMING\"]`)\r\n            ) {\r\n               return;\r\n            }\r\n            if (src = patchImg(img.src)) img.src = patchImg(src);\r\n         },\r\n      });\r\n      if (user_settings.thumbnails_clear_overlay) {\r\n         NOVA.css.push(\r\n            `#hover-overlays {\r\n               visibility: hidden !important;\r\n            }`);\r\n      }\r\n      function patchImg(str) {\r\n         if ((re = /(\\w{2}default|hq\\d+)./i) && re.test(str)) {\r\n            return str.replace(re, (user_settings.thumbnails_clear_preview_timestamp || \'hq2\') + \'.\');\r\n         }\r\n      }\r\n   },\r\n   options: {\r\n      thumbnails_clear_preview_timestamp: {\r\n         _tagName: \'select\',\r\n         label: \'Thumbnail timestamps\',\r\n         \'label:zh\': \'缩略图时间戳\',\r\n         \'label:ja\': \'サムネイルのタイムスタンプ\',\r\n         \'label:ko\': \'썸네일 타임스탬프\',\r\n         \'label:id\': \'Stempel waktu gambar mini\',\r\n         \'label:es\': \'Marcas de tiempo en miniatura\',\r\n         \'label:pt\': \'Carimbos de data e hora em miniatura\',\r\n         \'label:fr\': \'Horodatages des vignettes\',\r\n         \'label:it\': \'Timestamp in miniatura\',\r\n         \'label:de\': \'Thumbnail-Zeitstempel\',\r\n         \'label:pl\': \'Znaczniki czasowe miniatur\',\r\n         \'label:ua\': \'Мітки часу мініатюр\',\r\n         title: \'Show thumbnail from video time position\',\r\n         \'title:zh\': \'从视频时间位置显示缩略图\',\r\n         \'title:ja\': \'ビデオの時間位置からサムネイルを表示\',\r\n         \'title:ko\': \'비디오 시간 위치에서 썸네일 표시\',\r\n         \'title:id\': \'Tampilkan thumbnail dari posisi waktu video\',\r\n         \'title:es\': \'Mostrar miniatura de la posición de tiempo del video\',\r\n         \'title:pt\': \'Mostrar miniatura da posição no tempo do vídeo\',\r\n         \'title:fr\': \'Afficher la vignette à partir de la position temporelle de la vidéo\',\r\n         \'title:it\': \"Mostra la miniatura dalla posizione dell\'ora del video\",\r\n         \'title:de\': \'Miniaturansicht von der Videozeitposition anzeigen\',\r\n         \'title:pl\': \'Pokaż miniaturkę z pozycji czasu wideo\',\r\n         \'title:ua\': \'Показати мініатюру з часової позиції відео\',\r\n         options: [\r\n            {\r\n               label: \'start\', value: \'hq1\',\r\n               \'label:zh\': \'开始\',\r\n               \'label:ja\': \'始まり\',\r\n               \'label:ko\': \'시작\',\r\n               \'label:id\': \'awal\',\r\n               \'label:es\': \'comienzo\',\r\n               \'label:pt\': \'começar\',\r\n               \'label:fr\': \'le début\',\r\n               \'label:it\': \'inizio\',\r\n               \'label:de\': \'anfang\',\r\n               \'label:pl\': \'początek\',\r\n               \'label:ua\': \'початок\',\r\n            },\r\n            {\r\n               label: \'middle\', value: \'hq2\', selected: true,\r\n               \'label:zh\': \'中间\',\r\n               \'label:ja\': \'真ん中\',\r\n               \'label:ko\': \'~ 아니다\',\r\n               \'label:id\': \'tengah\',\r\n               \'label:es\': \'medio\',\r\n               \'label:pt\': \'meio\',\r\n               \'label:fr\': \'ne pas\',\r\n               \'label:it\': \'mezzo\',\r\n               \'label:de\': \'mitte\',\r\n               \'label:pl\': \'środek\',\r\n               \'label:ua\': \'середина\',\r\n            },\r\n            {\r\n               label: \'end\', value: \'hq3\',\r\n               \'label:zh\': \'结尾\',\r\n               \'label:ja\': \'終わり\',\r\n               \'label:ko\': \'끝\',\r\n               \'label:id\': \'akhir\',\r\n               \'label:es\': \'fin\',\r\n               \'label:pt\': \'fim\',\r\n               \'label:fr\': \'finir\',\r\n               \'label:it\': \'fine\',\r\n               \'label:de\': \'ende\',\r\n               \'label:pl\': \'koniec\',\r\n               \'label:ua\': \'кінець\',\r\n            }\r\n         ],\r\n      },\r\n      thumbnails_clear_overlay: {\r\n         _tagName: \'input\',\r\n         label: \'Hide overlay buttons on a thumbnail\',\r\n         \'label:zh\': \'隐藏覆盖在缩略图上的按钮\',\r\n         \'label:ja\': \'サムネイルにオーバーレイされたボタンを非表示にする\',\r\n         \'label:ko\': \'축소판에서 오버레이 버튼 숨기기\',\r\n         \'label:id\': \'Sembunyikan tombol overlay pada thumbnail\',\r\n         \'label:es\': \'Ocultar botones superpuestos en una miniatura\',\r\n         \'label:pt\': \'Ocultar botões de sobreposição em uma miniatura\',\r\n         \'label:fr\': \'Masquer les boutons de superposition sur une vignette\',\r\n         \'label:it\': \'Nascondi pulsanti sovrapposti su una miniatura\',\r\n         \'label:de\': \'Überlagerungsschaltflächen auf einer Miniaturansicht ausblenden\',\r\n         \'label:pl\': \'Ukryj przyciski nakładki na miniaturce\',\r\n         \'label:ua\': \'Приховати кнопки на мініатюрі\',\r\n         type: \'checkbox\',\r\n         title: \'Hide [ADD TO QUEUE] [WATCH LATER]\',\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'search-filter\',\r\n   title: \'Blocked channels\',\r\n   \'title:zh\': \'屏蔽频道列表\',\r\n   \'title:ja\': \'ブロックされたチャネルのリスト\',\r\n   \'title:ko\': \'차단된 채널 목록\',\r\n   \'title:id\': \'Saluran yang diblokir\',\r\n   \'title:es\': \'Lista de canales bloqueados\',\r\n   \'title:pt\': \'Lista de canais bloqueados\',\r\n   \'title:fr\': \'Liste des chaînes bloquées\',\r\n   \'title:it\': \'Canali bloccati\',\r\n   \'title:de\': \'Liste der gesperrten Kanäle\',\r\n   \'title:pl\': \'Zablokowane kanały\',\r\n   \'title:ua\': \'Заблоковані канали\',\r\n   run_on_pages: \'results, feed, -mobile\',\r\n   section: \'other\',\r\n   desc: \'Hide channels on the search page\',\r\n   \'desc:zh\': \'在搜索页面上隐藏频道\',\r\n   \'desc:ja\': \'検索ページでチャンネルを非表示にする\',\r\n   \'desc:ko\': \'검색 페이지에서 채널 숨기기\',\r\n   \'desc:id\': \'Sembunyikan saluran di halaman pencarian\',\r\n   \'desc:es\': \'Ocultar canales en la página de búsqueda\',\r\n   \'desc:pt\': \'Ocultar canais na página de pesquisa\',\r\n   \'desc:fr\': \'Masquer les chaînes sur la page de recherche\',\r\n   \'desc:it\': \'Nascondi i canali nella pagina di ricerca\',\r\n   \'desc:de\': \'Kanäle auf der Suchseite ausblenden\',\r\n   \'desc:pl\': \'Ukryj kanały na stronie wyszukiwania\',\r\n   \'desc:ua\': \'Приховує канали на сторінці пошуку\',\r\n   _runtime: user_settings => {\r\n      const keywords = user_settings.search_filter_channel_blocklist\r\n         ?.split(/[\\n,;]/)\r\n         .map(e => e.toString().trim().toLowerCase())\r\n         .filter(e => e.length);\r\n      const thumbsSelectors = [\r\n         \'ytd-rich-item-renderer\',\r\n         \'ytd-video-renderer\',\r\n         \'ytm-compact-video-renderer\',\r\n      ]\r\n         .join(\',\');\r\n      if (NOVA.isMobile) {\r\n         NOVA.watchElements({\r\n            selectors: [\'#channel-name\'],\r\n            attr_mark: \'nova-thumb-channel-filtered\',\r\n            callback: channel_name => {\r\n               keywords.forEach(keyword => {\r\n                  if (channel_name.textContent.trim().toLowerCase().includes(keyword)\r\n                     && (thumb = channel_name.closest(thumbsSelectors))\r\n                  ) {\r\n                     thumb.remove();\r\n                  }\r\n               });\r\n            }\r\n         });\r\n      }\r\n      else {\r\n         document.addEventListener(\'yt-action\', evt => {\r\n            if ([\r\n               \'yt-append-continuation-items-action\',\r\n               \'ytd-update-grid-state-action\',\r\n               \'yt-service-request\',\r\n            ]\r\n               .includes(evt.detail?.actionName)\r\n            ) {\r\n               document.body.querySelectorAll(\r\n                  \'#channel-name a[href]\'\r\n               )\r\n                  .forEach(channel_name => {\r\n                     keywords.forEach(keyword => {\r\n                        if (keyword.startsWith(\'@\')\r\n                           && channel_name.href.includes(keyword)\r\n                           && (thumb = channel_name.closest(thumbsSelectors))\r\n                        ) {\r\n                           thumb.remove();\r\n                        }\r\n                        else if (channel_name.textContent.trim().toLowerCase().includes(keyword)\r\n                           && (thumb = channel_name.closest(thumbsSelectors))\r\n                        ) {\r\n                           thumb.remove();\r\n                        }\r\n                     });\r\n                  });\r\n            }\r\n         });\r\n      }\r\n   },\r\n   options: {\r\n      search_filter_channel_blocklist: {\r\n         _tagName: \'textarea\',\r\n         label: \'List\',\r\n         \'label:zh\': \'频道列表\',\r\n         \'label:ja\': \'チャンネルリスト\',\r\n         \'label:ko\': \'채널 목록\',\r\n         \'label:id\': \'Daftar\',\r\n         \'label:es\': \'Lista\',\r\n         \'label:pt\': \'Lista\',\r\n         \'label:fr\': \'Liste\',\r\n         \'label:it\': \'Elenco\',\r\n         \'label:de\': \'Liste\',\r\n         \'label:pl\': \'Lista\',\r\n         \'label:ua\': \'Список\',\r\n         title: \'separator: \",\" or \";\" or \"new line\"\',\r\n         \'title:zh\': \'分隔器： \",\" 或 \";\" 或 \"新队\"\',\r\n         \'title:ja\': \'セパレータ： \",\" または \";\" または \"改行\"\',\r\n         \'title:ko\': \'구분 기호: \",\" 또는 \";\" 또는 \"새 줄\"\',\r\n         \'title:id\': \'pemisah: \",\" atau \";\" atau \"baris baru\"\',\r\n         \'title:es\': \'separador: \",\" o \";\" o \"new line\"\',\r\n         \'title:pt\': \'separador: \",\" ou \";\" ou \"new line\"\',\r\n         \'title:fr\': \'séparateur : \",\" ou \";\" ou \"nouvelle ligne\"\',\r\n         \'title:it\': \'separatore: \",\" o \";\" o \"nuova linea\"\',\r\n         \'title:de\': \'separator: \",\" oder \";\" oder \"new line\"\',\r\n         \'title:pl\': \'separator: \",\" lub \";\" lub \"now linia\"\',\r\n         \'title:ua\': \'розділювач: \",\" або \";\" або \"новий рядок\"\',\r\n         placeholder: \'channel1, channel2\',\r\n         required: true,\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'thumbnails-grid-count\',\r\n   title: \'Thumbnails count in line\',\r\n   run_on_pages: \'feed, channel, -mobile\',\r\n   section: \'other\',\r\n   _runtime: user_settings => {\r\n      const\r\n         origMathMin = Math.min,\r\n         addRowCount = +user_settings.thumbnails_grid_count || 1;\r\n      Math.min = function () {\r\n         return origMathMin.apply(Math, arguments)\r\n            + (/calcElementsPerRow/img.test(Error().stack || \'\') ? addRowCount : 0);\r\n      };\r\n      NOVA.css.push(\r\n         `ytd-rich-grid-video-renderer[mini-mode] #video-title.ytd-rich-grid-video-renderer {\r\n            font-size: 1.4rem;\r\n            font-weight: 500;\r\n            line-height: 1.6rem;\r\n         }\r\n         #avatar-link.ytd-rich-grid-video-renderer {\r\n            display: none !important;\r\n         }\r\n         ytd-video-renderer[use-prominent-thumbs] ytd-thumbnail.ytd-video-renderer {\r\n            min-width: 120px !important;\r\n            max-width: 240px !important;\r\n         }`);\r\n   },\r\n   options: {\r\n      thumbnails_grid_count: {\r\n         _tagName: \'input\',\r\n         label: \'Add to row\',\r\n         type: \'number\',\r\n         placeholder: \'1-10\',\r\n         step: 1,\r\n         min: 1,\r\n         max: 10,\r\n         value: 1,\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'thumbs-shorts-duration\',\r\n   title: \'Add time for shorts thumbnail\',\r\n   \'label:zh\': \'对于短裤添加缩略图叠加时间\',\r\n   \'label:ja\': \'短い場合は、サムネイルのオーバーレイ時間を追加します\',\r\n   \'label:ko\': \'Shorts의 경우 미리보기 이미지 오버레이 시간 추가\',\r\n   \'label:id\': \'Untuk celana pendek tambahkan waktu overlay thumbnail\',\r\n   \'label:es\': \'Para cortos, agregue tiempo de superposición de miniaturas\',\r\n   \'label:pt\': \'Para shorts, adicione o tempo de sobreposição da miniatura\',\r\n   \'label:fr\': \'Pour les courts métrages, ajoutez le temps de superposition des vignettes\',\r\n   \'label:it\': \'Per i cortometraggi aggiungi il tempo di sovrapposizione delle miniature\',\r\n   \'label:de\': \'Fügen Sie für Kurzfilme eine Überlagerungszeit für Miniaturansichten hinzu\',\r\n   \'label:pl\': \'W przypadku filmów krótkometrażowych dodaj czas nakładki miniatury\',\r\n   \'label:ua\': \'Для шортів додайте час накладання мініатюр\',\r\n   run_on_pages: \'feed, -mobile\',\r\n   section: \'other\',\r\n   _runtime: user_settings => {\r\n      if (user_settings[\'shorts_disable\']) return;\r\n      document.addEventListener(\'yt-action\', evt => {\r\n         if (![\'feed\', \'channel\'].includes(NOVA.currentPage)) return;\r\n         if ([\r\n            \'yt-append-continuation-items-action\',\r\n            \'ytd-update-grid-state-action\',\r\n         ]\r\n            .includes(evt.detail?.actionName)\r\n         ) {\r\n            addTimeToOverlay();\r\n         }\r\n      });\r\n      const\r\n         ATTR_MARK = \'nova-thumb-shorts-time\',\r\n         thumbsSelectors = [\r\n            \'ytd-rich-item-renderer\',\r\n         ]\r\n            .join(\',\');\r\n      function addTimeToOverlay() {\r\n         document.body.querySelectorAll(`a[href*=\"/shorts/\"]:not([${ATTR_MARK}])`)\r\n            .forEach(link => {\r\n               link.setAttribute(ATTR_MARK, true);\r\n               if (thumb = link.closest(thumbsSelectors)) {\r\n                  NOVA.waitSelector(\'ytd-thumbnail-overlay-time-status-renderer\', { container: link, stop_on_page_change: true })\r\n                     .then(overlay => {\r\n                        if ((thumb = link.closest(thumbsSelectors)?.data)\r\n                           && (time = getThumbTime(thumb))\r\n                        ) {\r\n                           overlay.setAttribute(\'overlay-style\', \'DEFAULT\');\r\n                           if (timeLabelEl = overlay.$[\'text\']) {\r\n                              timeLabelEl.textContent = time;\r\n                           }\r\n                        }\r\n                     });\r\n               }\r\n            });\r\n      }\r\n      function getThumbTime(videoData = required()) {\r\n         if ((location.pathname + location.search) == \'/playlist?list=WL\') return;\r\n         if ((title = videoData.title?.accessibility.accessibilityData?.label)\r\n            && (publishedTimeText = videoData.publishedTimeText?.simpleText)\r\n            && (viewCountText = videoData.viewCountText?.simpleText)\r\n         ) {\r\n            const\r\n               from = title.search(publishedTimeText) + publishedTimeText.length,\r\n               to = title.search(viewCountText),\r\n               time = parseInt(title.substring(from, to).replace(/\\D/g, \'\'));\r\n            return NOVA.timeFormatTo.HMS.digit(time === 1 ? 60 : time)\r\n         }\r\n         else {\r\n            console.error(\'getThumbTime empty:\',\r\n               \'\\ntitle:\', title,\r\n               \'\\npublishedTimeText:\', publishedTimeText,\r\n               \'\\nviewCountText:\', viewCountText);\r\n         }\r\n      }\r\n   },\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'thumbnails-watched\',\r\n   title: \'Mark watched thumbnails\',\r\n   \'title:zh\': \'标记您观看的缩略图\',\r\n   \'title:ja\': \'視聴したサムネイルにマークを付ける\',\r\n   \'title:ko\': \'본 썸네일 표시\',\r\n   \'title:id\': \'Tandai gambar mini yang ditonton\',\r\n   \'title:es\': \'Mark vio miniaturas\',\r\n   \'title:pt\': \'Mark assistiu às miniaturas\',\r\n   \'title:fr\': \'Marquer les vignettes visionnées\',\r\n   \'title:it\': \'Contrassegna le miniature visualizzate\',\r\n   \'title:de\': \'Angesehene Miniaturansichten markieren\',\r\n   \'title:pl\': \'Oznacz obejrzane miniaturki\',\r\n   \'title:ua\': \'Позначити переглянуті мініатюри\',\r\n   run_on_pages: \'home, results, feed, channel, watch, -mobile\',\r\n   section: \'other\',\r\n   _runtime: user_settings => {\r\n      NOVA.css.push(\r\n         `a#thumbnail,\r\n         a[class*=\"thumbnail\"] {\r\n            outline: 1px solid var(--yt-spec-general-background-a);\r\n         }\r\n         \r\n         a#thumbnail:visited,\r\n         a[class*=\"thumbnail\"]:visited {\r\n            outline: 1px solid ${user_settings.thumbnails_watched_frame_color || \'red\'} !important;\r\n         }\r\n         \r\n         ytd-playlist-panel-video-renderer a:visited #meta * {\r\n            color: ${user_settings.thumbnails_watched_title_color || \'#ff4500\'} !important;\r\n         }`);\r\n      if (user_settings.thumbnails_watched_title) {\r\n         NOVA.css.push(\r\n            `a#video-title:visited:not(:hover),\r\n            #description a:visited {\r\n               color: ${user_settings.thumbnails_watched_title_color} !important;\r\n            }`);\r\n      }\r\n   },\r\n   options: {\r\n      thumbnails_watched_frame_color: {\r\n         _tagName: \'input\',\r\n         label: \'Frame color\',\r\n         \'label:zh\': \'框架颜色\',\r\n         \'label:ja\': \'フレームカラー\',\r\n         \'label:ko\': \'프레임 색상\',\r\n         \'label:id\': \'Warna bingkai\',\r\n         \'label:es\': \'Color del marco\',\r\n         \'label:pt\': \'Cor da moldura\',\r\n         \'label:fr\': \'Couleur du cadre\',\r\n         \'label:it\': \'Colore del telaio\',\r\n         \'label:de\': \'Rahmenfarbe\',\r\n         \'label:pl\': \'Kolor ramki\',\r\n         \'label:ua\': \'Колір рамки\',\r\n         type: \'color\',\r\n         value: \'#FF0000\',\r\n      },\r\n      thumbnails_watched_title: {\r\n         _tagName: \'input\',\r\n         label: \'Set title color\',\r\n         \'label:zh\': \'您要更改标题颜色吗？\',\r\n         \'label:ja\': \'タイトルの色を変更しますか？\',\r\n         \'label:ko\': \'제목 색상 설정\',\r\n         \'label:id\': \'Setel warna judul\',\r\n         \'label:es\': \'Establecer el color del título\',\r\n         \'label:pt\': \'Definir a cor do título\',\r\n         \'label:fr\': \'Définir la couleur du titre\',\r\n         \'label:it\': \'Imposta il colore del titolo\',\r\n         \'label:de\': \'Titelfarbe festlegen\',\r\n         \'label:pl\': \'Ustaw kolor tytułu\',\r\n         \'label:ua\': \'Встановити колір заголовку\',\r\n         type: \'checkbox\',\r\n      },\r\n      thumbnails_watched_title_color: {\r\n         _tagName: \'input\',\r\n         label: \'Choose title color\',\r\n         \'label:zh\': \'选择标题颜色\',\r\n         \'label:ja\': \'タイトルの色を選択\',\r\n         \'label:ko\': \'제목 색상 선택\',\r\n         \'label:id\': \'Pilih warna judul\',\r\n         \'label:es\': \'Elija el color del título\',\r\n         \'label:pt\': \'Escolha a cor do título\',\r\n         \'label:fr\': \'Choisissez la couleur du titre\',\r\n         \'label:it\': \'Scegli il colore del titolo\',\r\n         \'label:de\': \'Titelfarbe auswählen\',\r\n         \'label:pl\': \'Wybierz kolor tytułu\',\r\n         \'label:ua\': \'Обрати колір заголовку\',\r\n         type: \'color\',\r\n         value: \'#ff4500\',\r\n         \'data-dependent\': { \'thumbnails_watched_title\': true },\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'miniplayer-disable\',\r\n   title: \'Disable miniplayer\',\r\n   \'title:ua\': \'Вимкнути мінівідтворювач\',\r\n   run_on_pages: \'watch, -mobile\',\r\n   section: \'other\',\r\n   desc: \'shown on changeable page when playing playlist\',\r\n   \'desc:ua\': \'Відображається на іншій сторінці під час відтворення плейлиста\',\r\n   _runtime: user_settings => {\r\n      NOVA.css.push(\r\n         `.ytp-right-controls .ytp-miniplayer-button {\r\n            display: none !important;\r\n         }`);\r\n      document.addEventListener(\'yt-action\', evt => {\r\n         if (NOVA.currentPage != \'watch\' && evt.detail?.actionName.includes(\'miniplayer\')) {\r\n            document.body.querySelector(\'ytd-miniplayer[active] #movie_player .ytp-miniplayer-scrim button.ytp-miniplayer-close-button\')\r\n               ?.click();\r\n         }\r\n      });\r\n   },\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'channel-trailer-stop-preload\',\r\n   title: \'Stop play channel trailer\',\r\n   \'title:zh\': \'停止频道预告片\',\r\n   \'title:ja\': \'チャンネルの予告編を停止する\',\r\n   \'title:ko\': \'채널 예고편 중지\',\r\n   \'title:id\': \'Hentikan cuplikan saluran\',\r\n   \'title:es\': \'Detener el tráiler del canal\',\r\n   \'title:pt\': \'Parar o trailer do canal\',\r\n   \'title:fr\': \'Arrêter la bande-annonce de la chaîne\',\r\n   \'title:it\': \'Interrompi il trailer del canale\',\r\n   \'title:de\': \'Kanaltrailer stoppen\',\r\n   \'title:pl\': \'Zatrzymaj zwiastun kanału\',\r\n   \'title:ua\': \'Не відтворювати трейлер каналу\',\r\n   run_on_pages: \'channel, -mobile\',\r\n   restart_on_location_change: true,\r\n   section: \'channel\',\r\n   _runtime: user_settings => {\r\n      NOVA.waitSelector(\'#c4-player[playing-mode]\', { stop_on_page_change: true })\r\n         .then(player => player.stopVideo());\r\n   },\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'thumbnails-title-normalize\',\r\n   title: \'Decapitalize thumbnails title\',\r\n   \'title:zh\': \'从大写中删除缩略图标题\',\r\n   \'title:ja\': \'サムネイルのタイトルを大文字から外す\',\r\n   \'title:ko\': \'썸네일 제목을 대문자로\',\r\n   \'title:id\': \'Judul gambar mini decapitalize\',\r\n   \'title:es\': \'Descapitalizar el título de las miniaturas\',\r\n   \'title:pt\': \'Decapitalize o título das miniaturas\',\r\n   \'title:fr\': \'Démajuscule le titre des vignettes\',\r\n   \'title:it\': \'Decapitalizza il titolo delle miniature\',\r\n   \'title:de\': \'Thumbnails-Titel entfernen\',\r\n   \'title:pl\': \'Zmniejsz czcionkę w tytule miniatur\',\r\n   \'title:ua\': \'Завжди маленькі літери для назв мініатюр\',\r\n   run_on_pages: \'home, feed, channel, watch\',\r\n   section: \'other\',\r\n   desc: \'Upper Case thumbnails title back to normal\',\r\n   \'desc:ua\': \'Зняти слова з великої літери для назв мініатюр\',\r\n   _runtime: user_settings => {\r\n      const\r\n         VIDEO_TITLE_SELECTOR = [\r\n            \'#video-title\',\r\n            \'a > [class*=\"media-item-headline\"]\',\r\n         ]\r\n            .map(i => i + \':not(:empty)\'),\r\n         MAX_CAPS_LETTERS = +user_settings.thumbnails_title_normalize_smart_max_words || 2,\r\n         ATTR_MARK = \'nova-thumb-title-normalized\',\r\n         clearOfSymbols = str => str.replace(/[\\u2011-\\u26FF]/g, \' \').replace(/\\s{2,}/g, \' \'),\r\n         clearOfEmoji = str => str.replace(/[^\\p{L}\\p{N}\\p{P}\\p{Z}{\\^\\$}]/gu, \' \').replace(/\\s{2,}/g, \' \');\r\n      if (user_settings.thumbnails_title_normalize_show_full) {\r\n         NOVA.css.push(\r\n            VIDEO_TITLE_SELECTOR.join(\',\') + `{\r\n               display: block !important;\r\n               max-height: unset !important;\r\n            }`);\r\n      }\r\n      const UpperCaseLetterRegex = new RegExp(\"([\\-0-9A-ZÀ-ÖØ-ÞĀĂĄĆĈĊČĎĐĒĔĖĘĚĜĞĠĢĤĦĨĪĬĮİĲĴĶĹĻĽĿŁŃŅŇŊŌŎŐŒŔŖŘŚŜŞŠŢŤŦŨŪŬŮŰŲŴŶŸ-ŹŻŽƁ-ƂƄƆ-ƇƉ-ƋƎ-ƑƓ-ƔƖ-ƘƜ-ƝƟ-ƠƢƤƦ-ƧƩƬƮ-ƯƱ-ƳƵƷ-ƸƼǄǇǊǍǏǑǓǕǗǙǛǞǠǢǤǦǨǪǬǮǱǴǶ-ǸǺǼǾȀȂȄȆȈȊȌȎȐȒȔȖȘȚȜȞȠȢȤȦȨȪȬȮȰȲȺ-ȻȽ-ȾɁɃ-ɆɈɊɌɎͰͲͶΆΈ-ΊΌΎ-ΏΑ-ΡΣ-ΫϏϒ-ϔϘϚϜϞϠϢϤϦϨϪϬϮϴϷϹ-ϺϽ-ЯѠѢѤѦѨѪѬѮѰѲѴѶѸѺѼѾҀҊҌҎҐҒҔҖҘҚҜҞҠҢҤҦҨҪҬҮҰҲҴҶҸҺҼҾӀ-ӁӃӅӇӉӋӍӐӒӔӖӘӚӜӞӠӢӤӦӨӪӬӮӰӲӴӶӸӺӼӾԀԂԄԆԈԊԌԎԐԒԔԖԘԚԜԞԠԢԱ-Ֆ֊־٠-٩۰-۹߀-߉०-९০-৯੦-੯૦-૯୦-୯௦-௯౦-౯೦-೯൦-൯๐-๙໐-໙༠-༩၀-၉႐-႙Ⴀ-Ⴥ០-៩᠆᠐-᠙᥆-᥏᧐-᧙᭐-᭙᮰-᮹᱀-᱉᱐-᱙ḀḂḄḆḈḊḌḎḐḒḔḖḘḚḜḞḠḢḤḦḨḪḬḮḰḲḴḶḸḺḼḾṀṂṄṆṈṊṌṎṐṒṔṖṘṚṜṞṠṢṤṦṨṪṬṮṰṲṴṶṸṺṼṾẀẂẄẆẈẊẌẎẐẒẔẞẠẢẤẦẨẪẬẮẰẲẴẶẸẺẼẾỀỂỄỆỈỊỌỎỐỒỔỖỘỚỜỞỠỢỤỦỨỪỬỮỰỲỴỶỸỺỼỾἈ-ἏἘ-ἝἨ-ἯἸ-ἿὈ-ὍὙὛὝὟὨ-ὯᾸ-ΆῈ-ΉῘ-ΊῨ-ῬῸ-Ώ‐-―ℂℇℋ-ℍℐ-ℒℕℙ-ℝℤΩℨK-ℭℰ-ℳℾ-ℿⅅↃⰀ-ⰮⱠⱢ-ⱤⱧⱩⱫⱭ-ⱯⱲⱵⲀⲂⲄⲆⲈⲊⲌⲎⲐⲒⲔⲖⲘⲚⲜⲞⲠⲢⲤⲦⲨⲪⲬⲮⲰⲲⲴⲶⲸⲺⲼⲾⳀⳂⳄⳆⳈⳊⳌⳎⳐⳒⳔⳖⳘⳚⳜⳞⳠⳢ⸗⸚〜〰゠꘠-꘩ꙀꙂꙄꙆꙈꙊꙌꙎꙐꙒꙔꙖꙘꙚꙜꙞꙢꙤꙦꙨꙪꙬꚀꚂꚄꚆꚈꚊꚌꚎꚐꚒꚔꚖꜢꜤꜦꜨꜪꜬꜮꜲꜴꜶꜸꜺꜼꜾꝀꝂꝄꝆꝈꝊꝌꝎꝐꝒꝔꝖꝘꝚꝜꝞꝠꝢꝤꝦꝨꝪꝬꝮꝹꝻꝽ-ꝾꞀꞂꞄꞆꞋ꣐-꣙꤀-꤉꩐-꩙︱-︲﹘﹣－０-９Ａ-Ｚ]|\\ud801[\\udc00-\\udc27\\udca0-\\udca9]|\\ud835[\\udc00-\\udc19\\udc34-\\udc4d\\udc68-\\udc81\\udc9c\\udc9e-\\udc9f\\udca2\\udca5-\\udca6\\udca9-\\udcac\\udcae-\\udcb5\\udcd0-\\udce9\\udd04-\\udd05\\udd07-\\udd0a\\udd0d-\\udd14\\udd16-\\udd1c\\udd38-\\udd39\\udd3b-\\udd3e\\udd40-\\udd44\\udd46\\udd4a-\\udd50\\udd6c-\\udd85\\udda0-\\uddb9\\uddd4-\\udded\\ude08-\\ude21\\ude3c-\\ude55\\ude70-\\ude89\\udea8-\\udec0\\udee2-\\udefa\\udf1c-\\udf34\\udf56-\\udf6e\\udf90-\\udfa8\\udfca\\udfce-\\udfff]){2,}\", \'g\');\r\n      NOVA.css.push({\r\n         \'text-transform\': \'uppercase\',\r\n      }, VIDEO_TITLE_SELECTOR.map(e => `${e}[${ATTR_MARK}]::first-letter`), \'important\');\r\n      NOVA.watchElements({\r\n         selectors: VIDEO_TITLE_SELECTOR,\r\n         attr_mark: ATTR_MARK,\r\n         callback: async videoTitleEl => {\r\n            if (NOVA.currentPage == \'results\') return;\r\n            let countCaps = 0;\r\n            if (user_settings.thumbnails_title_clear_emoji) {\r\n               videoTitleEl.textContent = clearOfEmoji(videoTitleEl.innerText).trim();\r\n            }\r\n            if (user_settings.thumbnails_title_clear_symbols) {\r\n               videoTitleEl.textContent = clearOfSymbols(videoTitleEl.innerText).trim();\r\n            }\r\n            const normalizedText = videoTitleEl.innerText.replace(UpperCaseLetterRegex, match => {\r\n               ++countCaps;\r\n               return (\r\n                  /\\d/.test(match)\r\n                  || (match.length === 1 && /[A-Z]/.test(match))\r\n                  //|| (match.length < 5 && match.includes(\'.\') && /([A-Z]\\.){2,}/.test(match)) \r\n                  || (match.length < 5 && match.length > 1 && [\'HD\', \'UHD\', \'USB\', \'TV\', \'CPU\', \'GPU\', \'APU\', \'AMD\', \'XT\', \'RX\', \'GTX\', \'RTX\', \'GT\', \'FX\', \'SE\', \'HP\', \'SSD\', \'RAM\', \'PC\', \'FPS\', \'RDNA\', \'FSR\', \'DLSS\', \'MSI\', \'VR\', \'GOTY\', \'AAA\', \'UI\', \'BBC\', \'WWE\', \'OS\', \'OP\', \'ED\', \'MV\', \'PV\', \'OST\', \'NCS\', \'BGM\', \'EDM\', \'GMV\', \'AMV\', \'MMD\', \'MAD\', \'SQL\', \'CAPS\'].includes(match))\r\n                  || (match.length < 5 && /(M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3}))/i.test(match))\r\n               ) ? match : match.toLowerCase();\r\n            });\r\n            if (countCaps > MAX_CAPS_LETTERS\r\n               || (countCaps > 1 && normalizedText.split(/\\s+/).length === countCaps)\r\n            ) {\r\n               videoTitleEl.innerText = normalizedText;\r\n            }\r\n         }\r\n      });\r\n      document.addEventListener(\'yt-action\', evt => {\r\n         if (evt.detail?.actionName == \'yt-chip-cloud-chip-select-action\') {\r\n            window.addEventListener(\'transitionend\', restoreTitle, { capture: true, once: true });\r\n         }\r\n      });\r\n      function restoreTitle() {\r\n         const selectorOldTitle = \'#video-title-link[title]\';\r\n         if (NOVA.channelTab == \'videos\') {\r\n            document.body.querySelectorAll(`${selectorOldTitle} ${VIDEO_TITLE_SELECTOR}[${ATTR_MARK}]`)\r\n               .forEach(el => {\r\n                  if (oldTitle = el.closest(selectorOldTitle)?.title) {\r\n                     el.innerText = oldTitle;\r\n                     el.removeAttribute(ATTR_MARK);\r\n                  }\r\n               });\r\n         }\r\n      }\r\n   },\r\n   options: {\r\n      thumbnails_title_normalize_show_full: {\r\n         _tagName: \'input\',\r\n         label: \'Show full title\',\r\n         \'label:zh\': \'显示完整标题\',\r\n         \'label:ja\': \'完全なタイトルを表示\',\r\n         \'label:ko\': \'전체 제목 표시\',\r\n         \'label:id\': \'Tampilkan judul lengkap\',\r\n         \'label:es\': \'Mostrar título completo\',\r\n         \'label:pt\': \'Mostrar título completo\',\r\n         \'label:fr\': \'Afficher le titre complet\',\r\n         \'label:it\': \'Mostra il titolo completo\',\r\n         \'label:de\': \'Vollständigen Titel anzeigen\',\r\n         \'label:pl\': \'Pokaż pełny tytuł\',\r\n         \'label:ua\': \'Показати повну назву\',\r\n         type: \'checkbox\'\r\n      },\r\n      thumbnails_title_normalize_smart_max_words: {\r\n         _tagName: \'input\',\r\n         label: \'Max words in uppercase\',\r\n         \'label:zh\': \'大写字数上限\',\r\n         \'label:ja\': \'大文字の最大単語数\',\r\n         \'label:ko\': \'대문자의 최대 단어 수\',\r\n         \'label:id\': \'Maks kata dalam huruf besar\',\r\n         \'label:es\': \'Máximo de palabras en mayúsculas\',\r\n         \'label:pt\': \'Máximo de palavras em maiúsculas\',\r\n         \'label:fr\': \'Mots maximum en majuscules\',\r\n         \'label:it\': \'Max parole in maiuscolo\',\r\n         \'label:de\': \'Maximale Wörter in Großbuchstaben\',\r\n         \'label:pl\': \'Maksymalna liczba słów pisanych wielkimi literami\',\r\n         \'label:ua\': \'Максимальна кількість слів ВЕЛИКИМИ літерами\',\r\n         type: \'number\',\r\n         placeholder: \'1-10\',\r\n         min: 1,\r\n         max: 10,\r\n         value: 2,\r\n      },\r\n      thumbnails_title_clear_emoji: {\r\n         _tagName: \'input\',\r\n         label: \'Remove emoji\',\r\n         \'label:zh\': \'从表情符号中清除标题\',\r\n         \'label:ja\': \'クリア絵文字\',\r\n         \'label:ko\': \'이모티콘 지우기\',\r\n         \'label:id\': \'Hapus emoji\',\r\n         \'label:es\': \'Borrar emoji\',\r\n         \'label:pt\': \'Limpar emoji\',\r\n         \'label:fr\': \'Emoji clair\',\r\n         \'label:it\': \'Emoji trasparenti\',\r\n         \'label:de\': \'Emoji löschen\',\r\n         \'label:pl\': \'Usuń emoji\',\r\n         \'label:ua\': \'Очистити емодзі\',\r\n         type: \'checkbox\',\r\n      },\r\n      thumbnails_title_clear_symbols: {\r\n         _tagName: \'input\',\r\n         label: \'Remove symbols\',\r\n         type: \'checkbox\',\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'collapse-navigation-panel\',\r\n   title: \'Hide navigation panel\',\r\n   run_on_pages: \'*, -watch, -embed, -live_chat\',\r\n   section: \'other\',\r\n   _runtime: user_settings => {\r\n      NOVA.waitSelector(\'#guide[opened]\')\r\n         .then(el => {\r\n            document.getElementById(\'guide-button\').click();\r\n            el.removeAttribute(\'opened\');\r\n         });\r\n   },\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'shorts-redirect\',\r\n   title: \'Redirect Shorts to regular (watch) URLs\',\r\n   \'title:zh\': \'将 Shorts 重定向到常规（watch）URL\',\r\n   \'title:ja\': \'ショートパンツを通常の（watch）URLにリダイレクトする\',\r\n   \'title:ko\': \'Shorts를 일반(watch) URL로 리디렉션\',\r\n   \'title:id\': \'Redirect Shorts ke URL reguler (watch)\',\r\n   \'title:es\': \'Redirigir Shorts a URL normales (watch)\',\r\n   \'title:pt\': \'Redirecionar Shorts para URLs regulares (watch)\',\r\n   \'title:fr\': \'Rediriger les shorts vers des URL normales (watch)\',\r\n   \'title:it\': \'Reindirizza i cortometraggi a URL normali (watch).\',\r\n   \'title:de\': \'Leiten Sie Shorts zu regulären (watch) URLs um\',\r\n   \'title:pl\': \'Przełączaj Shorts na zwykłe adresy URL\',\r\n   \'title:ua\': \'Перенаправляйте прев`ю на звичайні URL-адреси (для перегляду)\',\r\n   run_on_pages: \'shorts\',\r\n   restart_on_location_change: true,\r\n   section: \'other\',\r\n   desc: \'Redirect Shorts video to normal player\',\r\n   \'desc:zh\': \'将 Shorts 视频重定向到普通播放器\',\r\n   \'desc:ja\': \'ショートパンツのビデオを通常のプレーヤーにリダイレクトする\',\r\n   \'desc:ko\': \'Shorts 비디오를 일반 플레이어로 리디렉션\',\r\n   \'desc:id\': \'Redirect video Shorts ke pemutar normal\',\r\n   \'desc:es\': \'Redirigir el video de Shorts al reproductor normal\',\r\n   \'desc:pt\': \'Redirecionar o vídeo do Shorts para o player normal\',\r\n   \'desc:fr\': \'Rediriger la vidéo Short vers un lecteur normal\',\r\n   \'desc:it\': \'Reindirizza il video dei cortometraggi al lettore normale\',\r\n   \'desc:de\': \'Shorts-Video auf normalen Player umleiten\',\r\n   \'desc:pl\': \'Przełącza krótkie filmy do normalnego odtwarzacza\',\r\n   \'desc:ua\': \'Перенаправляйте прев`ю відео у звичайний відтворювач\',\r\n   _runtime: user_settings => {\r\n      location.href = location.href.replace(\'shorts/\', \'watch?v=\');\r\n   },\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'thumbs-hide\',\r\n   title: \'Thumbnails filtering\',\r\n   \'title:zh\': \'缩略图过滤\',\r\n   \'title:ja\': \'サムネイルのフィルタリング\',\r\n   \'title:ko\': \'썸네일 필터링\',\r\n   \'title:id\': \'Pemfilteran gambar mini\',\r\n   \'title:es\': \'Filtrado de miniaturas\',\r\n   \'title:pt\': \'Filtragem de miniaturas\',\r\n   \'title:fr\': \'Filtrage des vignettes\',\r\n   \'title:it\': \'Filtraggio miniature\',\r\n   \'title:de\': \'Filtrowanie miniatur\',\r\n   \'title:pl\': \'Ukryj kilka miniatur\',\r\n   \'title:ua\': \'Фільтрування мініатюр\',\r\n   run_on_pages: \'home, results, feed, channel, watch, -mobile\',\r\n   section: \'other\',\r\n   _runtime: user_settings => {\r\n      const\r\n         thumbsSelectors = [\r\n            \'ytd-rich-item-renderer\',\r\n            \'ytd-video-renderer\',\r\n            \'ytd-compact-video-renderer\',\r\n            \'ytm-compact-video-renderer\',\r\n            \'ytm-item-section-renderer\'\r\n         ]\r\n            .join(\',\');\r\n      document.addEventListener(\'yt-action\', evt => {\r\n         if ([\r\n            \'yt-append-continuation-items-action\',\r\n            \'ytd-update-grid-state-action\',\r\n            \'yt-service-request\',\r\n            \'ytd-rich-item-index-update-action\',\r\n         ]\r\n            .includes(evt.detail?.actionName)\r\n         ) {\r\n            switch (NOVA.currentPage) {\r\n               case \'home\':\r\n                  thumbRemove.live();\r\n                  thumbRemove.mix();\r\n                  thumbRemove.watched();\r\n                  break;\r\n               case \'results\':\r\n                  thumbRemove.live();\r\n                  thumbRemove.shorts();\r\n                  thumbRemove.mix();\r\n                  break;\r\n               case \'feed\':\r\n                  thumbRemove.live();\r\n                  thumbRemove.streamed();\r\n                  thumbRemove.shorts();\r\n                  thumbRemove.durationLimits();\r\n                  thumbRemove.premieres();\r\n                  thumbRemove.mix();\r\n                  thumbRemove.watched();\r\n                  break;\r\n               case \'channel\':\r\n                  thumbRemove.live();\r\n                  thumbRemove.streamed();\r\n                  thumbRemove.premieres();\r\n                  thumbRemove.watched();\r\n                  break;\r\n               case \'watch\':\r\n                  thumbRemove.live();\r\n                  thumbRemove.mix();\r\n                  thumbRemove.watched();\r\n                  break;\r\n            }\r\n         }\r\n      });\r\n      const thumbRemove = {\r\n         shorts() {\r\n            if (!user_settings.shorts_disable) return;\r\n            if (NOVA.currentPage == \'channel\' && NOVA.channelTab == \'shorts\') return;\r\n            document.body.querySelectorAll(\'a#thumbnail[href*=\"shorts/\"]\')\r\n               .forEach(el => el.closest(thumbsSelectors)?.remove());\r\n         },\r\n         durationLimits() {\r\n            if (!+user_settings.shorts_disable_min_duration) return;\r\n            const OVERLAYS_TIME_SELECTOR = \'#thumbnail #overlays #text:not(:empty)\';\r\n            NOVA.waitSelector(OVERLAYS_TIME_SELECTOR)\r\n               .then(() => {\r\n                  document.body.querySelectorAll(OVERLAYS_TIME_SELECTOR)\r\n                     .forEach(el => {\r\n                        if ((thumb = el.closest(thumbsSelectors))\r\n                           && (time = NOVA.timeFormatTo.hmsToSec(el.textContent.trim()))\r\n                           && time < (+user_settings.shorts_disable_min_duration || 60)\r\n                        ) {\r\n                           thumb.remove();\r\n                        }\r\n                     });\r\n               });\r\n         },\r\n         premieres() {\r\n            if (!user_settings.premieres_disable) return;\r\n            document.body.querySelectorAll(\r\n               `#thumbnail #overlays [aria-label=\"Premiere\"],\r\n               #thumbnail #overlays [aria-label=\"Upcoming\"]`\r\n            )\r\n               .forEach(el => el.closest(thumbsSelectors)?.remove());\r\n            document.body.querySelectorAll(\'#video-badges > [class*=\"live-now\"]\')\r\n               .forEach(el => el.closest(thumbsSelectors)?.remove());\r\n         },\r\n         live() {\r\n            if (!user_settings.live_disable) return;\r\n            if (NOVA.currentPage == \'channel\' && NOVA.channelTab == \'streams\') return;\r\n            document.body.querySelectorAll(\'#thumbnail img[src*=\"_live.jpg\"]\')\r\n               .forEach(el => el.closest(thumbsSelectors)?.remove());\r\n         },\r\n         streamed() {\r\n            if (!user_settings.streamed_disable) return;\r\n            if (NOVA.currentPage == \'channel\' && NOVA.channelTab == \'streams\') return;\r\n            document.body.querySelectorAll(\'#metadata-line > span:last-of-type\')\r\n               .forEach(el => {\r\n                  if (el.textContent?.split(\' \').length === 4\r\n                     && (thumb = el.closest(thumbsSelectors))) {\r\n                     thumb.remove();\r\n                  }\r\n               });\r\n         },\r\n         mix() {\r\n            if (!user_settings.mix_disable) return;\r\n            document.body.querySelectorAll(\r\n               `a[href*=\"list=\"][href*=\"start_radio=\"]:not([hidden]),\r\n               #video-title[title^=\"Mix -\"]:not([hidden])`\r\n            )\r\n               .forEach(el => el.closest(\'ytd-radio-renderer, ytd-compact-radio-renderer, \' + thumbsSelectors)?.remove());\r\n         },\r\n         watched() {\r\n            if (!user_settings.watched_disable) return;\r\n            if (!user_settings[\'thumbnails-watched\']) return;\r\n            const PERCENT_COMPLETE = user_settings.watched_disable_percent_complete || 90;\r\n            document.body.querySelectorAll(\'#thumbnail #overlays #progress\')\r\n               .forEach(el => {\r\n                  if (parseInt(el.style.width) > PERCENT_COMPLETE) {\r\n                     el.closest(thumbsSelectors)?.remove();\r\n                  }\r\n               });\r\n         },\r\n      };\r\n      if (user_settings.mix_disable) {\r\n         NOVA.css.push(\r\n            `ytd-radio-renderer {\r\n               display: none !important;\r\n            }`);\r\n      }\r\n   },\r\n   options: {\r\n      shorts_disable: {\r\n         _tagName: \'input\',\r\n         label: \'Hide Shorts\',\r\n         \'label:zh\': \'隐藏短裤\',\r\n         \'label:ja\': \'ショーツを隠す\',\r\n         \'label:ko\': \'반바지 숨기기\',\r\n         \'label:id\': \'Sembunyikan Celana Pendek\',\r\n         \'label:es\': \'Ocultar pantalones cortos\',\r\n         \'label:pt\': \'Ocultar shorts\',\r\n         \'label:fr\': \'Masquer les shorts\',\r\n         \'label:it\': \'Nascondi pantaloncini\',\r\n         \'label:de\': \'Shorts verstecken\',\r\n         \'label:pl\': \'Ukryj YouTube Shorts\',\r\n         \'label:ua\': \'Приховати прев`ю\',\r\n         type: \'checkbox\',\r\n      },\r\n      shorts_disable_min_duration: {\r\n         _tagName: \'input\',\r\n         label: \'Min duration in sec (for regular video)\',\r\n         \'label:zh\': \'最短持续时间（以秒为单位）\',\r\n         \'label:ja\': \'秒単位の最小期間\',\r\n         \'label:ko\': \'최소 지속 시간(초)\',\r\n         \'label:id\': \'Durasi lebih sedikit dalam detik\',\r\n         \'label:es\': \'Duración mínima en segundos\',\r\n         \'label:pt\': \'Duração mínima em segundos\',\r\n         \'label:fr\': \'Durée minimale en secondes\',\r\n         \'label:it\': \'Meno durata in sec\',\r\n         \'label:de\': \'Mindestdauer in Sekunden\',\r\n         \'label:pl\': \'Poniżej czasu trwania w sekundach\',\r\n         \'label:ua\': \'Мінімальна триваліcть в cекундах\',\r\n         type: \'number\',\r\n         title: \'0 - disable\',\r\n         placeholder: \'60-3600\',\r\n         step: 1,\r\n         min: 0,\r\n         max: 3600,\r\n         value: 0,\r\n      },\r\n      premieres_disable: {\r\n         _tagName: \'input\',\r\n         label: \'Hide Premieres/Upcoming\',\r\n         \'label:zh\': \'隐藏首映/即将上映\',\r\n         \'label:ja\': \'プレミア公開/近日公開を非表示\',\r\n         \'label:ko\': \'Premieres/예정 숨기기\',\r\n         \'label:id\': \'Sembunyikan Tayang Perdana/Mendatang\',\r\n         \'label:es\': \'Ocultar estrenos/próximos\',\r\n         \'label:pt\': \'Ocultar Estreias/Próximas\',\r\n         \'label:fr\': \'Masquer les premières/à venir\',\r\n         \'label:it\': \'Nascondi anteprime/in arrivo\',\r\n         \'label:de\': \'Premieren/Kommende ausblenden\',\r\n         \'label:pl\': \'Ukrywaj premiery\',\r\n         \'label:ua\': \'Приховати прем`єри\',\r\n         type: \'checkbox\',\r\n         title: \'Premiere Announcements\',\r\n      },\r\n      live_disable: {\r\n         _tagName: \'input\',\r\n         label: \'Hide Live streams\',\r\n         \'label:zh\': \'隐藏直播\',\r\n         \'label:ja\': \'ライブ ストリームを非表示にする\',\r\n         \'label:ko\': \'라이브 스트림 숨기기\',\r\n         \'label:id\': \'Sembunyikan streaming langsung\',\r\n         \'label:es\': \'Ocultar transmisiones en vivo\',\r\n         \'label:pt\': \'Ocultar transmissões ao vivo\',\r\n         \'label:fr\': \'Masquer les flux en direct\',\r\n         \'label:it\': \'Nascondi live streaming\',\r\n         \'label:de\': \'Live-Streams ausblenden\',\r\n         \'label:pl\': \'Ukryj strumień (na żywo)\',\r\n         \'label:ua\': \'Приховати живі транcляції\',\r\n         type: \'checkbox\',\r\n         title: \'Now airing\',\r\n         \'title:zh\': \'正在播出\',\r\n         \'title:ja\': \'放映中\',\r\n         \'title:ko\': \'지금 방영중\',\r\n         \'title:id\': \'Sekarang ditayangkan\',\r\n         \'title:es\': \'Ahora al aire\',\r\n         \'title:pt\': \'Agora no ar\',\r\n         \'title:fr\': \'Diffusion en cours\',\r\n         \'title:it\': \'Ora in onda\',\r\n         \'title:de\': \'Jetzt Lüften\',\r\n         \'title:pl\': \'Teraz wietrzenie\',\r\n         \'title:ua\': \'Зараз в ефірі\',\r\n      },\r\n      streamed_disable: {\r\n         _tagName: \'input\',\r\n         label: \'Hide finished streams\',\r\n         \'label:zh\': \'隐藏完成的流\',\r\n         \'label:ja\': \'終了したストリームを非表示にする\',\r\n         \'label:ko\': \'완료된 스트림 숨기기\',\r\n         \'label:id\': \'Sembunyikan aliran yang sudah selesai\',\r\n         \'label:es\': \'Ocultar flujos terminados\',\r\n         \'label:pt\': \'Ocultar streams concluídos\',\r\n         \'label:fr\': \'Masquer les flux terminés\',\r\n         \'label:it\': \'Nascondi i flussi finiti\',\r\n         \'label:de\': \'Fertige Streams ausblenden\',\r\n         \'label:pl\': \'Ukryj po streamie\',\r\n         \'label:ua\': \'cховати завершені транcляції\',\r\n         type: \'checkbox\',\r\n         //title: \'\',\r\n         \'data-dependent\': { \'live_disable\': true },\r\n      },\r\n      mix_disable: {\r\n         _tagName: \'input\',\r\n         label: \"Hide \'Mix\' thumbnails\",\r\n         \'label:zh\': \'隐藏[混合]缩略图\',\r\n         \'label:ja\': \'「Mix」サムネイルを非表示\',\r\n         \'label:ko\': \'\"믹스\" 썸네일 숨기기\',\r\n         \'label:id\': \'Sembunyikan gambar mini \"Mix\"\',\r\n         \'label:es\': \"Ocultar miniaturas de \'Mix\'\",\r\n         \'label:pt\': \"Ocultar miniaturas de \'Mix\'\",\r\n         \'label:fr\': \'Masquer les vignettes \"Mix\"\',\r\n         \'label:it\': \'Nascondi le miniature \"Mix\".\',\r\n         \'label:de\': \'„Mix“-Thumbnails ausblenden\',\r\n         \'label:pl\': \'Ukryj miniaturki \"Mix\"\',\r\n         \'label:ua\': \'Приховати мікc мініатюр\',\r\n         type: \'checkbox\',\r\n         title: \'[Mix] offers to rewatch what has already saw\',\r\n         \'title:zh\': \'[混合]提供重新观看已经看过的内容\',\r\n         \'title:ja\': \'「Mix」は、すでに見たものを再視聴することを提案します\',\r\n         \'title:ko\': \'[Mix]는 이미 본 것을 다시 볼 것을 제안합니다\',\r\n         \'title:id\': \'[Mix] menawarkan untuk menonton ulang apa yang telah dilihat\',\r\n         \'title:es\': \'[Mix] ofrece volver a ver lo que ya vio\',\r\n         \'title:pt\': \'[Mix] se oferece para rever o que já viu\',\r\n         \'title:it\': \'[Mix] si offre di rivedere ciò che ha già visto\',\r\n         \'title:de\': \'[Mix] bietet an, bereits Gesehenes noch einmal anzuschauen\',\r\n         \'title:pl\': \'[Mix] proponuje ponowne obejrzenie już obejrzanych filmów\',\r\n         \'title:ua\': \'[Mix] пропонує передивитиcя вже побачене\',\r\n      },\r\n      watched_disable: {\r\n         _tagName: \'input\',\r\n         label: \'Hide watched\',\r\n         \'label:zh\': \'隐藏观看\',\r\n         \'label:ja\': \'監視対象を非表示\',\r\n         \'label:ko\': \'시청 숨기기\',\r\n         \'label:id\': \'Sembunyikan ditonton\',\r\n         \'label:es\': \'Ocultar visto\',\r\n         \'label:pt\': \'Ocultar assistidos\',\r\n         \'label:fr\': \'Masquer surveillé\',\r\n         \'label:it\': \'Nascondi guardato\',\r\n         \'label:de\': \'Ausblenden beobachtet\',\r\n         \'label:pl\': \'Ukryj oglądane\',\r\n         \'label:ua\': \'cховати переглянуті відео\',\r\n         type: \'checkbox\',\r\n         title: \'Need to Turn on [YouTube History]\',\r\n      },\r\n      watched_disable_percent_complete: {\r\n         _tagName: \'input\',\r\n         label: \'Threshold percent\',\r\n         type: \'number\',\r\n         title: \'in %\',\r\n         placeholder: \'%\',\r\n         step: 5,\r\n         min: 5,\r\n         max: 100,\r\n         value: 90,\r\n         \'data-dependent\': { \'watched_disable\': true },\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'rss-link\',\r\n   title: \'Add RSS feed link\',\r\n   \'title:zh\': \'添加 RSS 提要链接\',\r\n   \'title:ja\': \'RSSフィードリンクを追加\',\r\n   \'title:ko\': \'RSS 피드 링크 추가\',\r\n   \'title:id\': \'Tambahkan tautan Umpan RSS\',\r\n   \'title:es\': \'Agregar enlace de fuente RSS\',\r\n   \'title:pt\': \'Adicionar link de feed RSS\',\r\n   \'title:fr\': \'Ajouter un lien de flux RSS\',\r\n   \'title:it\': \'Aggiungi collegamento al feed RSS\',\r\n   \'title:de\': \'RSS-Feed-Link hinzufügen\',\r\n   \'title:pl\': \'Dodaj kanał RSS\',\r\n   \'title:ua\': \'Додати RSS-посилання\',\r\n   run_on_pages: \'channel, playlist, -mobile\',\r\n   restart_on_location_change: true,\r\n   section: \'channel\',\r\n   _runtime: user_settings => {\r\n      const\r\n         SELECTOR_ID = \'nova-rss-link\',\r\n         rssLinkPrefix = \'/feeds/videos.xml\',\r\n         playlistURL = rssLinkPrefix + \'?playlist_id=\' + NOVA.queryURL.get(\'list\'),\r\n         genChannelURL = channelId => rssLinkPrefix + \'?channel_id=\' + channelId;\r\n      switch (NOVA.currentPage) {\r\n         case \'channel\':\r\n            NOVA.waitSelector(\'#channel-header #links-holder #primary-links\')\r\n               .then(container => {\r\n                  if (!parseInt(NOVA.css.getValue(\'#header div.banner-visible-area\', \'height\'))) {\r\n                     container = document.body.querySelector(\'#channel-header #inner-header-container #buttons\');\r\n                  }\r\n                  if (url = (document.querySelector(\'link[type=\"application/rss+xml\"][href]\')?.href\r\n                     || genChannelURL(NOVA.getChannelId(user_settings[\'user-api-key\'])))\r\n                  ) {\r\n                     insertToHTML({ \'url\': url, \'container\': container });\r\n                  }\r\n               });\r\n            break;\r\n         case \'playlist\':\r\n            NOVA.waitSelector(\'ytd-playlist-header-renderer .metadata-buttons-wrapper\', { stop_on_page_change: true })\r\n               .then(container => {\r\n                  insertToHTML({ \'url\': playlistURL, \'container\': container, \'is_playlist\': true });\r\n               });\r\n            break;\r\n      }\r\n      function insertToHTML({ url = required(), container = required(), is_playlist }) {\r\n         if (!(container instanceof HTMLElement)) return console.error(\'container not HTMLElement:\', container);\r\n         (container.querySelector(`#${SELECTOR_ID}`) || (function () {\r\n            const link = document.createElement(\'a\');\r\n            link.id = SELECTOR_ID;\r\n            link.target = \'_blank\';\r\n            link.className = `yt-spec-button-shape-next--overlay`;\r\n            link.innerHTML =\r\n               `<svg viewBox=\"-35 -35 55 55\" height=\"100%\" width=\"100%\" style=\"width: auto;\">\r\n                  <g fill=\"currentColor\">\r\n                     <path fill=\"#F60\" d=\"M-17.392 7.875c0 3.025-2.46 5.485-5.486 5.485s-5.486-2.46-5.486-5.485c0-3.026 2.46-5.486 5.486-5.486s5.486 2.461 5.486 5.486zm31.351 5.486C14.042.744 8.208-11.757-1.567-19.736c-7.447-6.217-17.089-9.741-26.797-9.708v9.792C-16.877-19.785-5.556-13.535.344-3.66a32.782 32.782 0 0 1 4.788 17.004h8.827v.017zm-14.96 0C-.952 5.249-4.808-2.73-11.108-7.817c-4.821-3.956-11.021-6.184-17.255-6.15v8.245c6.782-.083 13.432 3.807 16.673 9.774a19.296 19.296 0 0 1 2.411 9.326h8.278v-.017z\"/>\r\n                  </g>\r\n               </svg>`;\r\n            Object.assign(link.style, {\r\n               height: \'20px\',\r\n               display: \'inline-block\',\r\n               padding: \'5px\',\r\n            });\r\n            if (is_playlist) {\r\n               Object.assign(link.style, {\r\n                  \'margin-right\': \'8px\',\r\n                  \'border-radius\': \'20px\',\r\n                  \'background-color\': \'var(--yt-spec-static-overlay-button-secondary)\',\r\n                  color: \'var(--yt-spec-static-overlay-text-primary)\',\r\n                  padding: \'8px\',\r\n                  \'margin-right\': \'8px\',\r\n                  \'white-space\': \'nowrap\',\r\n                  \'font-size\': \'var(--ytd-tab-system-font-size, 1.4rem)\',\r\n                  \'font-weight\': \'var(--ytd-tab-system-font-weight, 500)\',\r\n                  \'letter-spacing\': \'var(--ytd-tab-system-letter-spacing, .007px)\',\r\n                  \'text-transform\': \'var(--ytd-tab-system-text-transform, uppercase)\',\r\n               });\r\n            }\r\n            container.prepend(link);\r\n            return link;\r\n         })())\r\n            .href = url;\r\n      }\r\n   },\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'channel-default-tab\',\r\n   title: \'Default tab on channel page\',\r\n   \'title:zh\': \'频道页默认选项卡\',\r\n   \'title:ja\': \'チャンネルページのデフォルトタブ\',\r\n   \'title:ko\': \'채널 페이지의 기본 탭\',\r\n   \'title:id\': \'Tab default di halaman saluran\',\r\n   \'title:es\': \'La pestaña predeterminada en la página del canal\',\r\n   \'title:pt\': \'A guia padrão na página do canal\',\r\n   \'title:fr\': \'Onglet par défaut sur la page de la chaîne\',\r\n   \'title:it\': \'Scheda predefinita nella pagina del canale\',\r\n   \'title:de\': \'Die Standardregisterkarte auf der Kanalseite\',\r\n   \'title:pl\': \'Domyślna karta na stronie kanału\',\r\n   \'title:ua\': \'Вкладка за умовчанням на сторінці каналу\',\r\n   run_on_pages: \'channel\',\r\n   restart_on_location_change: true,\r\n   section: \'channel\',\r\n   _runtime: user_settings => {\r\n      if (NOVA.channelTab) return;\r\n      if (user_settings.channel_default_tab_mode == \'redirect\') {\r\n         location.pathname += \'/\' + user_settings.channel_default_tab;\r\n      }\r\n      else {\r\n         const tabSelectors = \'#tabsContent > [role=\"tab\"]\';\r\n         NOVA.waitSelector(tabSelectors, { stop_on_page_change: true })\r\n            .then(() => {\r\n               let tabActive;\r\n               const tabs = [...document.querySelectorAll(tabSelectors)];\r\n               switch (user_settings.channel_default_tab) {\r\n                  case \'videos\': tabActive = tabs[1]; break;\r\n                  case \'playlists\': tabActive = tabs[tabs.length - 4]; break;\r\n                  case \'community\': tabActive = tabs[tabs.length - 3]; break;\r\n                  case \'about\': tabActive = tabs.pop(); break;\r\n                  default:\r\n                     location.pathname += \'/\' + user_settings.channel_default_tab;\r\n               }\r\n               tabActive?.click();\r\n            });\r\n      }\r\n   },\r\n   options: {\r\n      channel_default_tab: {\r\n         _tagName: \'select\',\r\n         label: \'Default tab\',\r\n         \'label:zh\': \'默认标签页\',\r\n         \'label:ja\': \'デフォルトのタブ\',\r\n         \'label:ko\': \'기본 탭\',\r\n         \'label:id\': \'tab bawaan\',\r\n         \'label:es\': \'Ficha predeterminada\',\r\n         \'label:pt\': \'Aba padrão\',\r\n         \'label:fr\': \'Onglet par défaut\',\r\n         \'label:it\': \'Scheda predefinita\',\r\n         \'label:de\': \'Standard-Tab\',\r\n         \'label:pl\': \'Domyślna karta\',\r\n         \'label:ua\': \'Вкладка за умовчанням\',\r\n         options: [\r\n            {\r\n               label: \'videos\', value: \'videos\', selected: true,\r\n               \'label:pl\': \'wideo\',\r\n               \'label:ua\': \'відео\',\r\n            },\r\n            {\r\n               label: \'shorts\', value: \'shorts\',\r\n            },\r\n            {\r\n               label: \'live\', value: \'streams\',\r\n            },\r\n            {\r\n               label: \'playlists\', value: \'playlists\',\r\n               \'label:pl\': \'playlista\',\r\n               \'label:ua\': \'плейлисти\',\r\n            },\r\n            {\r\n               label: \'community\', value: \'community\',\r\n            },\r\n            {\r\n               label: \'about\', value: \'about\',\r\n               \'label:pl\': \'o kanale\',\r\n               \'label:ua\': \'про канал\',\r\n            },\r\n         ],\r\n      },\r\n      channel_default_tab_mode: {\r\n         _tagName: \'select\',\r\n         label: \'Mode\',\r\n         \'label:zh\': \'模式\',\r\n         \'label:ja\': \'モード\',\r\n         \'label:ko\': \'방법\',\r\n         \'label:es\': \'Modo\',\r\n         \'label:pt\': \'Modo\',\r\n         \'label:it\': \'Modalità\',\r\n         \'label:de\': \'Modus\',\r\n         \'label:pl\': \'Tryb\',\r\n         \'label:ua\': \'Режим\',\r\n         title: \'Redirect is safer but slower\',\r\n         \'title:zh\': \'重定向是安全的，但速度很慢\',\r\n         \'title:ja\': \'リダイレクトは安全ですが遅くなります\',\r\n         \'title:ko\': \'리디렉션이 더 안전하지만 느립니다\',\r\n         \'title:id\': \'Redirect lebih aman tetapi lebih lambat\',\r\n         \'title:es\': \'La redirección es más segura pero más lenta\',\r\n         \'title:pt\': \'O redirecionamento é mais seguro, mas mais lento\',\r\n         \'title:fr\': \'La redirection est plus sûre mais plus lente\',\r\n         \'title:it\': \'Il reindirizzamento è più sicuro ma più lento\',\r\n         \'title:de\': \'Redirect ist sicherer, aber langsamer\',\r\n         \'title:pl\': \'Przekierowanie jest bezpieczniejsze, ale wolniejsze\',\r\n         \'title:ua\': \'Перенаправлення безпечніше, але повільніше\',\r\n         options: [\r\n            {\r\n               label: \'redirect\', value: \'redirect\',\r\n               \'label:pl\': \'przekierowanie\',\r\n               \'label:ua\': \'перенаправити\',\r\n            },\r\n            {\r\n               label: \'click\', selected: true,\r\n               \'label:pl\': \'klik\',\r\n               \'label:ua\': \'клік\',\r\n            },\r\n         ],\r\n         \'data-dependent\': { \'channel_default_tab\': [\'videos\', \'playlists\', \'community\', \'about\'] },\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'thumbs-preview-stop\',\r\n   title: \'Autostop thumbnail preview playback\',\r\n   run_on_pages: \'home, feed, -mobile\',\r\n   section: \'other\',\r\n   _runtime: user_settings => {\r\n      NOVA.waitSelector(\'#inline-preview-player\')\r\n         .then(player => {\r\n            NOVA.waitSelector(\'video\', { \'container\': player })\r\n               .then(video => {\r\n                  video.addEventListener(\'play\', () => player.stopVideo());\r\n               });\r\n         });\r\n   },\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'ad-skip-button\',\r\n   title: \'Ad intro skip\',\r\n   \'title:zh\': \'广告视频跳过\',\r\n   \'title:ja\': \'広告スキップ\',\r\n   \'title:ko\': \'광고 건너뛰기\',\r\n   \'title:id\': \'Intro iklan Lewati\',\r\n   \'title:es\': \'Saltar anuncios\',\r\n   \'title:pt\': \'Pular anúncios\',\r\n   \'title:fr\': \'Ignorer les annonces\',\r\n   \'title:it\': \'Salta introduttivo\',\r\n   \'title:de\': \'Anzeigen überspringen\',\r\n   \'title:pl\': \'Pomiń początkową reklamę\',\r\n   //\'title:ua\': \'Натиснути пропустити рекламу\',\r\n   \'title:ua\': \'Кнопка пропустити рекламу\',\r\n   run_on_pages: \'watch\',\r\n   section: \'player\',\r\n   desc: \'Auto click on the [Skip Ad] button\',\r\n   \'desc:zh\': \'自动点击“Skip Ad”按钮\',\r\n   \'desc:ja\': \'「Skip Ad」ボタンの自動クリック\',\r\n   \'desc:ko\': \'【광고 건너뛰기】버튼 자동 클릭\',\r\n   \'desc:id\': \'Klik otomatis pada tombol [Lewati Iklan]\',\r\n   \'desc:es\': \'Haga clic automáticamente en el botón [Omitir anuncio]\',\r\n   \'desc:pt\': \'Clique automaticamente no botão [Ignorar anúncio]\',\r\n   \'desc:fr\': \"Clic automatique sur le bouton [Ignorer l\'annonce]\",\r\n   \'desc:it\': \'Fare clic automaticamente sul pulsante [Salta annuncio].\',\r\n   \'desc:pl\': \'Auto kliknięcie przycisku [Pomiń reklamę]\',\r\n   \'desc:ua\': \'Автоматично натискати кнопку для пропуску реклами\',\r\n   _runtime: user_settings => {\r\n      NOVA.waitSelector(\'#movie_player.ad-showing video\')\r\n         .then(video => {\r\n            adSkip();\r\n            movie_player.addEventListener(\'onAdStateChange\', adSkip.bind(video));\r\n            video.addEventListener(\'loadedmetadata\', adSkip.bind(video));\r\n            video.addEventListener(\'loadeddata\', adSkip.bind(video));\r\n            video.addEventListener(\'canplay\', adSkip.bind(video));\r\n         });\r\n      function adSkip() {\r\n         if (!movie_player.classList.contains(\'ad-showing\')) return;\r\n         this.currentTime = this.duration;\r\n         NOVA.waitSelector(\'div.ytp-ad-text.ytp-ad-skip-button-text:not([hidden]), button.ytp-ad-skip-button:not([hidden])\', { stop_on_page_change: true })\r\n            .then(btn => btn.click());\r\n      }\r\n   },\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'player-control-below\',\r\n   title: \'Control panel below the player\',\r\n   \'title:ua\': \'Панель керування під плеєром\',\r\n   run_on_pages: \'watch, -mobile\',\r\n   section: \'player\',\r\n   _runtime: user_settings => {\r\n      NOVA.waitSelector(\'.ytp-chrome-bottom\')\r\n         .then(async control_panel => {\r\n            if ((heightPanel = NOVA.css.getValue(control_panel, \'height\'))\r\n               && (heightProgressBar = NOVA.css.getValue(\'.ytp-progress-bar-container\', \'height\'))\r\n            ) {\r\n               const height = `calc(${heightPanel} + ${heightProgressBar})` || \'51px\';\r\n               let SELECTOR_CONTAINER = \'ytd-watch-flexy:not([fullscreen])\';\r\n               if ([\'cinema_mode\', \'force\'].includes(user_settings.player_full_viewport_mode)) {\r\n                  SELECTOR_CONTAINER += `:not([theater])`;\r\n               }\r\n               NOVA.css.push(\r\n                  `\r\n                  ${SELECTOR_CONTAINER} .ytp-caption-window-bottom {\r\n                     margin-bottom: 0;\r\n                  }\r\n                  \r\n                  ${SELECTOR_CONTAINER} .ytp-gradient-bottom {\r\n                     transform: translateY(${height});\r\n                     display: block !important;\r\n                     opacity: 1 !important;\r\n                     height: ${height} !important;\r\n                     padding: 0;\r\n                     background-color: #0f0f0f; \r\n                  }\r\n                  \r\n                  ${SELECTOR_CONTAINER} .ytp-chrome-bottom {\r\n                     transform: translateY(${height});\r\n                     opacity: 1 !important;\r\n                  }\r\n                  \r\n                  ${SELECTOR_CONTAINER} .html5-video-player {\r\n                     overflow: visible;\r\n                  }\r\n                  \r\n                  ${SELECTOR_CONTAINER} .ytp-player-content.ytp-iv-player-content {\r\n                     bottom: ${NOVA.css.getValue(\'.ytp-player-content.ytp-iv-player-content\', \'left\') || \'12px\'};\r\n                  }\r\n                  \r\n                  ${SELECTOR_CONTAINER} .ytp-tooltip,\r\n                  ${SELECTOR_CONTAINER} .ytp-settings-menu {\r\n                     transform: translateY(${height});\r\n                  }\r\n                  \r\n                  \r\n                  ${SELECTOR_CONTAINER}[theater] > #columns,\r\n                  ${SELECTOR_CONTAINER}:not([theater]) #below {\r\n                     margin-top: ${height} !important;\r\n                  }\r\n                  \r\n                  `);\r\n               if (user_settings[\'player-float-progress-bar\']) {\r\n                  NOVA.css.push(\r\n                     `#movie_player.ytp-autohide .ytp-chrome-bottom .ytp-progress-bar-container {\r\n                        display: none !important;\r\n                     }`);\r\n               }\r\n               fixControlFreeze.apply(document.body.querySelector(\'ytd-watch-flexy\'));\r\n            }\r\n         });\r\n      function fixControlFreeze(ms = 2000) {\r\n         const moveMouse = new Event(\'mousemove\');\r\n         return window.setInterval(() => {\r\n            if ([\'smart\'].includes(user_settings.player_full_viewport_mode) && NOVA.css.getValue(movie_player, \'z-index\') != \'2020\' && NOVA.css.getValue(movie_player, \'position\') != \'fixed\') return;\r\n            if (NOVA.currentPage === \'watch\'\r\n               && document.visibilityState == \'visible\'\r\n               && movie_player.classList.contains(\'playing-mode\')\r\n               && !NOVA.isFullscreen()\r\n               && user_settings.player_hide_elements != \'time_display\'\r\n               && (!user_settings[\'theater-mode\'] || (user_settings[\'theater-mode\'] && ![\'cinema_mode\', \'force\'].includes(user_settings.player_full_viewport_mode)))\r\n            ) {\r\n               movie_player.dispatchEvent(moveMouse);\r\n            }\r\n         }, ms);\r\n      }\r\n   },\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'player-hide-elements\',\r\n   title: \'Hide some player buttons/elements\',\r\n   run_on_pages: \'watch, embed, -mobile\',\r\n   section: \'player\',\r\n   _runtime: user_settings => {\r\n      const SELECTORS = {\r\n         \'videowall_endscreen\': \'#movie_player .videowall-endscreen\',\r\n         \'card_endscreen\': \'#movie_player [class^=\"ytp-ce-\"]\',\r\n         \'prev_button\': \'#movie_player .ytp-chrome-bottom .ytp-prev-button\',\r\n         \'play_button\': \'#movie_player .ytp-chrome-bottom .ytp-play-button\',\r\n         \'next_button\': \'#movie_player .ytp-chrome-bottom .ytp-next-button\',\r\n         \'volume_area\': \'#movie_player .ytp-chrome-bottom .ytp-volume-area\',\r\n         \'time_display\': \'#movie_player .ytp-chrome-bottom .ytp-time-display\'\r\n            + (user_settings[\'time-remaining\'] ? \' span > span:not([id])\' : \'\'),\r\n         \'chapter_container\': \'#movie_player .ytp-chrome-bottom .ytp-chapter-container\',\r\n         \'autonav_toggle_button\': \'#movie_player .ytp-chrome-bottom button.ytp-button[data-tooltip-target-id=\"ytp-autonav-toggle-button\"]\',\r\n         \'subtitles_button\': \'#movie_player .ytp-chrome-bottom button.ytp-subtitles-button\',\r\n         \'settings_button\': \'#movie_player .ytp-chrome-bottom button.ytp-settings-button\',\r\n         \'size_button\': \'#movie_player .ytp-chrome-bottom button.ytp-size-button\',\r\n         \'miniplayer_button\': \'#movie_player .ytp-chrome-bottom button.ytp-miniplayer-button\',\r\n         \'logo_button\': \'#movie_player .ytp-chrome-bottom .yt-uix-sessionlink\',\r\n         \'fullscreen_button\': \'#movie_player .ytp-chrome-bottom button.ytp-fullscreen-button\',\r\n      };\r\n      const toArray = a => Array.isArray(a) ? a : [a];\r\n      let list = [];\r\n      toArray(user_settings.player_hide_elements)\r\n         .forEach(el => (data = SELECTORS[el]) && list.push(data));\r\n      if (list.length) {\r\n         NOVA.css.push(\r\n            list.join(\',\\n\') + ` {\r\n               display: none !important;\r\n            }`);\r\n      }\r\n   },\r\n   options: {\r\n      player_hide_elements: {\r\n         _tagName: \'select\',\r\n         label: \'Items\',\r\n         title: \'[Ctrl+Click] to select several\',\r\n         \'title:zh\': \'[Ctrl+Click] 选择多个\',\r\n         \'title:ja\': \'「Ctrl+Click」して、いくつかを選択します\',\r\n         \'title:ko\': \'[Ctrl+Click] 여러 선택\',\r\n         \'title:id\': \'[Ctrl+Klik] untuk memilih beberapa\',\r\n         \'title:es\': \'[Ctrl+Click] para seleccionar varias\',\r\n         \'title:pt\': \'[Ctrl+Click] para selecionar vários\',\r\n         \'title:fr\': \'[Ctrl+Click] pour sélectionner plusieurs\',\r\n         \'title:it\': \'[Ctrl+Clic] per selezionarne diversi\',\r\n         \'title:de\': \'[Ctrl+Click] um mehrere auszuwählen\',\r\n         \'title:pl\': \'Ctrl+kliknięcie, aby zaznaczyć kilka\',\r\n         \'title:ua\': \'[Ctrl+Click] щоб обрати декілька\',\r\n         multiple: null,\r\n         required: true,\r\n         size: 10,\r\n         options: [\r\n            {\r\n               label: \'videowall (thumbs)\', value: \'videowall_endscreen\',\r\n            },\r\n            {\r\n               label: \'card\', value: \'card_endscreen\',\r\n            },\r\n            {\r\n               label: \'prev\', value: \'prev_button\',\r\n            },\r\n            {\r\n               label: \'play\', value: \'play_button\',\r\n            },\r\n            {\r\n               label: \'next\', value: \'next_button\',\r\n            },\r\n            {\r\n               label: \'volume\', value: \'volume_area\',\r\n            },\r\n            {\r\n               label: \'time\', value: \'time_display\',\r\n            },\r\n            {\r\n               label: \'chapter\', value: \'chapter_container\',\r\n            },\r\n            {\r\n               label: \'autonav toggle\', value: \'autonav_toggle_button\',\r\n            },\r\n            {\r\n               label: \'subtitles\', value: \'subtitles_button\',\r\n            },\r\n            {\r\n               label: \'settings\', value: \'settings_button\',\r\n            },\r\n            {\r\n               label: \'size\', value: \'size_button\',\r\n            },\r\n            {\r\n               label: \'miniplayer\', value: \'miniplayer_button\',\r\n            },\r\n            {\r\n               label: \'logo (embed)\', value: \'logo_button\',\r\n            },\r\n            {\r\n               label: \'fullscreen\', value: \'fullscreen_button\',\r\n            },\r\n         ],\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'player-resize-ratio\',\r\n   title: \'Player force resize 16:9\',\r\n   \'title:ua\': \'Примусова зміна розміру програвача 16:9\',\r\n   run_on_pages: \'watch\',\r\n   section: \'player\',\r\n   desc: \'only for 4:3 video\',\r\n   \'desc:ua\': \'Лише для відео розміром 4:3\',\r\n   _runtime: user_settings => {\r\n      NOVA.waitSelector(\'ytd-watch-flexy:not([theater])\')\r\n         .then(ytd_watch => {\r\n            NOVA.waitSelector(\'#movie_player video\')\r\n               .then(video => {\r\n                  console.assert(ytd_watch.calculateCurrentPlayerSize_, \'\"ytd_watch\" does not have fn \"calculateCurrentPlayerSize_\"\');\r\n                  const\r\n                     heightRatio = .5625,\r\n                     check4to3 = () => \'4:3\' == NOVA.aspectRatio.getAspectRatio({\r\n                        \'width\': video.videoWidth,\r\n                        \'height\': video.videoHeight,\r\n                     });\r\n                  if (ytd_watch.calculateCurrentPlayerSize_ && ytd_watch.updateStyles) {\r\n                     const backupFn = ytd_watch.calculateCurrentPlayerSize_;\r\n                     patchYtCalculateFn();\r\n                     video.addEventListener(\'loadeddata\', patchYtCalculateFn);\r\n                     function sizeBypass() {\r\n                        let width = height = NaN;\r\n                        if (!ytd_watch.theater) {\r\n                           width = movie_player.offsetWidth;\r\n                           height = Math.round(movie_player.offsetWidth / (16 / 9));\r\n                           if (ytd_watch.updateStyles) {\r\n                              ytd_watch.updateStyles({\r\n                                 \'--ytd-watch-flexy-width-ratio\': 1,\r\n                                 \'--ytd-watch-flexy-height-ratio\': heightRatio,\r\n                              });\r\n                              window.dispatchEvent(new Event(\'resize\'));\r\n                           }\r\n                        }\r\n                        return {\r\n                           \'width\': width,\r\n                           \'height\': height,\r\n                        };\r\n                     }\r\n                     function patchYtCalculateFn() {\r\n                        ytd_watch.calculateCurrentPlayerSize_ = check4to3() ? sizeBypass : backupFn;\r\n                     }\r\n                  }\r\n                  else {\r\n                     new MutationObserver(mutationRecordsArray => {\r\n                        if (!ytd_watch.theater && heightRatio != ytd_watch.style.getPropertyValue(\'--ytd-watch-flexy-height-ratio\')) {\r\n                           updateRatio();\r\n                        }\r\n                     })\r\n                        .observe(ytd_watch, { attributes: true, attributeFilter: [\'style\'] });\r\n                  }\r\n                  window.addEventListener(\'resize\', updateRatio);\r\n                  function updateRatio() {\r\n                     if (check4to3()) {\r\n                        ytd_watch.style.setProperty(\'--ytd-watch-flexy-width-ratio\', 1);\r\n                        ytd_watch.style.setProperty(\'--ytd-watch-flexy-height-ratio\', heightRatio);\r\n                     }\r\n                  }\r\n               });\r\n         });\r\n   },\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'player-hotkeys-focused\',\r\n   title: \'Player shortcuts always active\',\r\n   \'title:zh\': \'播放器热键始终处于活动状态\',\r\n   \'title:ja\': \'プレーヤーのホットキーは常にアクティブです\',\r\n   \'title:ko\': \'플레이어 단축키는 항상 활성화되어 있습니다\',\r\n   \'title:id\': \'Tombol pintas pemain selalu aktif\',\r\n   \'title:es\': \'Teclas de acceso rápido del jugador siempre activas\',\r\n   \'title:pt\': \'Teclas de atalho do jogador sempre ativas\',\r\n   \'title:fr\': \'Les raccourcis clavier du joueur sont toujours actifs\',\r\n   \'title:it\': \'Tasti di scelta rapida del giocatore sempre attivi\',\r\n   \'title:de\': \'Player-Hotkeys immer aktiv\',\r\n   \'title:pl\': \'Klawisze skrótów dla graczy zawsze aktywne\',\r\n   \'title:ua\': \'Гарячі клавіші відтворювача завжди активні\',\r\n   run_on_pages: \'watch, embed, -mobile\',\r\n   section: \'player\',\r\n   _runtime: user_settings => {\r\n      document.addEventListener(\'keydown\', evt => {\r\n         if ([\'input\', \'textarea\', \'select\'].includes(evt.target.localName) || evt.target.isContentEditable) return;\r\n         movie_player.focus();\r\n         if (user_settings.hotkeys_disable_numpad && evt.code.startsWith(\'Numpad\')) {\r\n            evt.preventDefault();\r\n            evt.stopPropagation();\r\n            evt.stopImmediatePropagation();\r\n         }\r\n      });\r\n   },\r\n   options: {\r\n      hotkeys_disable_numpad: {\r\n         _tagName: \'input\',\r\n         label: \'Disable numpad hotkeys\',\r\n         type: \'checkbox\',\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'disable-player-sleep-mode\',\r\n   title: \'Disable the \"Continue watching?\" popup\',\r\n   \'title:zh\': \'玩家永远保持活跃\',\r\n   \'title:ja\': \'プレーヤーは永遠にアクティブなままです\',\r\n   \'title:ko\': \'플레이어는 영원히 활성 상태를 유지\',\r\n   \'title:id\': \'Pemain tetap aktif selamanya\',\r\n   \'title:es\': \'El jugador permanece activo para siempre\',\r\n   \'title:pt\': \'Jogador permanece ativo para sempre\',\r\n   \'title:fr\': \'Le joueur reste actif pour toujours\',\r\n   \'title:it\': \'Il giocatore resta attivo per sempre\',\r\n   \'title:de\': \'Spieler bleiben für immer aktiv\',\r\n   \'title:pl\': \'Wyłącz tryb uśpienia odtwarzacza\',\r\n   \'title:ua\': \'Вимкнути режим сну відтворювача\',\r\n   run_on_pages: \'watch, -mobile\',\r\n   section: \'player\',\r\n   _runtime: user_settings => {\r\n      window.setInterval(() => {\r\n         if (!document.hasFocus()) {\r\n            document.dispatchEvent(\r\n               new KeyboardEvent(\'keyup\', { bubbles: true, cancelable: true, keyCode: 143, which: 143 })\r\n            );\r\n         }\r\n      }, 1000 * 60 * 5);\r\n   },\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'embed-show-control-force\',\r\n   title: \'Force enable control panel in embed\',\r\n   \'title:zh\': \'埋め込みでコントロール パネルを強制的に有効にする\',\r\n   \'title:ja\': \'强制启用嵌入的控制面板\',\r\n   \'title:ko\': \'임베디드에서 강제 활성화 제어판\',\r\n   \'title:id\': \'Paksa aktifkan panel kontrol di sematan\',\r\n   \'title:es\': \'Forzar habilitar el panel de control en incrustar\',\r\n   \'title:pt\': \'Forçar ativação do painel de controle na incorporação\',\r\n   \'title:fr\': \"Forcer l\'activation du panneau de contrôle dans l\'intégration\",\r\n   \'title:it\': \"Forza l\'abilitazione del pannello di controllo nell\'incorporamento\",\r\n   \'title:de\': \'Erzwingen Sie die Aktivierung des Bedienfelds in der Einbettung\',\r\n   \'title:pl\': \'Wymuś włączenie panelu sterowania w osadzeniu\',\r\n   \'title:ua\': \'Примусово показувати панель керування у вбудованому відео\',\r\n   run_on_pages: \'embed\',\r\n   section: \'player\',\r\n   _runtime: user_settings => {\r\n      if ([\'0\', \'false\'].includes(NOVA.queryURL.get(\'controls\'))) {\r\n         NOVA.updateUrl(NOVA.queryURL.remove(\'controls\'));\r\n      }\r\n   },\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'time-jump\',\r\n   title: \'Time jump\',\r\n   \'title:zh\': \'时间跳跃\',\r\n   \'title:ja\': \'タイムジャンプ\',\r\n   \'title:ko\': \'시간 점프\',\r\n   \'title:id\': \'Lompatan waktu\',\r\n   \'title:es\': \'Salto de tiempo\',\r\n   \'title:pt\': \'Salto no tempo\',\r\n   \'title:fr\': \'Saut dans le temps\',\r\n   \'title:it\': \'Salto nel tempo\',\r\n   \'title:de\': \'Zeitsprung\',\r\n   \'title:pl\': \'Skok czasowy\',\r\n   \'title:ua\': \'Стрибок часу\',\r\n   run_on_pages: \'watch, embed, -mobile\',\r\n   section: \'player\',\r\n   desc: \'Use to skip the intro or ad inserts\',\r\n   \'desc:zh\': \'用于跳过介绍或广告插入\',\r\n   \'desc:ja\': \'イントロや広告挿入をスキップするために使用します\',\r\n   \'desc:ko\': \'인트로 또는 광고 삽입을 건너뛸 때 사용\',\r\n   \'desc:id\': \'Gunakan untuk melewati intro atau sisipan iklan\',\r\n   \'desc:pt\': \'Use para pular a introdução ou inserções de anúncios\',\r\n   \'desc:fr\': \"Utiliser pour ignorer l\'intro ou les encarts publicitaires\",\r\n   \'desc:pl\': \'Służy do pomijania wstępu lub wstawek reklamowych\',\r\n   \'desc:ua\': \'Використовуйте щоб пропустити інтро\',\r\n   _runtime: user_settings => {\r\n      if (user_settings.time_jump_title_offset) addTitleOffset();\r\n      NOVA.waitSelector(\'#movie_player video\')\r\n         .then(video => {\r\n            let chapterList;\r\n            video.addEventListener(\'loadeddata\', () => chapterList = []);\r\n            doubleKeyPressListener(timeLeap, user_settings.time_jump_hotkey);\r\n            function timeLeap() {\r\n               if (movie_player.getVideoData().isLive\r\n                  || (NOVA.currentPage == \'embed\' && window.self.location.href.includes(\'live_stream\'))\r\n               ) return;\r\n               if (chapterList !== null && !chapterList?.length) {\r\n                  chapterList = NOVA.getChapterList(movie_player.getDuration()) || null;\r\n               }\r\n               const\r\n                  currentTime = movie_player.getCurrentTime(),\r\n                  nextChapterIndex = chapterList?.findIndex(c => c.sec > currentTime),\r\n                  separator = \' • \';\r\n               let msg;\r\n               if (chapterList?.length\r\n                  && nextChapterIndex !== -1\r\n               ) {\r\n                  const nextChapterData = chapterList?.find(({ sec }) => sec >= currentTime);\r\n                  seekTime(nextChapterData.sec + .5);\r\n                  msg = nextChapterData.title + separator + nextChapterData.time;\r\n               }\r\n               else {\r\n                  seekTime(+user_settings.time_jump_step + currentTime);\r\n                  msg = `+${user_settings.time_jump_step} sec` + separator + NOVA.timeFormatTo.HMS.digit(currentTime);\r\n               }\r\n               NOVA.bezelTrigger(msg);\r\n            }\r\n            function seekTime(sec) {\r\n               if (typeof movie_player.seekBy === \'function\') {\r\n                  movie_player.seekTo(sec);\r\n               }\r\n               else if (NOVA.videoElement) {\r\n                  NOVA.videoElement.currentTime = sec;\r\n               }\r\n               else {\r\n                  const errorText = \'[time-jump] > \"seekTime\" detect player error\'\r\n                  console.error(errorText);\r\n                  throw errorText;\r\n               }\r\n            }\r\n         });\r\n      function addTitleOffset() {\r\n         NOVA.css.push(\r\n            `.ytp-tooltip-text:after {\r\n               content: attr(data-before);\r\n               color: #ffcc00;\r\n            }`);\r\n         NOVA.waitSelector(\'.ytp-progress-bar\')\r\n            .then(progressContainer => {\r\n               if (tooltipEl = document.body.querySelector(\'.ytp-tooltip-text\')) {\r\n                  progressContainer.addEventListener(\'mousemove\', () => {\r\n                     if (movie_player.getVideoData().isLive\r\n                        || (NOVA.currentPage == \'embed\' && window.self.location.href.includes(\'live_stream\'))\r\n                     ) return;\r\n                     const\r\n                        cursorTime = NOVA.timeFormatTo.hmsToSec(tooltipEl.textContent),\r\n                        offsetTime = cursorTime - NOVA.videoElement?.currentTime,\r\n                        sign = (offsetTime >= 1) ? \'+\' : (Math.sign(offsetTime) === -1) ? \'-\' : \'\';\r\n                     tooltipEl.setAttribute(\'data-before\', ` ${sign + NOVA.timeFormatTo.HMS.digit(offsetTime)}`);\r\n                  });\r\n                  progressContainer.addEventListener(\'mouseleave\', () => tooltipEl.removeAttribute(\'data-before\'));\r\n               }\r\n            });\r\n      }\r\n      function doubleKeyPressListener(callback, keyCodeFilter) {\r\n         let\r\n            pressed,\r\n            isDoublePress,\r\n            lastPressed = parseInt(keyCodeFilter) || null;\r\n         const\r\n            timeOut = () => setTimeout(() => isDoublePress = false, 500),\r\n            handleDoublePresss = key => {\r\n               if (callback && typeof callback === \'function\') return callback(key);\r\n            };\r\n         function keyPress(evt) {\r\n            if ([\'input\', \'textarea\', \'select\'].includes(evt.target.localName) || evt.target.isContentEditable) return;\r\n            pressed = evt.keyCode;\r\n            if (isDoublePress && pressed === lastPressed) {\r\n               isDoublePress = false;\r\n               handleDoublePresss(evt);\r\n            }\r\n            else {\r\n               isDoublePress = true;\r\n               timeOut();\r\n            }\r\n            if (!keyCodeFilter) lastPressed = pressed;\r\n         }\r\n         document.addEventListener(\'keyup\', keyPress);\r\n      }\r\n      if (user_settings[\'save-channel-state\']) {\r\n         NOVA.waitSelector(\'#movie_player video\')\r\n            .then(video => {\r\n               NOVA.runOnPageInitOrTransition(async () => {\r\n                  const\r\n                     CACHE_PREFIX = \'nova-resume-playback-time\',\r\n                     getCacheName = () => CACHE_PREFIX + \':\' + (NOVA.queryURL.get(\'v\') || movie_player.getVideoData().video_id);\r\n                  if ((NOVA.currentPage == \'watch\' || NOVA.currentPage == \'embed\')\r\n                     && !+sessionStorage.getItem(getCacheName())\r\n                     && !NOVA.queryURL.has(\'t\')\r\n                     && (userSeek = await NOVA.storage_obj_manager.getParam(\'skip-into\'))\r\n                  ) {\r\n                     video.addEventListener(\'canplay\', timeLeapInto.apply(video, [userSeek]), { capture: true, once: true });\r\n                  }\r\n               });\r\n            });\r\n      }\r\n      else if (+user_settings.skip_into_step) {\r\n         NOVA.waitSelector(\'#movie_player video\')\r\n            .then(video => {\r\n               NOVA.runOnPageInitOrTransition(() => {\r\n                  if (NOVA.currentPage == \'watch\') {\r\n                     video.addEventListener(\'canplay\', timeLeapInto.bind(video), { capture: true, once: true });\r\n                  }\r\n               });\r\n            });\r\n      }\r\n      function timeLeapInto(time_seek = user_settings.skip_into_step || 10) {\r\n         if (!time_seek && !user_settings.skip_into_step_in_music && NOVA.isMusic()) return;\r\n         const\r\n            CACHE_PREFIX = \'resume-playback-time\',\r\n            getCacheName = () => CACHE_PREFIX + \':\' + (NOVA.queryURL.get(\'v\') || movie_player.getVideoData().video_id);\r\n         if (user_settings[\'player-resume-playback\']\r\n            && (saveTime = +sessionStorage.getItem(getCacheName()))\r\n            && (saveTime > (this.duration - 3))\r\n         ) return;\r\n         if ((isNaN(this.duration) || this.duration > 30)\r\n            && this.currentTime < (+user_settings.skip_into_step || +time_seek)\r\n         ) {\r\n            this.currentTime = +time_seek;\r\n         }\r\n      }\r\n   },\r\n   options: {\r\n      time_jump_step: {\r\n         _tagName: \'input\',\r\n         label: \'Step time\',\r\n         \'label:zh\': \'步骤时间\',\r\n         \'label:ko\': \'단계 시간\',\r\n         \'label:id\': \'Langkah waktu\',\r\n         \'label:es\': \'Tiempo de paso\',\r\n         \'label:pt\': \'Tempo da etapa\',\r\n         \'label:fr\': \'Temps de pas\',\r\n         \'label:it\': \'Tempo di passaggio\',\r\n         \'label:de\': \'Schrittzeit\',\r\n         \'label:pl\': \'Krok czasowy\',\r\n         \'label:ua\': \'Крок часу\',\r\n         type: \'number\',\r\n         title: \'In seconds\',\r\n         placeholder: \'sec\',\r\n         min: 3,\r\n         max: 300,\r\n         value: 30,\r\n      },\r\n      time_jump_hotkey: {\r\n         _tagName: \'select\',\r\n         label: \'Hotkey (double click)\',\r\n         \'label:zh\': \'热键（双击）\',\r\n         \'label:ja\': \'Hotkey (ダブルプレス)\',\r\n         \'label:ko\': \'단축키(더블 클릭)\',\r\n         \'label:id\': \'Tombol pintas (klik dua kali)\',\r\n         \'label:es\': \'Tecla de acceso rápido (doble clic)\',\r\n         \'label:pt\': \'Atalho (duplo clique)\',\r\n         \'label:fr\': \'Raccourci clavier (double clic)\',\r\n         \'label:it\': \'Tasto di scelta rapida (doppio clic)\',\r\n         \'label:de\': \'Hotkey (Doppelklick)\',\r\n         \'label:pl\': \'Klawisz skrótu (podwójne kliknięcie)\',\r\n         \'label:ua\': \'Гаряча клавіша (двічі натиснути)\',\r\n         options: [\r\n            { label: \'alt\', value: 18 },\r\n            { label: \'shift\', value: 16 },\r\n            { label: \'ctrl\', value: 17, selected: true },\r\n         ],\r\n      },\r\n      time_jump_title_offset: {\r\n         _tagName: \'input\',\r\n         label: \'Show time offset on progress bar\',\r\n         \'label:zh\': \'在进度条中显示时间偏移\',\r\n         \'label:ja\': \'プログレスバーに時間オフセットを表示する\',\r\n         \'label:ko\': \'진행률 표시줄에 시간 오프셋 표시\',\r\n         \'label:id\': \'Tampilkan offset waktu di bilah kemajuan\',\r\n         \'label:es\': \'Mostrar compensación de tiempo en la barra de progreso\',\r\n         \'label:pt\': \'Mostrar a diferença de tempo na barra de progresso\',\r\n         \'label:fr\': \'Afficher le décalage horaire sur la barre de progression\',\r\n         \'label:it\': \"Mostra l\'offset di tempo sulla barra di avanzamento\",\r\n         \'label:de\': \'Zeitverschiebung im Fortschrittsbalken anzeigen\',\r\n         \'label:pl\': \'Pokaż przesunięcie czasu na pasku postępu\',\r\n         \'label:ua\': \'Показувати часовий зсув на панелі прогресу\',\r\n         type: \'checkbox\',\r\n         title: \'Time offset from current playback time\',\r\n         \'title:zh\': \'与当前播放时间的时间偏移\',\r\n         \'title:ja\': \'現在の再生時間からの時間オフセット\',\r\n         \'title:ko\': \'현재 재생 시간으로부터의 시간 오프셋\',\r\n         \'label:id\': \'Waktu offset dari waktu pemutaran saat ini\',\r\n         \'title:es\': \'Desfase de tiempo del tiempo de reproducción actual\',\r\n         \'title:pt\': \'Deslocamento de tempo do tempo de reprodução atual\',\r\n         \'title:fr\': \"Décalage temporel par rapport à l\'heure de lecture actuelle\",\r\n         \'title:it\': \'Spostamento temporale dal tempo di riproduzione corrente\',\r\n         \'title:de\': \'Zeitverschiebung zur aktuellen Wiedergabezeit\',\r\n         \'title:pl\': \'Przesunięcie czasu względem bieżącego czasu odtwarzania\',\r\n         \'title:ua\': \'Часовий зсув відносно поточного часу відтворення\',\r\n      },\r\n      skip_into_step: {\r\n         _tagName: \'input\',\r\n         label: \'Start playback at\',\r\n         \'label:zh\': \'设置开始时间\',\r\n         \'label:ja\': \'開始時刻を設定\',\r\n         \'label:ko\': \'시작 시간 설정\',\r\n         \'label:id\': \'Tetapkan waktu mulai\',\r\n         \'label:es\': \'Establecer hora de inicio\',\r\n         \'label:pt\': \'Definir horário de início\',\r\n         \'label:fr\': \"Définir l\'heure de début\",\r\n         \'label:it\': \"Imposta l\'ora di inizio\",\r\n         \'label:de\': \'Startzeit festlegen\',\r\n         \'label:pl\': \'Ustaw czas rozpoczęcia\',\r\n         \'label:ua\': \'Встановіть час початку\',\r\n         type: \'number\',\r\n         title: \'sec\',\r\n         placeholder: \'1-30\',\r\n         step: 1,\r\n         min: 0,\r\n         max: 30,\r\n         value: 0,\r\n      },\r\n      skip_into_step_in_music: {\r\n         _tagName: \'input\',\r\n         label: \'Apply for music genre\',\r\n         type: \'checkbox\',\r\n         \'data-dependent\': { \'skip_into_step\': \"!0\" },\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'player-indicator\',\r\n   title: \'Replace HUD (bezel)\',\r\n   \'title:zh\': \'替换默认指示器\',\r\n   \'title:ja\': \'デフォルトのインジケーターを置き換える\',\r\n   \'title:ko\': \'기본 표시기 교체\',\r\n   \'title:id\': \'Ganti HUD (bezel)\',\r\n   \'title:es\': \'Reemplazar indicador predeterminado\',\r\n   \'title:pt\': \'Substituir o indicador padrão\',\r\n   \'title:fr\': \"Remplacer l\'indicateur par défaut\",\r\n   \'title:it\': \'Sostituisci HUD (cornice)\',\r\n   \'title:de\': \'Standardkennzeichen ersetzen\',\r\n   \'title:pl\': \'Zamień wskaźnik standardowy\',\r\n   \'title:ua\': \'Замінити стандартний інтерфейс\',\r\n   run_on_pages: \'watch, embed, -mobile\',\r\n   section: \'player\',\r\n   _runtime: user_settings => {\r\n      const\r\n         SELECTOR_ID = \'nova-player-indicator-info\',\r\n         COLOR_HUD = user_settings.player_indicator_color || \'#ff0000\';\r\n      NOVA.waitSelector(\'#movie_player video\')\r\n         .then(video => {\r\n            video.addEventListener(\'volumechange\', function () {\r\n               HUD.set({\r\n                  \'pt\': Math.round(movie_player.getVolume()),\r\n                  \'suffix\': \'%\',\r\n               });\r\n            });\r\n            video.addEventListener(\'ratechange\', () => HUD.set({\r\n               \'pt\': video.playbackRate,\r\n               \'suffix\': \'x\',\r\n            }));\r\n            if (user_settings.player_indicator_chapter) {\r\n               NOVA.waitSelector(\'ytd-watch-metadata #description.ytd-watch-metadata\')\r\n                  .then(() => {\r\n                     const getNextChapterIndex = () => chapterList?.findIndex(c => c.sec > ~~video.currentTime);\r\n                     let chapterList, lastChapTime = 0;\r\n                     video.addEventListener(\'loadeddata\', () => chapterList = []);\r\n                     video.addEventListener(\'timeupdate\', function () {\r\n                        if (chapterList !== null && !chapterList?.length) {\r\n                           chapterList = NOVA.getChapterList(movie_player.getDuration()) || null;\r\n                        }\r\n                        if (chapterList?.length\r\n                           && this.currentTime > lastChapTime\r\n                        ) {\r\n                           const nextChapterIndex = getNextChapterIndex();\r\n                           lastChapTime = chapterList[nextChapterIndex].sec;\r\n                           if (chapterData = chapterList[nextChapterIndex - 1]) {\r\n                              const separator = \' • \';\r\n                              const msg = chapterData.title + separator + chapterData.time;\r\n                              NOVA.bezelTrigger(msg);\r\n                           }\r\n                        }\r\n                     });\r\n                     video.addEventListener(\'seeking\', function () {\r\n                        if (chapterList?.length && (nexChapterData = chapterList[getNextChapterIndex()])) {\r\n                           lastChapTime = nexChapterData.sec;\r\n                        }\r\n                     });\r\n                  });\r\n               if (user_settings.player_indicator_chapter_default_container_hide\r\n                  && !(user_settings.player_hide_elements.length && user_settings.player_hide_elements.includes(\'chapter_container\'))\r\n               ) {\r\n                  NOVA.css.push(\r\n                     `#movie_player .ytp-chrome-bottom .ytp-chapter-container { display: none !important; }`\r\n                  );\r\n               }\r\n            }\r\n         });\r\n      NOVA.waitSelector(\'.ytp-bezel-text\')\r\n         .then(target => {\r\n            new MutationObserver(mutationRecordsArray => {\r\n               let timeout_ms;\r\n               if (target.textContent) {\r\n                  if (!target.textContent.startsWith(\'+\') && target.textContent.includes(\' • \')) {\r\n                     timeout_ms = 1800;\r\n                  }\r\n                  HUD.set({\r\n                     \'pt\': target.textContent,\r\n                     \'timeout_ms\': timeout_ms,\r\n                  });\r\n               }\r\n            })\r\n               .observe(target, { attributes: true, childList: true });\r\n         });\r\n      const HUD = {\r\n         get() {\r\n            return this.container || this.create();\r\n         },\r\n         create() {\r\n            NOVA.css.push(\r\n               `.ytp-bezel-text-wrapper,\r\n               .ytp-doubletap-ui-legacy.ytp-time-seeking,\r\n               \r\n               .ytp-chapter-seek {\r\n                  display:none !important;\r\n               }`);\r\n            NOVA.css.push(\r\n               `#${SELECTOR_ID} {\r\n                  --color: #fff;\r\n                  --bg-color: rgba(0,0,0,${user_settings.player_indicator_opacity || .3});\r\n                  --zindex: ${1 + Math.max(NOVA.css.getValue(\'.ytp-chrome-top\', \'z-index\'), 60)};\r\n                  position: absolute;\r\n                  right: 0;\r\n                  z-index: calc(var(--zindex) + 1);\r\n                  margin: 0 auto;\r\n                  text-align: center;\r\n                  opacity: 0;\r\n                  background-color: var(--bg-color);\r\n                  color: var(--color);\r\n               }`);\r\n            movie_player.insertAdjacentHTML(\'beforeend\', `<div id=\"${SELECTOR_ID}\"><span></span></div>`);\r\n            this.container = document.getElementById(SELECTOR_ID);\r\n            this.hudSpan = this.container.querySelector(\'span\');\r\n            switch (user_settings.player_indicator_type) {\r\n               case \'bar-center\':\r\n                  Object.assign(this.container.style, {\r\n                     left: 0,\r\n                     bottom: \'20%\',\r\n                     width: \'30%\',\r\n                     \'font-size\': \'1.2em\',\r\n                  });\r\n                  Object.assign(this.hudSpan.style, {\r\n                     \'background-color\': COLOR_HUD,\r\n                     transition: \'width 100ms ease-out 0s\',\r\n                     display: \'inline-block\',\r\n                  });\r\n                  break;\r\n               case \'bar-vertical\':\r\n                  Object.assign(this.container.style, {\r\n                     top: 0,\r\n                     height: \'100%\',\r\n                     width: \'25px\',\r\n                     \'font-size\': \'1.2em\',\r\n                  });\r\n                  Object.assign(this.hudSpan.style, {\r\n                     position: \'absolute\',\r\n                     bottom: 0,\r\n                     right: 0,\r\n                     \'background-color\': COLOR_HUD,\r\n                     transition: \'height 100ms ease-out 0s\',\r\n                     display: \'inline-block\',\r\n                     width: \'100%\',\r\n                     \'font-weight\': \'bold\',\r\n                  });\r\n                  break;\r\n               default:\r\n                  Object.assign(this.container.style, {\r\n                     top: 0,\r\n                     width: \'100%\',\r\n                     padding: \'.2em\',\r\n                     \'font-size\': \'1.55em\',\r\n                  });\r\n            }\r\n            return this.container;\r\n         },\r\n         set({ pt = 100, suffix = \'\', timeout_ms = 800 }) {\r\n            if (typeof this.fateNovaHUD === \'number\') clearTimeout(this.fateNovaHUD);\r\n            let hudContainer = this.get();\r\n            const text = pt + suffix;\r\n            if (suffix == \'x\') {\r\n               const maxPercent = (+user_settings.rate_step % .25) === 0 ? 2 : 3;\r\n               pt = (+pt / maxPercent) * 100;\r\n            }\r\n            pt = Math.round(pt);\r\n            switch (user_settings.player_indicator_type) {\r\n               case \'bar-center\':\r\n                  this.hudSpan.style.width = pt + \'%\';\r\n                  this.hudSpan.textContent = text;\r\n                  break;\r\n               case \'bar-vertical\':\r\n                  this.hudSpan.style.height = pt + \'%\';\r\n                  this.hudSpan.textContent = text;\r\n                  break;\r\n               case \'bar-top\':\r\n                  hudContainer.style.background = `linear-gradient(to right, ${COLOR_HUD}50 ${pt}%, rgba(0,0,0,.8) ${pt}%)`;\r\n                  this.hudSpan.style.width = pt + \'%\';\r\n                  this.hudSpan.textContent = text;\r\n                  break;\r\n               default:\r\n                  this.hudSpan.textContent = text;\r\n            }\r\n            hudContainer.style.transition = \'none\';\r\n            hudContainer.style.opacity = 1;\r\n            this.fateNovaHUD = setTimeout(() => {\r\n               hudContainer.style.transition = \'opacity 200ms ease-in\';\r\n               hudContainer.style.opacity = null;\r\n            }, timeout_ms); //total 1s = 800ms + 200ms(hudContainer.style.transition)\r\n         }\r\n      };\r\n   },\r\n   options: {\r\n      player_indicator_type: {\r\n         _tagName: \'select\',\r\n         label: \'Indicator type\',\r\n         \'label:zh\': \'指标类型\',\r\n         \'label:ja\': \'インジケータータイプ\',\r\n         \'label:ko\': \'표시기 유형\',\r\n         \'label:id\': \'Gösterge tipi\',\r\n         \'label:es\': \'Tipo de indicador\',\r\n         \'label:pt\': \'Tipo de indicador\',\r\n         \'label:fr\': \"Type d\'indicateur\",\r\n         \'label:it\': \'Tipo di indicatore\',\r\n         \'label:de\': \'Indikatortyp\',\r\n         \'label:pl\': \'Typ wskaźnika\',\r\n         \'label:ua\': \'Тип індикатора\',\r\n         options: [\r\n            {\r\n               label: \'text-top\', value: \'text-top\', selected: true,\r\n               \'label:ua\': \'текст зверху\',\r\n            },\r\n            {\r\n               label: \'bar-top\', value: \'bar-top\',\r\n               \'label:ua\': \'панель зверху\',\r\n            },\r\n            {\r\n               label: \'bar-center\', value: \'bar-center\',\r\n               \'label:ua\': \'панель в центрі\',\r\n            },\r\n            {\r\n               label: \'bar-vertical\', value: \'bar-vertical\',\r\n               \'label:ua\': \'вертикальна панель\',\r\n            },\r\n         ],\r\n      },\r\n      player_indicator_color: {\r\n         _tagName: \'input\',\r\n         type: \'color\',\r\n         value: \'#ff0000\',\r\n         label: \'Color\',\r\n         \'label:zh\': \'颜色\',\r\n         \'label:ja\': \'色\',\r\n         \'label:ko\': \'색깔\',\r\n         \'label:id\': \'Warna\',\r\n         \'label:pt\': \'Cor\',\r\n         \'label:fr\': \'Couleur\',\r\n         \'label:it\': \'Colore\',\r\n         \'label:de\': \'Farbe\',\r\n         \'label:pl\': \'Kolor\',\r\n         \'label:ua\': \'Колір\',\r\n         \'data-dependent\': { \'player_indicator_type\': \'!text-top\' },\r\n      },\r\n      player_indicator_chapter: {\r\n         _tagName: \'input\',\r\n         label: \'Show info at start chapter\',\r\n         \'label:zh\': \'在开始章节显示信息\',\r\n         \'label:ja\': \'章の開始時に情報を表示\',\r\n         \'label:ko\': \'시작 장에 정보 표시\',\r\n         \'label:id\': \'Tampilkan info di awal bab\',\r\n         \'label:es\': \'Mostrar información al inicio del capítulo\',\r\n         \'label:pt\': \'Mostrar informações no capítulo inicial\',\r\n         \'label:fr\': \'Afficher les informations au début du chapitre\',\r\n         \'label:it\': \"Mostra informazioni all\'inizio del capitolo\",\r\n         \'label:de\': \'Info beim Startkapitel anzeigen\',\r\n         \'label:pl\': \'Pokaż informacje na początku rozdziału\',\r\n         \'label:ua\': \'Показати інформацію на початку розділу\',\r\n         type: \'checkbox\',\r\n      },\r\n      player_indicator_chapter_default_container_hide: {\r\n         _tagName: \'input\',\r\n         label: \'Hide default block in player control panel\',\r\n         type: \'checkbox\',\r\n         \'data-dependent\': { \'player_indicator_chapter\': true },\r\n      },\r\n      player_indicator_opacity: {\r\n         _tagName: \'input\',\r\n         label: \'Opacity\',\r\n         \'label:zh\': \'不透明度\',\r\n         \'label:ja\': \'不透明度\',\r\n         \'label:ko\': \'불투명\',\r\n         \'label:id\': \'Kegelapan\',\r\n         \'label:es\': \'Opacidad\',\r\n         \'label:pt\': \'Opacidade\',\r\n         \'label:fr\': \'Opacité\',\r\n         \'label:it\': \'Opacità\',\r\n         \'label:tr\': \'opaklık\',\r\n         \'label:de\': \'Opazität\',\r\n         \'label:pl\': \'Przezroczystość\',\r\n         \'label:ua\': \'Прозорість\',\r\n         type: \'number\',\r\n         title: \'less value - more transparency\',\r\n         placeholder: \'0-1\',\r\n         step: .1,\r\n         min: .1,\r\n         max: .9,\r\n         value: .3,\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'theater-mode\',\r\n   title: \'Theater mode\',\r\n   \'title:pl\': \'Tryb kinowy\',\r\n   \'title:ua\': \'Режим кінотеарту\',\r\n   run_on_pages: \'watch, -mobile\',\r\n   section: \'player\',\r\n   _runtime: user_settings => {\r\n      if (user_settings.player_full_viewport_mode == \'redirect_watch_to_embed\') {\r\n         return location.assign(`https://www.youtube.com/embed/` + NOVA.queryURL.get(\'v\'));\r\n      }\r\n      NOVA.waitSelector(\'ytd-watch-flexy\')\r\n         .then(el => {\r\n            if (location.search.includes(\'list=\')) {\r\n               if (user_settings.theater_mode_ignore_playlist == \'all\'\r\n                  || (user_settings.theater_mode_ignore_playlist == \'music\' && NOVA.isMusic())\r\n               ) {\r\n                  el.theaterModeChanged_(false);\r\n                  return;\r\n               }\r\n            }\r\n            el.theaterModeChanged_(true);\r\n         });\r\n      if (user_settings.player_full_viewport_mode == \'\') return;\r\n      if ((user_settings[\'player-fullscreen-mode\'] || user_settings[\'embed-popup\'])\r\n         && !user_settings.player_fullscreen_mode_embed\r\n         && user_settings.player_full_viewport_mode != \'cinema_mode\'\r\n      ) {\r\n         return;\r\n      }\r\n      NOVA.waitSelector(\'#movie_player\')\r\n         .then(movie_player => {\r\n            const\r\n               PLAYER_CONTAINER_SELECTOR = \'ytd-watch-flexy[theater]:not([fullscreen]) #player-theater-container\',\r\n               PINNED_SELECTOR = \'.nova-player-pin\',\r\n               PLAYER_SCROLL_LOCK_CLASS_NAME = \'nova-lock-scroll\',\r\n               PLAYER_SELECTOR = `${PLAYER_CONTAINER_SELECTOR} #movie_player:not(${PINNED_SELECTOR}):not(.${PLAYER_SCROLL_LOCK_CLASS_NAME})`,\r\n               zIindex = Math.max(getComputedStyle(movie_player)[\'z-index\'], 2020);\r\n            addScrollDownBehavior();\r\n            switch (user_settings.player_full_viewport_mode) {\r\n               case \'force\':\r\n                  setPlayerFullViewport(user_settings.player_full_viewport_mode_exit);\r\n               case \'smart\':\r\n                  if (user_settings.player_full_viewport_mode_exclude_shorts && NOVA.currentPage == \'shorts\') {\r\n                     return;\r\n                  }\r\n                  NOVA.waitSelector(\'video\')\r\n                     .then(video => {\r\n                        video.addEventListener(\'loadeddata\', function () {\r\n                           if (user_settings.player_full_viewport_mode_exclude_shorts && this.videoWidth < this.videoHeight) {\r\n                              return;\r\n                           }\r\n                           const miniSize = NOVA.aspectRatio.sizeToFit({\r\n                              \'srcWidth\': this.videoWidth,\r\n                              \'srcHeight\': this.videoHeight,\r\n                           });\r\n                           if (miniSize.width < window.innerWidth) {\r\n                              setPlayerFullViewport(\'player_full_viewport_mode_exit\');\r\n                           }\r\n                        });\r\n                     });\r\n                  break;\r\n               case \'cinema_mode\':\r\n                  NOVA.css.push(\r\n                     PLAYER_CONTAINER_SELECTOR + `{\r\n                        z-index: ${zIindex};\r\n                     }\r\n                     ${PLAYER_SELECTOR}:before {\r\n                        content: \'\';\r\n                        position: fixed;\r\n                        top: 0;\r\n                        left: 0;\r\n                        width: 100%;\r\n                        height: 100%;\r\n                        background-color: rgba(0, 0, 0, ${+user_settings.cinema_mode_opacity});\r\n                        opacity: 0;\r\n                        transition: opacity .4s ease-in-out;\r\n                        pointer-events: none;\r\n                     }\r\n                     \r\n                     ${PLAYER_SELECTOR}.playing-mode:before {\r\n                        opacity: 1;\r\n                     }\r\n                     \r\n                     .ytp-ad-player-overlay,\r\n                     #playlist:hover,\r\n                     #masthead-container:hover,\r\n                     iframe, \r\n                     #guide,\r\n                     [class*=\"popup\"],\r\n                     [role=\"navigation\"],\r\n                     [role=\"dialog\"] {\r\n                        z-index: ${zIindex + 1};\r\n                     }\r\n                     #playlist:hover {\r\n                        position: relative;\r\n                     }\r\n                     \r\n                     body { overflow: hidden; }`);\r\n                  break;\r\n            }\r\n            function setPlayerFullViewport(exclude_pause) {\r\n               const CLASS_OVER_PAUSED = \'nova-player-fullviewport\';\r\n               NOVA.css.push(\r\n                  `${PLAYER_SELECTOR}.playing-mode\r\n                  ${exclude_pause ? \'\' : `, ${PLAYER_SELECTOR}.paused-mode`}\r\n                  , ${PLAYER_SELECTOR}.${CLASS_OVER_PAUSED} {\r\n                     width: 100vw;\r\n                     height: 100vh;\r\n                     position: fixed;\r\n                     bottom: 0 !important;\r\n                     z-index: ${zIindex};\r\n                     background-color: black;\r\n                  }\r\n                  \r\n                  body { overflow: hidden; }`);\r\n               if (user_settings.player_full_viewport_mode_exit) {\r\n                  NOVA.waitSelector(\'video\')\r\n                     .then(video => {\r\n                        video.addEventListener(\'pause\', () => {\r\n                           if (!document.body.querySelector(\'.ytp-progress-bar\')?.contains(document.activeElement)) {\r\n                              window.dispatchEvent(new Event(\'resize\'));\r\n                           }\r\n                        });\r\n                     });\r\n                  NOVA.waitSelector(\'.ytp-progress-bar\')\r\n                     .then(progress_bar => {\r\n                        [\'mousedown\', \'mouseup\'].forEach(evt => {\r\n                           progress_bar.addEventListener(evt, () => {\r\n                              movie_player.classList.add(CLASS_OVER_PAUSED);\r\n                           });\r\n                        });\r\n                     });\r\n               }\r\n            }\r\n            function addScrollDownBehavior() {\r\n               if (activateScrollElement = document.body.querySelector(\'.ytp-chrome-controls\')) {\r\n                  activateScrollElement.addEventListener(\'wheel\', evt => {\r\n                     switch (Math.sign(evt.wheelDelta)) {\r\n                        case -1:\r\n                           movie_player.classList.add(PLAYER_SCROLL_LOCK_CLASS_NAME);\r\n                           break;\r\n                     }\r\n                  });\r\n                  document.addEventListener(\'scroll\', evt => {\r\n                     if (window.scrollY === 0\r\n                        && movie_player.classList.contains(PLAYER_SCROLL_LOCK_CLASS_NAME)\r\n                     ) {\r\n                        movie_player.classList.remove(PLAYER_SCROLL_LOCK_CLASS_NAME);\r\n                     }\r\n                  });\r\n               }\r\n            }\r\n         });\r\n   },\r\n   options: {\r\n      player_full_viewport_mode: {\r\n         _tagName: \'select\',\r\n         label: \'Mode\',\r\n         \'label:zh\': \'模式\',\r\n         \'label:ja\': \'モード\',\r\n         \'label:ko\': \'방법\',\r\n         \'label:es\': \'Modo\',\r\n         \'label:pt\': \'Modo\',\r\n         \'label:it\': \'Modalità\',\r\n         \'label:de\': \'Modus\',\r\n         \'label:pl\': \'Tryb\',\r\n         \'label:ua\': \'Режим\',\r\n         options: [\r\n            {\r\n               label: \'default\', selected: true,\r\n               \'label:ua\': \'за замовчуванням\',\r\n            },\r\n            {\r\n               label: \'cinema\', value: \'cinema_mode\',\r\n               \'label:ua\': \'кінотеатр\',\r\n            },\r\n            {\r\n               label: \'full-viewport (auto)\', value: \'smart\',\r\n               \'label:ua\': \'повноекранний (авто)\',\r\n            },\r\n            {\r\n               label: \'full-viewport\', value: \'force\',\r\n               \'label:ua\': \'повноекранний\',\r\n            },\r\n            {\r\n               label: \'redirect to embedded\', value: \'redirect_watch_to_embed\',\r\n               \'label:ua\': \'передавати на вбудований\',\r\n            },\r\n         ],\r\n      },\r\n      player_full_viewport_mode_exit: {\r\n         _tagName: \'input\',\r\n         label: \'Full-viewport exit if video ends/pause\',\r\n         \'label:zh\': \'视频结束/暂停时退出\',\r\n         \'label:ja\': \'ビデオが終了/一時停止したら終了します\',\r\n         \'label:ko\': \'동영상이 종료/일시 중지되면 종료\',\r\n         \'label:id\': \'Keluar dari viewport penuh jika video berakhir/jeda\',\r\n         \'label:es\': \'Salir si el video termina/pausa\',\r\n         \'label:pt\': \'Sair se o vídeo terminar/pausar\',\r\n         \'label:fr\': \'Quitter si la vidéo se termine/pause\',\r\n         \'label:it\': \'Uscita dalla visualizzazione completa se il video termina/mette in pausa\',\r\n         \'label:de\': \'Beenden, wenn das Video endet/pausiert\',\r\n         \'label:pl\': \'Wyjdź, gdy film się kończy/pauzuje\',\r\n         \'label:ua\': \'Вихід із повного вікна перегляду, якщо відео закінчується/призупиняється\',\r\n         type: \'checkbox\',\r\n         \'data-dependent\': { \'player_full_viewport_mode\': [\'force\', \'smart\'] },\r\n      },\r\n      player_full_viewport_mode_exclude_shorts: {\r\n         _tagName: \'input\',\r\n         label: \'Full-viewport exclude shorts\',\r\n         \'label:zh\': \'全视口不包括短裤\',\r\n         \'label:ja\': \'フルビューポートはショートパンツを除外します\',\r\n         \'label:ko\': \'전체 뷰포트 제외 반바지\',\r\n         \'label:id\': \'Area pandang penuh tidak termasuk celana pendek\',\r\n         \'label:es\': \'Vista completa excluir pantalones cortos\',\r\n         \'label:pt\': \'Shorts de exclusão da janela de visualização completa\',\r\n         \'label:fr\': \'La fenêtre complète exclut les shorts\',\r\n         \'label:it\': \'La visualizzazione completa esclude i cortometraggi\',\r\n         \'label:de\': \'Vollbildansicht schließt Shorts aus\',\r\n         \'label:pl\': \'Pełny ekran wyklucza krótkie filmy\',\r\n         \'label:ua\': \'Повне вікно перегляду без прев`ю\',\r\n         type: \'checkbox\',\r\n         \'data-dependent\': { \'player_full_viewport_mode\': \'smart\' },\r\n      },\r\n      cinema_mode_opacity: {\r\n         _tagName: \'input\',\r\n         label: \'Opacity\',\r\n         \'label:zh\': \'不透明度\',\r\n         \'label:ja\': \'不透明度\',\r\n         \'label:ko\': \'불투명\',\r\n         \'label:id\': \'Kegelapan\',\r\n         \'label:es\': \'Opacidad\',\r\n         \'label:pt\': \'Opacidade\',\r\n         \'label:fr\': \'Opacité\',\r\n         \'label:it\': \'Opacità\',\r\n         \'label:de\': \'Opazität\',\r\n         \'label:pl\': \'Przezroczystość\',\r\n         \'label:ua\': \'Прозорість\',\r\n         type: \'number\',\r\n         title: \'0-1\',\r\n         placeholder: \'0-1\',\r\n         step: .05,\r\n         min: 0,\r\n         max: 1,\r\n         value: .75,\r\n         \'data-dependent\': { \'player_full_viewport_mode\': \'cinema_mode\' },\r\n      },\r\n      theater_mode_ignore_playlist: {\r\n         _tagName: \'select\',\r\n         label: \'Ignore playlist\',\r\n         options: [\r\n            {\r\n               label: \'false\', selected: true,\r\n            },\r\n            {\r\n               label: \'all\', value: \'all\',\r\n            },\r\n            {\r\n               label: \'only music\', value: \'music\',\r\n            },\r\n         ],\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'page-title-time\',\r\n   title: \'Show time in tab title\',\r\n   \'title:zh\': \'在标签标题中显示时间\',\r\n   \'title:ja\': \'タブタイトルに時間を表示する\',\r\n   \'title:ko\': \'탭 제목에 시간 표시\',\r\n   \'title:id\': \'Tampilkan waktu di judul tab\',\r\n   \'title:es\': \'Mostrar la hora en el título de la pestaña\',\r\n   \'title:pt\': \'Mostrar tempo no título da guia\',\r\n   \'title:fr\': \"Afficher l\'heure dans le titre de l\'onglet\",\r\n   \'title:it\': \"Mostra l\'ora nel titolo della scheda\",\r\n   \'title:de\': \'Zeit im Tab-Titel anzeigen\',\r\n   \'title:pl\': \'Pokaż czas w tytule karty\',\r\n   \'title:ua\': \'Відображення часу в заголовку вкладки\',\r\n   run_on_pages: \'watch\',\r\n   section: \'player\',\r\n   _runtime: user_settings => {\r\n      NOVA.waitSelector(\'video\')\r\n         .then(video => {\r\n            document.addEventListener(\'yt-navigate-start\', () => pageTitle.backup = null);\r\n            video.addEventListener(\'playing\', pageTitle.save.bind(pageTitle));\r\n            video.addEventListener(\'timeupdate\', () => pageTitle.update(video));\r\n            video.addEventListener(\'pause\', () => pageTitle.restore(video));\r\n            video.addEventListener(\'ended\', () => pageTitle.restore(video));\r\n         });\r\n      const pageTitle = {\r\n         strSplit: \' | \',\r\n         saveCheck() {\r\n            return (result = (this.backup || document.title).includes(this.strSplit))\r\n               ? new RegExp(`^((\\\\d?\\\\d:){1,2}\\\\d{2})(${this.strSplit.replace(\'|\', \'\\\\|\')})`, \'\')\r\n                  .test(document.title)\r\n               : result;\r\n         },\r\n         save() {\r\n            if (this.backup\r\n               || movie_player.getVideoData().isLive\r\n               || movie_player.classList.contains(\'ad-showing\')\r\n               || this.saveCheck()\r\n            ) {\r\n               return;\r\n            }\r\n            this.backup = movie_player.getVideoData().title;\r\n         },\r\n         update(video = NOVA.videoElement) {\r\n            if (!this.backup) return;\r\n            let newTitleArr = [];\r\n            switch (movie_player.getVideoData().isLive ? \'current\' : user_settings.page_title_time_mode) {\r\n               case \'current\':\r\n                  newTitleArr = [video.currentTime];\r\n                  break;\r\n               case \'current-duration\':\r\n                  if (!isNaN(video.duration)) {\r\n                     newTitleArr = [video.currentTime, \' / \', video.duration];\r\n                  }\r\n                  break;\r\n               default:\r\n                  if (!isNaN(video.duration)) {\r\n                     newTitleArr = [video.duration - video.currentTime];\r\n                  }\r\n            }\r\n            newTitleArr = newTitleArr\r\n               .map(t => (typeof t === \'string\') ? t : NOVA.timeFormatTo.HMS.digit(t / video.playbackRate))\r\n               .join(\'\');\r\n            this.set([newTitleArr, this.backup]);\r\n         },\r\n         restore(video = NOVA.videoElement) {\r\n            if (!this.backup) return;\r\n            this.set([movie_player.getVideoData().isLive && video.currentTime, this.backup]);\r\n         },\r\n         set(arr) {\r\n            document.title = arr\r\n               .filter(Boolean)\r\n               .join(this.strSplit);\r\n         },\r\n      };\r\n   },\r\n   options: {\r\n      page_title_time_mode: {\r\n         _tagName: \'select\',\r\n         label: \'Mode\',\r\n         \'label:zh\': \'模式\',\r\n         \'label:ja\': \'モード\',\r\n         \'label:ko\': \'방법\',\r\n         \'label:es\': \'Modo\',\r\n         \'label:pt\': \'Modo\',\r\n         \'label:it\': \'Modalità\',\r\n         \'label:de\': \'Modus\',\r\n         \'label:pl\': \'Tryb\',\r\n         \'label:ua\': \'Режим\',\r\n         options: [\r\n            {\r\n               label: \'left\', value: \'left\', selected: true,\r\n               \'label:zh\': \'剩下\',\r\n               \'label:ja\': \'左\',\r\n               \'label:ko\': \'왼쪽\',\r\n               \'label:id\': \'tetap\',\r\n               \'label:es\': \'izquierda\',\r\n               \'label:pt\': \'deixou\',\r\n               \'label:fr\': \'à gauche\',\r\n               \'label:it\': \'è rimasta\',\r\n               \'label:de\': \'links\',\r\n               \'label:pl\': \'pozostało\',\r\n               \'label:ua\': \'лишилось\',\r\n            },\r\n            {\r\n               label: \'current/duration\', value: \'current-duration\',\r\n               \'label:zh\': \'现在/期间\',\r\n               \'label:ja\': \'現在/期間\',\r\n               \'label:ko\': \'현재/기간\',\r\n               \'label:id\': \'saat ini/durasi\',\r\n               \'label:es\': \'actual/duración\',\r\n               \'label:pt\': \'atual/duração\',\r\n               \'label:fr\': \'courant/durée\',\r\n               \'label:it\': \'corrente/durata\',\r\n               \'label:de\': \'strom/dauer\',\r\n               \'label:pl\': \'bieżący czas\',\r\n               \'label:ua\': \'поточний/тривалість\',\r\n            },\r\n         ],\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'player-progress-bar-color\',\r\n   title: \'Player progress bar color\',\r\n   \'title:ua\': \'Колір індикатора прогресу програвача\',\r\n   run_on_pages: \'watch, embed, -mobile\',\r\n   section: \'player\',\r\n   _runtime: user_settings => {\r\n      NOVA.css.push(\r\n         `.ytp-swatch-background-color {\r\n            background-color: ${user_settings.player_progress_bar_color || \'#f00\'} !important;\r\n         }`);\r\n   },\r\n   options: {\r\n      player_progress_bar_color: {\r\n         _tagName: \'input\',\r\n         type: \'color\',\r\n         value: \'#0089ff\',\r\n         label: \'Color\',\r\n         \'label:zh\': \'颜色\',\r\n         \'label:ja\': \'色\',\r\n         \'label:ko\': \'색깔\',\r\n         \'label:id\': \'Warna\',\r\n         \'label:pt\': \'Cor\',\r\n         \'label:fr\': \'Couleur\',\r\n         \'label:it\': \'Colore\',\r\n         \'label:de\': \'Farbe\',\r\n         \'label:pl\': \'Kolor\',\r\n         \'label:ua\': \'Колір\',\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'embed-popup\',\r\n   title: \'Redirect embedded to popup\',\r\n   \'title:zh\': \'将嵌入式视频重定向到弹出窗口\',\r\n   \'title:ja\': \'埋め込まれたビデオをポップアップにリダイレクトします\',\r\n   \'title:ko\': \'포함된 비디오를 팝업으로 리디렉션\',\r\n   \'title:id\': \'포함된 비디오를 팝업으로 리디렉션\',\r\n   \'title:es\': \'Redirigir video incrustado a ventana emergente\',\r\n   \'title:pt\': \'Redirecionar vídeo incorporado para pop-up\',\r\n   \'title:fr\': \'Rediriger la vidéo intégrée vers une fenêtre contextuelle\',\r\n   \'title:it\': \'Reindirizza il video incorporato al popup\',\r\n   \'title:de\': \'Leiten Sie eingebettete Videos zum Popup um\',\r\n   \'title:pl\': \'Przekieruj osadzone wideo do wyskakującego okienka\',\r\n   \'title:ua\': \'Переспрямувати вбудоване відео у спливаюче вікно\',\r\n   run_on_pages: \'embed, -mobile\',\r\n   section: \'player\',\r\n   _runtime: user_settings => {\r\n      if (window.top === window.self) return;\r\n      if (NOVA.queryURL.has(\'popup\')) return;\r\n      if (user_settings.player_full_viewport_mode == \'redirect_watch_to_embed\') return;\r\n      NOVA.waitSelector(\'#movie_player video\')\r\n         .then(video => {\r\n            video.addEventListener(\'loadeddata\', createPopup.bind(video));\r\n         });\r\n      function createPopup() {\r\n         movie_player.stopVideo();\r\n         const { width, height } = NOVA.aspectRatio.sizeToFit({\r\n            \'srcWidth\': this.videoWidth,\r\n            \'srcHeight\': this.videoHeight,\r\n            \'maxWidth\': screen.width / (+user_settings.player_buttons_custom_popup_width || 4),\r\n         });\r\n         const url = new URL(\r\n            document.querySelector(\'link[itemprop=\"embedUrl\"][href]\')?.href\r\n            || (location.origin + \'/embed/\' + movie_player.getVideoData().video_id)\r\n         );\r\n         url.searchParams.set(\'autoplay\', 1);\r\n         url.searchParams.set(\'popup\', true);\r\n         openPopup({ \'url\': url.href, \'title\': document.title, \'width\': width, \'height\': height });\r\n         function openPopup({ url, title, width, height }) {\r\n            const left = (screen.width / 2) - (width / 2);\r\n            const top = (screen.height / 2) - (height / 2);\r\n            const newWindow = window.open(url, \'_blank\', `popup=1,toolbar=no,location=no,directories=no,status=no,menubar=no,scrollbars=no,resizable=yes,copyhistory=no,width=${width},height=${height},top=${top},left=${left}`);\r\n            newWindow.document.title = title;\r\n         }\r\n      }\r\n   },\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'sponsor-block\',\r\n   title: \'SponsorBlock\',\r\n   run_on_pages: \'watch, embed\',\r\n   section: \'player\',\r\n   _runtime: user_settings => {\r\n      NOVA.waitSelector(\'#movie_player video\')\r\n         .then(video => {\r\n            let segmentsList = [];\r\n            let muteState;\r\n            video.addEventListener(\'loadeddata\', init.bind(video));\r\n            async function init() {\r\n               const videoId = movie_player.getVideoData().video_id || NOVA.queryURL.get(\'v\');\r\n               segmentsList = await getSkipSegments(videoId) || [];\r\n               if (user_settings[\'player-float-progress-bar\'] && segmentsList.length) {\r\n                  const SELECTOR = \'nova-player-float-progress-bar-chapters\';\r\n                  let el;\r\n                  await NOVA.waitUntil(() =>\r\n                     (el = document.body.querySelectorAll(`#${SELECTOR} > span[time]`)) && el.length\r\n                     , 1000);\r\n                  el.forEach(chapterEl => {\r\n                     const sec = NOVA.timeFormatTo.hmsToSec(chapterEl.getAttribute(\'time\'));\r\n                     for (const [i, value] of segmentsList.entries()) {\r\n                        const [start, end, category] = value;\r\n                        if (sec >= (~~start - 5) && sec <= (Math.ceil(end) + 5)) {\r\n                           chapterEl.style.title = category;\r\n                           let color;\r\n                           switch (category) {\r\n                              case \'sponsor\': color = \'rgb(255,231,0,.3)\'; break;\r\n                              case \'interaction\': color = \'rgb(255,127,80,.3)\'; break;\r\n                              case \'selfpromo\': color = \'rgb(255,99,71,.3)\'; break;\r\n                              case \'intro\': color = \'rgb(255,165,0,.3)\'; break;\r\n                              case \'outro\': color = \'rgb(255,165,0,.3)\'; break;\r\n                           }\r\n                           chapterEl.style.background = color;\r\n                        }\r\n                     }\r\n                  });\r\n               }\r\n            }\r\n            video.addEventListener(\'timeupdate\', function () {\r\n               let start, end, category;\r\n               for (let i = 0; i < segmentsList.length; i++) {\r\n                  [start, end, category] = segmentsList[i];\r\n                  start = ~~start;\r\n                  end = Math.ceil(end);\r\n                  const inSegment = (this.currentTime > start && this.currentTime < end);\r\n                  switch (user_settings.sponsor_block_action) {\r\n                     case \'mute\':\r\n                        if (inSegment && !muteState && !this.muted) {\r\n                           muteState = true;\r\n                           movie_player.mute(true);\r\n                           return novaNotification(\'muted\');\r\n                        }\r\n                        else if (!inSegment && muteState && this.muted) {\r\n                           muteState = false;\r\n                           movie_player.unMute();\r\n                           segmentsList.splice(i, 1);\r\n                           return novaNotification(\'unMuted\');\r\n                        }\r\n                        break;\r\n                     case \'skip\':\r\n                        if (inSegment) {\r\n                           this.currentTime = end;\r\n                           segmentsList.splice(i, 1);\r\n                           return novaNotification(\'skipped\');\r\n                        }\r\n                        break;\r\n                  }\r\n               }\r\n               function novaNotification(prefix = \'\') {\r\n                  const msg = `${prefix} [${category}] • ${NOVA.timeFormatTo.HMS.digit(start)} - ${NOVA.timeFormatTo.HMS.digit(end)}`;\r\n                  console.info(msg);\r\n                  NOVA.bezelTrigger(msg);\r\n               }\r\n            });\r\n         });\r\n      async function getSkipSegments(videoId = required()) {\r\n         const CACHE_PREFIX = \'nova-videos-sponsor-block:\';\r\n         if (storage = sessionStorage.getItem(CACHE_PREFIX + videoId)) {\r\n            return JSON.parse(storage);\r\n         }\r\n         else {\r\n            const\r\n               actionTypes = (Array.isArray(user_settings.sponsor_block_action)\r\n                  ? user_settings.sponsor_block_action : [user_settings.sponsor_block_action])\r\n                  || [\'skip\', \'mute\'],\r\n               categories = user_settings.sponsor_block_category || [\r\n                  \'sponsor\',\r\n                  \'interaction\',\r\n                  \'selfpromo\',\r\n                  \'intro\',\r\n                  \'outro\',\r\n               ],\r\n               params = {\r\n                  \'videoID\': videoId,\r\n                  \'actionTypes\': JSON.stringify(actionTypes),\r\n                  \'categories\': JSON.stringify(categories),\r\n               },\r\n               query = Object.keys(params)\r\n                  .map(k => encodeURIComponent(k) + \'=\' + encodeURIComponent(params[k]))\r\n                  .join(\'&\');\r\n            const fetchAPI = () => fetch((user_settings.sponsor_block_url || \'https://sponsor.ajay.app\')\r\n               + `/api/skipSegments?${query}`,\r\n               {\r\n                  method: \'GET\',\r\n                  headers: { \'Content-Type\': \'application/json\' }\r\n               }\r\n            )\r\n               .then(response => response.json())\r\n               .then(json => json\r\n                  .map(a => [...a.segment, a.category])\r\n               )\r\n               .catch(error => {\r\n               });\r\n            if (result = await fetchAPI()) {\r\n               sessionStorage.setItem(CACHE_PREFIX + videoId, JSON.stringify(result));\r\n               return result;\r\n            }\r\n         }\r\n      }\r\n   },\r\n   options: {\r\n      sponsor_block_category: {\r\n         _tagName: \'select\',\r\n         label: \'Category\',\r\n         title: \'[Ctrl+Click] to select several\',\r\n         \'title:zh\': \'[Ctrl+Click] 选择多个\',\r\n         \'title:ja\': \'「Ctrl+Click」して、いくつかを選択します\',\r\n         \'title:ko\': \'[Ctrl+Click] 여러 선택\',\r\n         \'title:id\': \'[Ctrl+Klik] untuk memilih beberapa\',\r\n         \'title:es\': \'[Ctrl+Click] para seleccionar varias\',\r\n         \'title:pt\': \'[Ctrl+Click] para selecionar vários\',\r\n         \'title:fr\': \'[Ctrl+Click] pour sélectionner plusieurs\',\r\n         \'title:it\': \'[Ctrl+Clic] per selezionarne diversi\',\r\n         \'title:de\': \'[Ctrl+Click] um mehrere auszuwählen\',\r\n         \'title:pl\': \'Ctrl+kliknięcie, aby zaznaczyć kilka\',\r\n         \'title:ua\': \'[Ctrl+Click] щоб обрати декілька\',\r\n         multiple: null,\r\n         required: true,\r\n         size: 7,\r\n         options: [\r\n            {\r\n               label: \'Sponsor\', value: \'sponsor\',\r\n            },\r\n            {\r\n               label: \'Unpaid/Self Promotion\', value: \'selfpromo\',\r\n            },\r\n            {\r\n               label: \'Reminder Subscribe\', value: \'interaction\',\r\n            },\r\n            {\r\n               label: \'Intro\', value: \'intro\',\r\n            },\r\n            {\r\n               label: \'Endcards/Credits (Outro)\', value: \'outro\',\r\n            },\r\n            {\r\n               label: \'Preview/Recap\', value: \'preview\',\r\n            },\r\n            {\r\n               label: \'Music: Non-Music Section\', value: \'music_offtopic\',\r\n            },\r\n            {\r\n               label: \'Full Video Label Only\', value: \'exclusive_access\',\r\n            },\r\n         ],\r\n      },\r\n      sponsor_block_action: {\r\n         _tagName: \'select\',\r\n         label: \'Mode\',\r\n         \'label:zh\': \'模式\',\r\n         \'label:ja\': \'モード\',\r\n         \'label:ko\': \'방법\',\r\n         \'label:es\': \'Modo\',\r\n         \'label:pt\': \'Modo\',\r\n         \'label:it\': \'Modalità\',\r\n         \'label:de\': \'Modus\',\r\n         \'label:pl\': \'Tryb\',\r\n         \'label:ua\': \'Режим\',\r\n         options: [\r\n            {\r\n               label: \'skip\', value: \'skip\', selected: true,\r\n            },\r\n            {\r\n               label: \'mute\', value: \'mute\',\r\n            },\r\n         ],\r\n      },\r\n      sponsor_block_url: {\r\n         _tagName: \'input\',\r\n         label: \'URL\',\r\n         type: \'url\',\r\n         pattern: \"https://.*\",\r\n         placeholder: \'https://youtube.com/...\',\r\n         value: \'https://sponsor.ajay.app\',\r\n         required: true,\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'player-live-duration\',\r\n   title: \'Show duration on live\',\r\n   \'title:ua\': \'Показувати тривалість трансляції\',\r\n   run_on_pages: \'watch, embed, -mobile\',\r\n   section: \'player\',\r\n   _runtime: user_settings => {\r\n      NOVA.waitSelector(\'#movie_player video\')\r\n         .then(video => {\r\n            video.addEventListener(\'canplay\', function () {\r\n               if (movie_player.getVideoData().isLive\r\n                  && (el = document.body.querySelector(\'#movie_player .ytp-chrome-controls .ytp-live .ytp-time-current\'))\r\n               ) {\r\n                  el.style = \'display: block !important; margin-right: 5px;\';\r\n               }\r\n            });\r\n            NOVA.css.push(\r\n               `#movie_player .ytp-chrome-controls .ytp-time-display.ytp-live {\r\n                  display: flex !important;\r\n               }`);\r\n         });\r\n   },\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'player-disable-fullscreen-scroll\',\r\n   title: \'Disable scrolling in Full Screen player\',\r\n   \'title:zh\': \'禁用全屏滚动\',\r\n   \'title:ja\': \'フルスクリーンスクロールを無効にする\',\r\n   \'title:ko\': \'전체 화면 스크롤 비활성화\',\r\n   \'title:id\': \'Nonaktifkan pengguliran pemain dalam mode layar penuh\',\r\n   \'title:es\': \'Desactivar el desplazamiento a pantalla completa\',\r\n   \'title:pt\': \'Desabilitar rolagem em tela cheia\',\r\n   \'title:fr\': \'Désactiver le défilement plein écran\',\r\n   \'title:it\': \'Disabilita lo scorrimento del lettore in modalità a schermo intero\',\r\n   \'title:de\': \'Deaktivieren Sie das Scrollen im Vollbildmodus\',\r\n   \'title:pl\': \'Wyłącz przewijanie w trybie pełnoekranowym\',\r\n   \'title:ua\': \'Вимкнути прокрутку у повноекранному режимі\',\r\n   run_on_pages: \'watch\',\r\n   section: \'player\',\r\n   _runtime: user_settings => {\r\n      NOVA.css.push(`.ytp-fullerscreen-edu-button { display: none !important; }`);\r\n      document.addEventListener(\'fullscreenchange\', () => {\r\n         document.fullscreenElement\r\n            ? document.addEventListener(\'wheel\', lockscroll, { passive: false })\r\n            : document.removeEventListener(\'wheel\', lockscroll)\r\n      }\r\n      );\r\n      function lockscroll(evt) {\r\n         evt.preventDefault();\r\n      }\r\n   },\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'player-control-autohide\',\r\n   title: \'Hide player control panel if not hovered\',\r\n   \'title:zh\': \'播放器上的自动隐藏控件\',\r\n   \'title:ja\': \'プレーヤーのコントロールを自動非表示\',\r\n   \'title:ko\': \'플레이어의 자동 숨기기 컨트롤\',\r\n   \'title:id\': \'Sembunyikan kontrol pada pemutar\',\r\n   \'title:es\': \'Ocultar automáticamente los controles en el reproductor\',\r\n   \'title:pt\': \'Auto-ocultar controles no player\',\r\n   \'title:fr\': \'Masque le panneau de contrôle du lecteur\',\r\n   \'title:it\': \'Nascondi i controlli sul giocatore\',\r\n   \'title:de\': \'Blendet das Player-Bedienfeld aus\',\r\n   \'title:pl\': \'Ukrywaj elementy w odtwarzaczu\',\r\n   \'title:ua\': \'Приховати панель керування у відтворювачі\',\r\n   run_on_pages: \'watch, -mobile\',\r\n   section: \'player\',\r\n   desc: \'Hover controls to display it\',\r\n   \'desc:zh\': \'将鼠标悬停在它上面以显示它\',\r\n   \'desc:ja\': \'カーソルを合わせると表示されます\',\r\n   \'desc:ko\': \'그것을 표시하려면 그 위로 마우스를 가져갑니다\',\r\n   \'desc:id\': \'Arahkan kontrol untuk menampilkannya\',\r\n   \'desc:es\': \'Coloca el cursor sobre él para mostrarlo\',\r\n   \'desc:pt\': \'Passe o mouse sobre ele para exibi-lo\',\r\n   \'desc:fr\': \"Survolez-le pour l\'afficher\",\r\n   \'desc:it\': \'Passa il mouse sui controlli per visualizzarlo\',\r\n   \'desc:de\': \'Bewegen Sie den Mauszeiger darüber, um es anzuzeigen\',\r\n   \'desc:pl\': \'Najedź, aby wyświetlić\',\r\n   \'desc:ua\': \'Наведіть мишкою щоб показати\',\r\n   _runtime: user_settings => {\r\n      if (user_settings[\'player-control-below\']) return;\r\n      let selectorHover, selectorGradientHide;\r\n      switch (user_settings.player_control_autohide_container) {\r\n         case \'player\':\r\n            selectorHover = \'ytd-watch-flexy:not([fullscreen]) #movie_player:hover .ytp-chrome-bottom\';\r\n            selectorGradientHide = \'#movie_player:not(:hover) .ytp-gradient-bottom\';\r\n            elementOnHoverChangeState({\r\n               \'element\': movie_player,\r\n               \'callback\': function (hovered) {\r\n                  if (hovered) this.mouseMoveIntervalId = fixControlFreeze();\r\n                  else clearInterval(this.mouseMoveIntervalId);\r\n               },\r\n            });\r\n            break;\r\n         default:\r\n            selectorHover = \'.ytp-chrome-bottom:hover\';\r\n            selectorGradientHide = \'#movie_player:has(.ytp-chrome-bottom:not(:hover)) .ytp-gradient-bottom\';\r\n            break;\r\n      }\r\n      NOVA.css.push(\r\n         `.ytp-chrome-bottom {\r\n            opacity: 0;\r\n         }\r\n         ${selectorHover} {\r\n            opacity: 1;\r\n         }\r\n         \r\n         ytd-watch-flexy:not([fullscreen]) #movie_player.ytp-autohide:hover #nova-player-float-progress-bar {\r\n            visibility: hidden !important;\r\n         }`);\r\n      NOVA.css.push(\r\n         `${selectorGradientHide} {\r\n            opacity: 0;\r\n         }`);\r\n      function elementOnHoverChangeState({ element = required(), callback = required() }) {\r\n         if (!(element instanceof HTMLElement)) return console.error(\'elementOnHoverChangeState:\', typeof element);\r\n         if (typeof callback !== \'function\') return console.error(\'elementOnHoverChangeState:\', typeof callback);\r\n         const isHover = e => e.parentElement.querySelector(\':hover\') === e;\r\n         document.addEventListener(\'mousemove\', function checkHover() {\r\n            const hovered = isHover(movie_player);\r\n            if (hovered !== checkHover.hovered) {\r\n               checkHover.hovered = hovered;\r\n               return callback(hovered);\r\n            }\r\n         });\r\n      }\r\n      function fixControlFreeze(ms = 2000) {\r\n         const moveMouse = new Event(\'mousemove\');\r\n         return window.setInterval(() => {\r\n            if (NOVA.currentPage === \'watch\'\r\n               && document.visibilityState == \'visible\'\r\n               && movie_player.classList.contains(\'playing-mode\')\r\n               && !NOVA.isFullscreen()\r\n            ) {\r\n               movie_player.dispatchEvent(moveMouse);\r\n            }\r\n         }, ms);\r\n      }\r\n   },\r\n   options: {\r\n      player_control_autohide_container: {\r\n         _tagName: \'select\',\r\n         label: \'Hover container\',\r\n         \'label:ua\': \'Відображати вміст при наведенні\',\r\n         options: [\r\n            {\r\n               label: \'player\', value: \'player\', selected: true,\r\n               \'label:ua\': \'програвач\',\r\n            },\r\n            {\r\n               label: \'control\', value: \'control\',\r\n               \'label:ua\': \'панель керування\',\r\n            },\r\n         ],\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'player-fullscreen-mode\',\r\n   title: \'Auto fullscreen on playback\',\r\n   \'title:zh\': \'播放时自动全屏\',\r\n   \'title:ja\': \'再生時に全画面表示\',\r\n   \'title:ko\': \'재생 시 자동 전체 화면\',\r\n   \'title:id\': \'Layar penuh otomatis saat diputar\',\r\n   \'title:es\': \'Pantalla completa automática en reproducción\',\r\n   \'title:pt\': \'Tela cheia automática na reprodução\',\r\n   \'title:fr\': \'Plein écran automatique lors de la lecture\',\r\n   \'title:it\': \'Schermo intero automatico durante la riproduzione\',\r\n   \'title:de\': \'Automatischer Vollbildmodus bei Wiedergabe\',\r\n   \'title:pl\': \'Pełny ekran podczas odtwarzania\',\r\n   \'title:ua\': \'Автоматичне ввімкнення повного екрану при відтворенні\',\r\n   run_on_pages: \'watch, embed\',\r\n   section: \'player\',\r\n   _runtime: user_settings => {\r\n      if (NOVA.currentPage == \'embed\' && (window.self === window.top)) return;\r\n      if (user_settings.player_fullscreen_mode_embed && NOVA.currentPage != \'embed\') return;\r\n      NOVA.css.push(\r\n         `.ytp-popup:has(a[href=\"https://support.google.com/youtube/answer/6276924\"]),\r\n         #ytd-player .html5-video-player.ytp-fullscreen.playing-mode > .ytp-popup.ytp-generic-popup[role=\"alert\"][style] {\r\n            visibility: hidden !important;\r\n         }`);\r\n      NOVA.waitSelector(\'video\')\r\n         .then(video => {\r\n            video.addEventListener(\'play\', setFullscreen.bind(video), { capture: true, once: true });\r\n            video.addEventListener(\'loaddata\', setFullscreen.bind(video));\r\n            video.addEventListener(\'ended\', exitFullscreen);\r\n            if (user_settings.player_fullscreen_mode_onpause) {\r\n               video.addEventListener(\'pause\', () => {\r\n                  if (!document.body.querySelector(\'.ytp-progress-bar\')?.contains(document.activeElement)) {\r\n                     exitFullscreen();\r\n                  }\r\n               });\r\n               video.addEventListener(\'play\', setFullscreen.bind(video));\r\n            }\r\n         });\r\n      function setFullscreen() {\r\n         if (movie_player.classList.contains(\'ad-showing\')) return;\r\n         if (user_settings.player_fullscreen_mode_ignore_music && NOVA.isMusic()) return;\r\n         if (user_settings.player_fullscreen_mode_ignore_playlist && (location.search.includes(\'list=\')\r\n         )) return;\r\n         if (!document.fullscreenElement) {\r\n            movie_player.requestFullscreen()\r\n               .catch(error => console.warn(\'Fullscreen not allowed\', error));\r\n         }\r\n      }\r\n      function exitFullscreen() {\r\n         document.fullscreenElement && document?.exitFullscreen();\r\n      }\r\n      if (NOVA.currentPage == \'embed\') {\r\n         NOVA.waitSelector(\'#movie_player .ytp-chrome-bottom .ytp-fullscreen-button[aria-disabled=\"true\"]\')\r\n            .then(btn => btn.setAttribute(\'aria-disabled\', false));\r\n      }\r\n   },\r\n   options: {\r\n      player_fullscreen_mode_embed: {\r\n         _tagName: \'select\',\r\n         label: \'Apply to video type\',\r\n         \'label:ua\': \'Застосувати до відео\',\r\n         options: [\r\n            {\r\n               label: \'all\', value: false, selected: true,\r\n               \'label:ua\': \'всіх\',\r\n            },\r\n            {\r\n               label: \'embed\', value: \'on\',\r\n               \'label:ua\': \'вбудованих\',\r\n            },\r\n         ],\r\n         title: \'Unavailable if emded fullscreen is not allow\',\r\n      },\r\n      player_fullscreen_mode_onpause: {\r\n         _tagName: \'input\',\r\n         label: \'Exit on video pause\',\r\n         \'label:zh\': \'如果视频暂停，则退出全屏模式\',\r\n         \'label:ja\': \'ビデオが一時停止している場合は、全画面表示モードを終了します\',\r\n         \'label:ko\': \'비디오가 일시 중지되면 전체 화면 모드 종료\',\r\n         \'label:id\': \'Keluar dari mode layar penuh jika video dijeda\',\r\n         \'label:es\': \'Salga del modo de pantalla completa si el video está en pausa\',\r\n         \'label:pt\': \'Saia do modo de tela cheia se o vídeo estiver pausado\',\r\n         \'label:fr\': \'Quitter le mode plein écran si la vidéo est en pause\',\r\n         \'label:it\': \'Uscire dalla modalità a schermo intero se il video è in pausa\',\r\n         \'label:de\': \'Beenden Sie den Vollbildmodus, wenn das Video angehalten ist\',\r\n         \'label:pl\': \'Wyjdź z trybu pełnoekranowego, jeśli wideo jest wstrzymane\',\r\n         \'label:ua\': \'Вихід з повного екрану зупиняє відео\',\r\n         type: \'checkbox\',\r\n      },\r\n      player_fullscreen_mode_ignore_playlist: {\r\n         _tagName: \'input\',\r\n         label: \'Ignore playlist\',\r\n         \'label:zh\': \'忽略播放列表\',\r\n         \'label:ja\': \'プレイリストを無視する\',\r\n         \'label:ko\': \'재생목록 무시\',\r\n         \'label:id\': \'Abaikan daftar putar\',\r\n         \'label:es\': \'Ignorar lista de reproducción\',\r\n         \'label:pt\': \'Ignorar lista de reprodução\',\r\n         \'label:fr\': \'Ignorer la liste de lecture\',\r\n         \'label:it\': \'Ignora playlist\',\r\n         \'label:de\': \'Wiedergabeliste ignorieren\',\r\n         \'label:pl\': \'Zignoruj listę odtwarzania\',\r\n         \'label:ua\': \'Ігнорувати список відтворення\',\r\n         type: \'checkbox\',\r\n      },\r\n      player_fullscreen_mode_ignore_music: {\r\n         _tagName: \'input\',\r\n         label: \'Ignore music\',\r\n         \'label:zh\': \'忽略音乐\',\r\n         \'label:ja\': \'音楽を無視\',\r\n         \'label:ko\': \'음악 무시\',\r\n         \'label:id\': \'Abaikan musik\',\r\n         \'label:es\': \'ignorar la musica\',\r\n         \'label:pt\': \'Ignorar música\',\r\n         \'label:fr\': \'Ignorer la musique\',\r\n         \'label:it\': \'Ignora la musica\',\r\n         \'label:de\': \'Musik ignorieren\',\r\n         \'label:pl\': \'Ignoruj ​​muzykę\',\r\n         \'label:ua\': \'Ігноруйте музику\',\r\n         type: \'checkbox\',\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'video-unblock-warn-content\',\r\n   title: \'Skip warn about inappropriate or offensive content\',\r\n   \'title:ua\': \'Пропустити попередження про неприйнятний або образливий вміст\',\r\n   run_on_pages: \'watch, embed, -mobile\',\r\n   section: \'player\',\r\n   desc: \"skip \'The following content may contain suicide or self-harm topics.\'\",\r\n   \'desc:ua\': \'пропустити \"Наступний контент може містити теми суїциду або самоушкодження\".\',\r\n   _runtime: user_settings => {\r\n      NOVA.waitSelector(\'ytd-watch-flexy[player-unavailable] yt-player-error-message-renderer #button.yt-player-error-message-renderer button\', { stop_on_page_change: true })\r\n         .then(btn => btn.click());\r\n   },\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'save-channel-state\',\r\n   title: \'Add button Save for specific channel\',\r\n   \'title:zh\': \'특정 채널에 저장\',\r\n   \'title:ja\': \'特定のチャンネル用に保存\',\r\n   \'title:ko\': \'특정 채널에 저장\',\r\n   \'title:id\': \'Simpan untuk saluran tertentu\',\r\n   \'title:es\': \'Guardar para un canal específico\',\r\n   \'title:pt\': \'Salvar para canal específico\',\r\n   \'title:fr\': \'Enregistrer pour un canal spécifique\',\r\n   \'title:it\': \'Salva per canale specifico\',\r\n   \'title:de\': \'Speichern Sie für einen bestimmten Kanal\',\r\n   \'title:pl\': \'Zapisz dla określonego kanału\',\r\n   \'title:ua\': \'Зберегти для конкретного каналу\',\r\n   run_on_pages: \'watch, embed\',\r\n   section: \'player\',\r\n   _runtime: user_settings => {\r\n      const\r\n         SELECTOR_BUTTON_ID = \'nova-channels-state\',\r\n         SELECTOR_BUTTON = \'#\' + SELECTOR_BUTTON_ID,\r\n         SELECTOR_BUTTON_CLASS_NAME = \'nova-right-custom-button\',\r\n         SELECTOR_BUTTON_LIST_ID = SELECTOR_BUTTON_CLASS_NAME + \'-list\',\r\n         SELECTOR_BUTTON_LIST = \'#\' + SELECTOR_BUTTON_LIST_ID,\r\n         SELECTOR_BUTTON_TITLE_ID = SELECTOR_BUTTON_CLASS_NAME + \'-title\';\r\n      NOVA.waitSelector(\'#movie_player .ytp-right-controls\')\r\n         .then(container => {\r\n            initStyles();\r\n            NOVA.runOnPageInitOrTransition(async () => {\r\n               if (NOVA.currentPage == \'watch\' || NOVA.currentPage == \'embed\') {\r\n                  await NOVA.storage_obj_manager.initStorage();\r\n                  if (btn = document.getElementById(SELECTOR_BUTTON_ID)) {\r\n                     btn.append(genList());\r\n                  }\r\n                  else {\r\n                     const btn = document.createElement(\'button\');\r\n                     btn.id = SELECTOR_BUTTON_ID;\r\n                     btn.className = `ytp-button ${SELECTOR_BUTTON_CLASS_NAME}`;\r\n                     btn.title = \'Save channel state\';\r\n                     const btnTitle = document.createElement(\'span\');\r\n                     btnTitle.id = SELECTOR_BUTTON_TITLE_ID;\r\n                     btnTitle.style.display = \'flex\';\r\n                     btnTitle.innerHTML =\r\n                        `<svg width=\"100%\" height=\"100%\" viewBox=\"-140 -140 500 500\">\r\n                           <g fill=\"currentColor\">\r\n                              <path d=\"M198.5,0h-17v83h-132V0h-49v231h230V32.668L198.5,0z M197.5,199h-165v-83h165V199z\" />\r\n                              <rect width=\"33\" x=\"131.5\" height=\"66\" />\r\n                           </g>\r\n                        </svg>`;\r\n                     btn.prepend(btnTitle);\r\n                     btn.append(genList());\r\n                     container.prepend(btn);\r\n                  }\r\n                  btnTitleStateUpdate(Boolean(NOVA.storage_obj_manager.read()));\r\n               }\r\n            });\r\n         });\r\n      function btnTitleStateUpdate(state) {\r\n         document.getElementById(SELECTOR_BUTTON_TITLE_ID)\r\n            .style.setProperty(\'opacity\', state ? 1 : .3);\r\n      }\r\n      function genList() {\r\n         const ul = document.createElement(\'ul\');\r\n         ul.id = SELECTOR_BUTTON_LIST_ID;\r\n         let listItem = [];\r\n         if (user_settings[\'video-quality\']) {\r\n            listItem.push({ name: \'quality\', getSaveDataFn: movie_player.getPlaybackQuality });\r\n         }\r\n         if (user_settings[\'rate-wheel\']) {\r\n            listItem.push({ name: \'speed\', getSaveDataFn: movie_player.getPlaybackRate });\r\n         }\r\n         if (user_settings[\'volume-wheel\']) {\r\n            listItem.push({ name: \'volume\', getSaveDataFn: () => ~~(movie_player.getVolume()) });\r\n         }\r\n         listItem.push({\r\n            name: \'subtitles\',\r\n            getSaveDataFn: () => {\r\n               movie_player.toggleSubtitlesOn();\r\n               return true;\r\n            },\r\n            customInit: () => {\r\n               NOVA.waitUntil(() => {\r\n                  movie_player.toggleSubtitlesOn();\r\n                  return document.body.querySelector(\'.ytp-caption-window-top[id^=\"caption-window\"]\');\r\n               }, 500);\r\n            },\r\n         });\r\n         if (user_settings[\'player-resume-playback\']) {\r\n            listItem.push({ name: \'ignore-playback\', label: \'unsave playback time\', getSaveDataFn: () => true });\r\n         }\r\n         listItem.forEach(async element => {\r\n            const storage = NOVA.storage_obj_manager._getParam(element.name);\r\n            const checkbox = document.createElement(\'input\');\r\n            checkbox.type = \'checkbox\';\r\n            checkbox.id = `checkbox-${element.name}`;\r\n            checkbox.checked = Boolean(storage);\r\n            checkbox.className = \'ytp-menuitem-toggle-checkbox\';\r\n            const li = document.createElement(\'li\');\r\n            li.innerHTML =\r\n               `<label for=\"checkbox-${element.name}\">\r\n                  ${element.label || element.name} <span>${storage || \'\'}</span>\r\n               </label>`;\r\n            li.title = storage ? `Currently stored value ${storage}` : \'none\';\r\n            if (Boolean(storage) && element.hasOwnProperty(\'customInit\') && typeof element.customInit === \'function\') {\r\n               element.customInit();\r\n            }\r\n            checkbox.addEventListener(\'change\', () => {\r\n               let state;\r\n               if (checkbox.checked && (state = element.getSaveDataFn())) {\r\n                  NOVA.storage_obj_manager.save({ [element.name]: state });\r\n               }\r\n               else {\r\n                  NOVA.storage_obj_manager.remove(element.name);\r\n               }\r\n               li.title = state ? `Currently stored value ${state}` : \'none\';\r\n               li.querySelector(\'span\').textContent = state || \'\';\r\n               btnTitleStateUpdate(Boolean(state));\r\n            });\r\n            li.prepend(checkbox);\r\n            ul.append(li);\r\n         });\r\n         if (user_settings[\'time-jump\']) {\r\n            const\r\n               SLIDER_LABEL = \'skip into\',\r\n               SLIDER_STORAGE_NAME = \'skip-into\',\r\n               storage = +NOVA.storage_obj_manager._getParam(SLIDER_STORAGE_NAME);\r\n            const slider = document.createElement(\'input\');\r\n            slider.type = \'range\';\r\n            slider.min = 0;\r\n            slider.max = 120;\r\n            slider.step = 1;\r\n            slider.value = storage || 0;\r\n            const li = document.createElement(\'li\');\r\n            li.innerHTML =\r\n               `<label for=\"checkbox-${SLIDER_STORAGE_NAME}\">\r\n                  ${SLIDER_LABEL} <span>${storage || \'\'}</span>\r\n               </label>`;\r\n            li.title = \'Simple alternative SponsorBlock\';\r\n            slider.addEventListener(\'change\', sliderChange);\r\n            slider.addEventListener(\'input\', sliderChange);\r\n            slider.addEventListener(\'wheel\', evt => {\r\n               evt.preventDefault();\r\n               evt.target.value = +evt.target.value + Math.sign(evt.wheelDelta);\r\n               sliderChange(evt);\r\n            });\r\n            li.prepend(slider);\r\n            ul.append(li);\r\n            function sliderChange({ target }) {\r\n               if (state = +target.value) {\r\n                  NOVA.storage_obj_manager.save({ [SLIDER_STORAGE_NAME]: +target.value });\r\n               }\r\n               else {\r\n                  NOVA.storage_obj_manager.remove(SLIDER_STORAGE_NAME);\r\n               }\r\n               li.title = state ? `Currently stored value ${state}` : \'none\';\r\n               li.querySelector(\'span\').textContent = state || \'\';\r\n               btnTitleStateUpdate(Boolean(state));\r\n            }\r\n         }\r\n         return ul;\r\n      }\r\n      function initStyles() {\r\n         NOVA.css.push(\r\n            SELECTOR_BUTTON + ` {\r\n               overflow: visible !important;\r\n               position: relative;\r\n               text-align: center !important;\r\n               vertical-align: top;\r\n               font-weight: bold;\r\n            }\r\n            .ytp-left-controls {\r\n               overflow: visible !important;\r\n            }\r\n            ${SELECTOR_BUTTON_LIST} {\r\n               position: absolute;\r\n               bottom: 2.5em !important;\r\n               left: -2.2em;\r\n               list-style: none;\r\n               padding-bottom: 1.5em !important;\r\n               z-index: ${+NOVA.css.getValue(\'.ytp-progress-bar\', \'z-index\') + 1};\r\n            }\r\n            \r\n            html[data-cast-api-enabled] ${SELECTOR_BUTTON_LIST} {\r\n               margin: 0;\r\n               padding: 0;\r\n               bottom: 3.3em;\r\n               \r\n            }\r\n            ${SELECTOR_BUTTON}:not(:hover) ${SELECTOR_BUTTON_LIST} {\r\n               display: none;\r\n            }\r\n            ${SELECTOR_BUTTON_LIST} li {\r\n               cursor: pointer;\r\n               white-space: nowrap;\r\n               line-height: 1.4;\r\n               background: rgba(28, 28, 28, 0.9);\r\n               margin: .3em 0;\r\n               padding: .5em 1em;\r\n               border-radius: .3em;\r\n               color: #fff;\r\n               text-align: left !important;\r\n               display: grid;\r\n               grid-template-columns: auto auto;\r\n               align-items: center;\r\n               justify-content: start;\r\n            }\r\n            ${SELECTOR_BUTTON_LIST} li label {\r\n               cursor: pointer;\r\n               padding-left: 5px;\r\n            }\r\n            ${SELECTOR_BUTTON_LIST} li.active { background: #720000; }\r\n            ${SELECTOR_BUTTON_LIST} li.disable { color: #666; }\r\n            ${SELECTOR_BUTTON_LIST} li:not(:hover) { opacity: .8; }\r\n            \r\n            ${SELECTOR_BUTTON_LIST} li span:not(:empty):before { content: \'(\'; }\r\n            ${SELECTOR_BUTTON_LIST} li span:not(:empty):after { content: \')\'; }\r\n            \r\n            ${SELECTOR_BUTTON_LIST} [type=\"checkbox\"] {\r\n               appearance: none;\r\n               outline: none;\r\n               cursor: pointer;\r\n            }\r\n            ${SELECTOR_BUTTON_LIST} [type=\"checkbox\"]:checked {\r\n               background: #f00;\r\n            }\r\n            ${SELECTOR_BUTTON_LIST} [type=\"checkbox\"]:checked:after {\r\n               left: 20px;\r\n               background-color: #fff;\r\n            }`);\r\n      }\r\n   },\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'time-remaining\',\r\n   title: \'Remaining time\',\r\n   \'title:zh\': \'剩余时间\',\r\n   \'title:ja\': \'余日\',\r\n   \'title:ko\': \'남은 시간\',\r\n   \'title:id\': \'Waktu yang tersisa\',\r\n   \'title:es\': \'Tiempo restante\',\r\n   \'title:pt\': \'Tempo restante\',\r\n   \'title:fr\': \'Temps restant\',\r\n   \'title:it\': \'Tempo rimanente\',\r\n   \'title:de\': \'Verbleibende Zeit\',\r\n   \'title:pl\': \'Pozostały czas\',\r\n   \'title:ua\': \'Час, що залишився\',\r\n   run_on_pages: \'watch, embed, -mobile\',\r\n   section: \'player\',\r\n   desc: \'Remaining time until the end of the video\',\r\n   \'desc:zh\': \'距离视频结束的剩余时间\',\r\n   \'desc:ja\': \'ビデオの終わりまでの残り時間\',\r\n   \'desc:ko\': \'영상 끝까지 남은 시간\',\r\n   \'desc:id\': \'Sisa waktu sampai akhir video\',\r\n   \'desc:es\': \'Tiempo restante hasta el final del video\',\r\n   \'desc:pt\': \'Tempo restante até o final do vídeo\',\r\n   \'desc:fr\': \"Temps restant jusqu\'à la fin de la vidéo\",\r\n   \'desc:it\': \'Tempo rimanente fino alla fine del video\',\r\n   \'desc:de\': \'Verbleibende Zeit bis zum Ende des Videos\',\r\n   \'desc:pl\': \'Czas pozostały do końca filmu\',\r\n   \'desc:ua\': \'Час, що залишився до кінця відео\',\r\n   _runtime: user_settings => {\r\n      const SELECTOR_ID = \'nova-player-time-remaining\';\r\n      NOVA.waitSelector(\'.ytp-time-duration, ytm-time-display .time-display-content\')\r\n         .then(container => {\r\n            NOVA.waitSelector(\'video\')\r\n               .then(video => {\r\n                  video.addEventListener(\'timeupdate\', setRemaining.bind(video));\r\n                  video.addEventListener(\'ratechange\', setRemaining.bind(video));\r\n                  video.addEventListener(\'ended\', () => insertToHTML({ \'container\': container }));\r\n                  document.addEventListener(\'yt-navigate-finish\', () => insertToHTML({ \'container\': container }));\r\n               });\r\n            function setRemaining() {\r\n               if (isNaN(this.duration)\r\n                  || movie_player.getVideoData().isLive\r\n                  || (NOVA.currentPage == \'embed\' && window.self.location.href.includes(\'live_stream\'))\r\n                  || document.visibilityState == \'hidden\'\r\n                  || movie_player.classList.contains(\'ytp-autohide\')\r\n               ) return;\r\n               const\r\n                  getProgressPt = () => {\r\n                     const floatRound = pt => (this.duration > 3600) ? pt.toFixed(2)\r\n                        : (this.duration > 1500) ? pt.toFixed(1)\r\n                           : Math.round(pt);\r\n                     return floatRound((this.currentTime / this.duration) * 100) + \'%\';\r\n                  },\r\n                  getLeftTime = () => \'-\' + NOVA.timeFormatTo.HMS.digit((this.duration - this.currentTime) / this.playbackRate);\r\n               let text;\r\n               switch (user_settings.time_remaining_mode) {\r\n                  case \'pt\': text = \' • \' + getProgressPt(); break;\r\n                  case \'time\': text = getLeftTime(); break;\r\n                  default:\r\n                     text = getLeftTime();\r\n                     text += text && ` (${getProgressPt()})`;\r\n               }\r\n               if (text) {\r\n                  insertToHTML({ \'text\': text, \'container\': container });\r\n               }\r\n            }\r\n            function insertToHTML({ text = \'\', container = required() }) {\r\n               if (!(container instanceof HTMLElement)) return console.error(\'container not HTMLElement:\', container);\r\n               (document.getElementById(SELECTOR_ID) || (function () {\r\n                  container.insertAdjacentHTML(\'afterend\', `&nbsp;<span id=\"${SELECTOR_ID}\">${text}</span>`);\r\n                  return document.getElementById(SELECTOR_ID);\r\n               })())\r\n                  .textContent = text;\r\n            }\r\n         });\r\n   },\r\n   options: {\r\n      time_remaining_mode: {\r\n         _tagName: \'select\',\r\n         label: \'Mode\',\r\n         \'label:zh\': \'模式\',\r\n         \'label:ja\': \'モード\',\r\n         \'label:ko\': \'방법\',\r\n         \'label:es\': \'Modo\',\r\n         \'label:pt\': \'Modo\',\r\n         \'label:it\': \'Modalità\',\r\n         \'label:de\': \'Modus\',\r\n         \'label:pl\': \'Tryb\',\r\n         \'label:ua\': \'Режим\',\r\n         options: [\r\n            {\r\n               label: \'time+(%)\', value: \'full\',\r\n               \'label:ua\': \'час+(%)\',\r\n            },\r\n            {\r\n               label: \'time\', value: \'time\', selected: true,\r\n               \'label:ua\': \'час\',\r\n            },\r\n            {\r\n               label: \'%\', value: \'pt\',\r\n            },\r\n         ],\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'player-float-progress-bar\',\r\n   title: \'Float player progress bar\',\r\n   \'title:zh\': \'浮动播放器进度条\',\r\n   \'title:ja\': \'フロートプレーヤーのプログレスバー\',\r\n   \'title:ko\': \'플로팅 플레이어 진행률 표시줄\',\r\n   \'title:id\': \'Bilah kemajuan pemain mengambang\',\r\n   \'title:es\': \'Barra de progreso flotante del jugador\',\r\n   \'title:pt\': \'Barra de progresso do jogador flutuante\',\r\n   \'title:fr\': \'Barre de progression du joueur flottant\',\r\n   \'title:it\': \'Barra di avanzamento del giocatore mobile\',\r\n   \'title:de\': \'Float-Player-Fortschrittsbalken\',\r\n   \'title:pl\': \'Pływający pasek postępu odtwarzacza\',\r\n   \'title:ua\': \'Плаваючий індикатор прогресу відтворення\',\r\n   run_on_pages: \'watch, embed, -mobile\',\r\n   section: \'player\',\r\n   _runtime: user_settings => {\r\n      if (NOVA.currentPage == \'embed\' && window.self.location.href.includes(\'live_stream\')\r\n      ) return;\r\n      if (NOVA.currentPage == \'embed\' && [\'0\', \'false\'].includes(NOVA.queryURL.get(\'controls\'))) return;\r\n      const\r\n         SELECTOR_ID = \'nova-player-float-progress-bar\',\r\n         SELECTOR = \'#\' + SELECTOR_ID,\r\n         CHAPTERS_MARK_WIDTH_PX = \'2px\';\r\n      NOVA.waitSelector(\'#movie_player.ytp-autohide video\')\r\n         .then(video => {\r\n            const\r\n               container = insertFloatBar(Math.max(\r\n                  NOVA.css.getValue(\'.ytp-chrome-bottom\', \'z-index\'), 59\r\n               ) + 1),\r\n               bufferEl = document.getElementById(`${SELECTOR_ID}-buffer`),\r\n               progressEl = document.getElementById(`${SELECTOR_ID}-progress`);\r\n            renderChapters.init(video);\r\n            video.addEventListener(\'loadeddata\', resetBar);\r\n            video.addEventListener(\'timeupdate\', function () {\r\n               if (notInteractiveToRender()) return;\r\n               if (!isNaN(this.duration)) {\r\n                  progressEl.style.transform = `scaleX(${this.currentTime / this.duration})`;\r\n               }\r\n            });\r\n            video.addEventListener(\'progress\', renderBuffer.bind(video));\r\n            video.addEventListener(\'seeking\', renderBuffer.bind(video));\r\n            function renderBuffer() {\r\n               if (notInteractiveToRender()) return;\r\n               if ((totalDuration = movie_player.getDuration()) && !isNaN(totalDuration)) {\r\n                  bufferEl.style.transform = `scaleX(${movie_player.getVideoLoadedFraction()})`;\r\n               }\r\n            }\r\n            function resetBar() {\r\n               container.style.display = movie_player.getVideoData().isLive ? \'none\' : \'initial\';\r\n               container.classList.remove(\'transition\');\r\n               bufferEl.style.transform = \'scaleX(0)\';\r\n               progressEl.style.transform = \'scaleX(0)\';\r\n               container.classList.add(\'transition\');\r\n               renderChapters.init(video);\r\n            }\r\n            function notInteractiveToRender() {\r\n               return (document.visibilityState == \'hidden\'\r\n                  || movie_player.getVideoData().isLive\r\n               );\r\n            }\r\n         });\r\n      function insertFloatBar(z_index = 60) {\r\n         return document.getElementById(SELECTOR_ID) || (function () {\r\n            movie_player.insertAdjacentHTML(\'beforeend\',\r\n               `<div id=\"${SELECTOR_ID}\" class=\"transition\">\r\n                  <div class=\"container\">\r\n                     <div id=\"${SELECTOR_ID}-buffer\" class=\"ytp-load-progress\"></div>\r\n                     <div id=\"${SELECTOR_ID}-progress\" class=\"ytp-swatch-background-color\"></div>\r\n                  </div>\r\n                  <div id=\"${SELECTOR_ID}-chapters\"></div>\r\n               </div>`);\r\n            NOVA.css.push(\r\n               `[id|=${SELECTOR_ID}] {\r\n                  position: absolute;\r\n                  bottom: 0;\r\n               }\r\n               ${SELECTOR} {\r\n                  --opacity: ${+user_settings.player_float_progress_bar_opacity || .7};\r\n                  --height: ${+user_settings.player_float_progress_bar_height || 3}px;\r\n                  --bg-color: ${NOVA.css.getValue(\'.ytp-progress-list\', \'background-color\') || \'rgba(255,255,255,.2)\'};\r\n                  --zindex: ${z_index};\r\n                  opacity: var(--opacity);\r\n                  z-index: var(--zindex);\r\n                  background-color: var(--bg-color);\r\n                  width: 100%;\r\n                  visibility: hidden;\r\n               }\r\n               \r\n               #movie_player.ytp-autohide ${SELECTOR} {\r\n                  visibility: visible;\r\n               }\r\n               \r\n               ${SELECTOR}.transition [id|=${SELECTOR_ID}] {\r\n                  transition: transform .2s linear;\r\n               }\r\n               ${SELECTOR}-progress, ${SELECTOR}-buffer {\r\n                  width: 100%;\r\n                  height: var(--height);\r\n                  transform-origin: 0 0;\r\n                  transform: scaleX(0);\r\n               }\r\n               ${SELECTOR}-progress {\r\n                  z-index: calc(var(--zindex) + 1);\r\n               }\r\n               \r\n               ${SELECTOR}-chapters {\r\n                  position: relative;\r\n                  width: 100%;\r\n                  display: flex;\r\n                  justify-content: flex-end;\r\n               }\r\n               ${SELECTOR}-chapters span {\r\n                  height: var(--height);\r\n                  z-index: calc(var(--zindex) + 1);\r\n                  box-sizing: border-box;\r\n                  padding: 0;\r\n                  margin: 0;\r\n               }\r\n               ${SELECTOR}-chapters span:not(:first-child) {\r\n                  \r\n                  border-left: ${CHAPTERS_MARK_WIDTH_PX} solid rgba(255,255,255,.7);\r\n               }`);\r\n            return document.getElementById(SELECTOR_ID);\r\n         })();\r\n      }\r\n      const renderChapters = {\r\n         async init(vid) {\r\n            if (NOVA.currentPage == \'watch\' && !(vid instanceof HTMLElement)) {\r\n               return console.error(\'vid not HTMLElement:\', chaptersContainer);\r\n            }\r\n            await NOVA.waitUntil(() => !isNaN(vid.duration), 1000);\r\n            switch (NOVA.currentPage) {\r\n               case \'watch\':\r\n                  this.from_description(vid.duration);\r\n                  break;\r\n               case \'embed\':\r\n                  await NOVA.waitUntil(() => (\r\n                     chaptersContainer = document.body.querySelector(\'.ytp-chapters-container\'))\r\n                     && chaptersContainer?.children.length > 1\r\n                     , 1000);\r\n                  (\r\n                     this.renderChaptersMarks(vid.duration)\r\n                     || this.from_div(chaptersContainer)\r\n                  );\r\n                  break;\r\n            }\r\n            NOVA.runOnPageInitOrTransition(() => {\r\n               if (NOVA.currentPage == \'watch\') {\r\n                  NOVA.waitSelector(\'#meta [collapsed] #more, [description-collapsed] #description #expand\')\r\n                     .then(btn => btn.click());\r\n               }\r\n            });\r\n         },\r\n         from_description(duration = required()) {\r\n            if (Math.sign(duration) !== 1) return console.error(\'duration not positive number:\', duration);\r\n            const selectorTimestampLink = \'a[href*=\"&t=\"]\';\r\n            NOVA.waitSelector(`ytd-watch-metadata #description.ytd-watch-metadata ${selectorTimestampLink}`, { stop_on_page_change: true })\r\n               .then(() => this.renderChaptersMarks(duration));\r\n            NOVA.waitSelector(`#comments #comment #comment-content ${selectorTimestampLink}`, { stop_on_page_change: true })\r\n               .then(() => this.renderChaptersMarks(duration));\r\n         },\r\n         from_div(chaptersContainer = required()) {\r\n            if (!(chaptersContainer instanceof HTMLElement)) return console.error(\'container not HTMLElement:\', chaptersContainer);\r\n            const\r\n               progressContainerWidth = parseInt(getComputedStyle(chaptersContainer).width),\r\n               chaptersOut = document.getElementById(`${SELECTOR_ID}-chapters`);\r\n            for (const chapter of chaptersContainer.children) {\r\n               const\r\n                  newChapter = document.createElement(\'span\'),\r\n                  { width, marginLeft, marginRight } = getComputedStyle(chapter),\r\n                  chapterMargin = parseInt(marginLeft) + parseInt(marginRight);\r\n               newChapter.style.width = (((parseInt(width) + chapterMargin) / progressContainerWidth) * 100) + \'%\';\r\n               chaptersOut.append(newChapter);\r\n            }\r\n         },\r\n         renderChaptersMarks(duration) {\r\n            if (isNaN(duration)) return console.error(\'duration isNaN:\', duration);\r\n            if (chaptersContainer = document.getElementById(`${SELECTOR_ID}-chapters`)) {\r\n               chaptersContainer.innerHTML = \'\';\r\n            }\r\n            const chapterList = NOVA.getChapterList(duration);\r\n            chapterList\r\n               ?.forEach((chapter, i, chapters_list) => {\r\n                  const newChapter = document.createElement(\'span\');\r\n                  const nextChapterSec = chapters_list[i + 1]?.sec || duration;\r\n                  newChapter.style.width = ((nextChapterSec - chapter.sec) / duration) * 100 + \'%\';\r\n                  if (chapter.title) newChapter.title = chapter.title;\r\n                  newChapter.setAttribute(\'time\', chapter.time);\r\n                  chaptersContainer.append(newChapter);\r\n               });\r\n            return chapterList;\r\n         },\r\n      };\r\n   },\r\n   options: {\r\n      player_float_progress_bar_height: {\r\n         _tagName: \'input\',\r\n         label: \'Height\',\r\n         \'label:zh\': \'高度\',\r\n         \'label:ja\': \'身長\',\r\n         \'label:ko\': \'키\',\r\n         \'label:id\': \'Tinggi\',\r\n         \'label:es\': \'Altura\',\r\n         \'label:pt\': \'Altura\',\r\n         \'label:fr\': \'Hauteur\',\r\n         \'label:it\': \'Altezza\',\r\n         \'label:de\': \'Höhe\',\r\n         \'label:pl\': \'Wysokość\',\r\n         \'label:ua\': \'Висота\',\r\n         type: \'number\',\r\n         title: \'in pixels\',\r\n         placeholder: \'px\',\r\n         min: 1,\r\n         max: 9,\r\n         value: 3,\r\n      },\r\n      player_float_progress_bar_opacity: {\r\n         _tagName: \'input\',\r\n         label: \'Opacity\',\r\n         \'label:zh\': \'不透明度\',\r\n         \'label:ja\': \'不透明度\',\r\n         \'label:ko\': \'불투명\',\r\n         \'label:id\': \'Kegelapan\',\r\n         \'label:es\': \'Opacidad\',\r\n         \'label:pt\': \'Opacidade\',\r\n         \'label:fr\': \'Opacité\',\r\n         \'label:it\': \'Opacità\',\r\n         \'label:de\': \'Opazität\',\r\n         \'label:pl\': \'Przejrzystość\',\r\n         \'label:ua\': \'Прозорість\',\r\n         type: \'number\',\r\n         placeholder: \'0-1\',\r\n         step: .05,\r\n         min: 0,\r\n         max: 1,\r\n         value: .7,\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'player-quick-buttons\',\r\n   title: \'Custom player buttons\',\r\n   \'title:zh\': \'自定义按钮\',\r\n   \'title:ja\': \'カスタムボタン\',\r\n   \'title:ko\': \'사용자 정의 버튼\',\r\n   \'title:id\': \'Tombol pemutar khusus\',\r\n   \'title:es\': \'Botones personalizados\',\r\n   \'title:pt\': \'Botões personalizados\',\r\n   \'title:fr\': \'Boutons personnalisés\',\r\n   \'title:it\': \'Pulsanti personalizzati del giocatore\',\r\n   \'title:de\': \'Benutzerdefinierte Schaltflächen\',\r\n   \'title:pl\': \'Własne przyciski odtwarzacza\',\r\n   \'title:ua\': \'Власні кнопки відтворювання\',\r\n   run_on_pages: \'watch, embed, -mobile\',\r\n   section: \'player\',\r\n   _runtime: user_settings => {\r\n      const\r\n         SELECTOR_BTN_CLASS_NAME = \'nova-right-custom-button\',\r\n         SELECTOR_BTN = \'.\' + SELECTOR_BTN_CLASS_NAME;\r\n      NOVA.waitSelector(\'#movie_player .ytp-right-controls\')\r\n         .then(async container => {\r\n            NOVA.videoElement = await NOVA.waitSelector(\'video\');\r\n            NOVA.css.push(\r\n               `${SELECTOR_BTN} {\r\n                  user-select: none;\r\n                  \r\n               }\r\n               ${SELECTOR_BTN}:hover { color: #66afe9 !important; }\r\n               ${SELECTOR_BTN}:active { color: #2196f3 !important; }`);\r\n            NOVA.css.push(\r\n               `${SELECTOR_BTN}[tooltip]:hover::before {\r\n                  content: attr(tooltip);\r\n                  position: absolute;\r\n                  top: -3em;\r\n                  transform: translateX(-30%);\r\n                  line-height: normal;\r\n                  background-color: rgba(28,28,28,.9);\r\n                  border-radius: 2px;\r\n                  padding: 5px 9px;\r\n                  color: #fff;\r\n                  font-weight: bold;\r\n                  white-space: nowrap;\r\n               }\r\n               \r\n               html[data-cast-api-enabled] ${SELECTOR_BTN}[tooltip]:hover::before {\r\n                  font-weight: normal;\r\n               }`);\r\n            if (user_settings.player_buttons_custom_items?.includes(\'picture-in-picture\')) {\r\n               const pipBtn = document.createElement(\'button\');\r\n               pipBtn.className = `ytp-button ${SELECTOR_BTN_CLASS_NAME}`;\r\n               pipBtn.setAttribute(\'tooltip\', \'Open in PictureInPicture\');\r\n               pipBtn.innerHTML = createSVG();\r\n               pipBtn.addEventListener(\'click\', () => document.pictureInPictureElement\r\n                  ? document.exitPictureInPicture() : NOVA.videoElement.requestPictureInPicture()\r\n               );\r\n               container.prepend(pipBtn);\r\n               NOVA.videoElement?.addEventListener(\'enterpictureinpicture\', () => pipBtn.innerHTML = createSVG(2));\r\n               NOVA.videoElement?.addEventListener(\'leavepictureinpicture\', () => pipBtn.innerHTML = createSVG());\r\n               function createSVG(alt) {\r\n                  const svg = document.createElement(\'svg\');\r\n                  svg.setAttribute(\'width\', \'100%\');\r\n                  svg.setAttribute(\'height\', \'100%\');\r\n                  svg.setAttribute(\'viewBox\', \'-8 -6 36 36\');\r\n                  const path = document.createElement(\'path\');\r\n                  path.setAttribute(\'fill\', \'currentColor\');\r\n                  path.setAttribute(\'d\', alt\r\n                     ? \'M18.5,11H18v1h.5A1.5,1.5,0,0,1,20,13.5v5A1.5,1.5,0,0,1,18.5,20h-8A1.5,1.5,0,0,1,9,18.5V18H8v.5A2.5,2.5,0,0,0,10.5,21h8A2.5,2.5,0,0,0,21,18.5v-5A2.5,2.5,0,0,0,18.5,11Z M14.5,4H2.5A2.5,2.5,0,0,0,0,6.5v8A2.5,2.5,0,0,0,2.5,17h12A2.5,2.5,0,0,0,17,14.5v-8A2.5,2.5,0,0,0,14.5,4Z\'\r\n                     : \'M2.5,17A1.5,1.5,0,0,1,1,15.5v-9A1.5,1.5,0,0,1,2.5,5h13A1.5,1.5,0,0,1,17,6.5V10h1V6.5A2.5,2.5,0,0,0,15.5,4H2.5A2.5,2.5,0,0,0,0,6.5v9A2.5,2.5,0,0,0,2.5,18H7V17Z M18.5,11h-8A2.5,2.5,0,0,0,8,13.5v5A2.5,2.5,0,0,0,10.5,21h8A2.5,2.5,0,0,0,21,18.5v-5A2.5,2.5,0,0,0,18.5,11Z\');\r\n                  svg.append(path);\r\n                  return svg.outerHTML;\r\n               }\r\n            }\r\n            if (user_settings.player_buttons_custom_items?.indexOf(\'popup\') !== -1 && !NOVA.queryURL.has(\'popup\')) {\r\n               const popupBtn = document.createElement(\'button\');\r\n               popupBtn.className = `ytp-button ${SELECTOR_BTN_CLASS_NAME}`;\r\n               popupBtn.setAttribute(\'tooltip\', \'Open in popup\');\r\n               popupBtn.innerHTML =\r\n                  `<svg viewBox=\"-8 -8 36 36\" height=\"100%\" width=\"100%\">\r\n                     <g fill=\"currentColor\">\r\n                        <path d=\"M18 2H6v4H2v12h12v-4h4V2z M12 16H4V8h2v6h6V16z M16 12h-2h-2H8V8V6V4h8V12z\" />\r\n                     </g>\r\n                  </svg>`;\r\n               popupBtn.addEventListener(\'click\', () => {\r\n                  const { width, height } = NOVA.aspectRatio.sizeToFit({\r\n                     \'srcWidth\': NOVA.videoElement.videoWidth,\r\n                     \'srcHeight\': NOVA.videoElement.videoHeight,\r\n                     \'maxWidth\': screen.width / (+user_settings.player_buttons_custom_popup_width || 4),\r\n                  });\r\n                  url = new URL(\r\n                     document.querySelector(\'link[itemprop=\"embedUrl\"][href]\')?.href\r\n                     || (location.origin + \'/embed/\' + movie_player.getVideoData().video_id)\r\n                  );\r\n                  if (currentTime = ~~NOVA.videoElement?.currentTime) url.searchParams.set(\'start\', currentTime);\r\n                  url.searchParams.set(\'autoplay\', 1);\r\n                  url.searchParams.set(\'popup\', true);\r\n                  openPopup({ \'url\': url.href, \'title\': document.title, \'width\': width, \'height\': height });\r\n               });\r\n               container.prepend(popupBtn);\r\n               function openPopup({ url, title, width, height }) {\r\n                  const left = (screen.width / 2) - (width / 2);\r\n                  const top = (screen.height / 2) - (height / 2);\r\n                  const newWindow = window.open(url, \'_blank\', `popup=1,toolbar=no,location=no,directories=no,status=no,menubar=no,scrollbars=no,resizable=yes,copyhistory=no,width=${width},height=${height},top=${top},left=${left}`);\r\n                  newWindow.document.title = title;\r\n               }\r\n            }\r\n            if (user_settings.player_buttons_custom_items?.includes(\'screenshot\')) {\r\n               const\r\n                  SELECTOR_SCREENSHOT_ID = \'nova-screenshot-result\',\r\n                  SELECTOR_SCREENSHOT = \'#\' + SELECTOR_SCREENSHOT_ID;\r\n               NOVA.css.push(\r\n                  SELECTOR_SCREENSHOT + ` {\r\n                     --width: 400px;\r\n                     --height: 400px;\r\n                     position: fixed;\r\n                     top: 0;\r\n                     right: 0;\r\n                     overflow: hidden;\r\n                     margin: 36px 30px; \r\n                     box-shadow: 0 0 15px #000;\r\n                     max-width: var(--width);\r\n                     max-height: var(--height);\r\n                  }\r\n                  \r\n                  \r\n                  \r\n                  ${SELECTOR_SCREENSHOT} canvas {\r\n                     max-width: var(--width);\r\n                     max-height: var(--height);\r\n                     \r\n                  }\r\n                  ${SELECTOR_SCREENSHOT} .close-btn {\r\n                     position: absolute;\r\n                     bottom: 0;\r\n                     right: 0;\r\n                     background-color: rgba(0, 0, 0, .5);\r\n                     color: #FFF;\r\n                     cursor: pointer;\r\n                     font-size: 12px;\r\n                     display: grid;\r\n                     height: 100%;\r\n                     width: 25%;\r\n                  }\r\n                  ${SELECTOR_SCREENSHOT} .close-btn:hover { background-color: rgba(0, 0, 0, .65); }\r\n                  ${SELECTOR_SCREENSHOT} .close-btn > * { margin: auto; }`);\r\n               const screenshotBtn = document.createElement(\'button\');\r\n               screenshotBtn.className = `ytp-button ${SELECTOR_BTN_CLASS_NAME}`;\r\n               screenshotBtn.setAttribute(\'tooltip\', \'Take screenshot\');\r\n               screenshotBtn.innerHTML =\r\n                  `<svg viewBox=\"0 -166 512 860\" height=\"100%\" width=\"100%\">\r\n                     <g fill=\"currentColor\">\r\n                        <circle cx=\"255.811\" cy=\"285.309\" r=\"75.217\" />\r\n                        <path d=\"M477,137H352.718L349,108c0-16.568-13.432-30-30-30H191c-16.568,0-30,13.432-30,30l-3.718,29H34 c-11.046,0-20,8.454-20,19.5v258c0,11.046,8.954,20.5,20,20.5h443c11.046,0,20-9.454,20-20.5v-258C497,145.454,488.046,137,477,137 z M255.595,408.562c-67.928,0-122.994-55.066-122.994-122.993c0-67.928,55.066-122.994,122.994-122.994 c67.928,0,122.994,55.066,122.994,122.994C378.589,353.495,323.523,408.562,255.595,408.562z M474,190H369v-31h105V190z\" />\r\n                     </g>\r\n                  </svg>`;\r\n               screenshotBtn.addEventListener(\'click\', () => {\r\n                  const\r\n                     container = document.getElementById(SELECTOR_SCREENSHOT_ID) || document.createElement(\'a\'),\r\n                     canvas = container.querySelector(\'canvas\') || document.createElement(\'canvas\');\r\n                  canvas.width = NOVA.videoElement.videoWidth;\r\n                  canvas.height = NOVA.videoElement.videoHeight\r\n                  canvas.getContext(\'2d\').drawImage(NOVA.videoElement, 0, 0, canvas.width, canvas.height);\r\n                  canvas.title = \'Click to save\';\r\n                  try {\r\n                     canvas.toBlob(blob => container.href = URL.createObjectURL(blob));\r\n                  } catch (error) {\r\n                  }\r\n                  if (!container.id) {\r\n                     container.id = SELECTOR_SCREENSHOT_ID;\r\n                     container.target = \'_blank\';\r\n                     if (headerContainer = document.getElementById(\'masthead-container\')) {\r\n                        container.style.marginTop = (headerContainer?.offsetHeight || 0) + \'px\';\r\n                        container.style.zIndex = +getComputedStyle(headerContainer)[\'z-index\'] + 1;\r\n                     }\r\n                     canvas.addEventListener(\'click\', evt => {\r\n                        evt.preventDefault();\r\n                        downloadCanvasAsImage(evt.target);\r\n                        container.remove();\r\n                     });\r\n                     container.append(canvas);\r\n                     const close = document.createElement(\'a\');\r\n                     close.className = \'close-btn\'\r\n                     close.innerHTML = \'<span>CLOSE</span>\';\r\n                     close.title = \'Close\';\r\n                     close.addEventListener(\'click\', evt => {\r\n                        evt.preventDefault();\r\n                        container.remove();\r\n                     });\r\n                     container.append(close);\r\n                     document.body.append(container);\r\n                  }\r\n               });\r\n               function downloadCanvasAsImage(canvas) {\r\n                  const\r\n                     downloadLink = document.createElement(\'a\'),\r\n                     downloadFileName =\r\n                        [\r\n                           movie_player.getVideoData().title\r\n                              .replace(/[\\\\/:*?\"<>|]+/g, \'\')\r\n                              .replace(/\\s+/g, \' \').trim(),\r\n                           `[${NOVA.timeFormatTo.HMS.abbr(NOVA.videoElement.currentTime)}]`,\r\n                        ]\r\n                           .join(\' \');\r\n                  downloadLink.href = canvas.toBlob(blob => URL.createObjectURL(blob));\r\n                  downloadLink.download = downloadFileName +\r\n                     \'.\' + (user_settings.player_buttons_custom_screenshot || \'png\');\r\n                  downloadLink.click();\r\n               }\r\n               container.prepend(screenshotBtn);\r\n            }\r\n            if (user_settings.player_buttons_custom_items?.includes(\'thumbnail\')) {\r\n               const thumbBtn = document.createElement(\'button\');\r\n               thumbBtn.className = `ytp-button ${SELECTOR_BTN_CLASS_NAME}`;\r\n               thumbBtn.setAttribute(\'tooltip\', \'View Thumbnail\');\r\n               thumbBtn.innerHTML =\r\n                  `<svg viewBox=\"0 -10 21 40\" height=\"100%\" width=\"100%\">\r\n                     <g fill=\"currentColor\">\r\n                        <circle cx=\'8\' cy=\'7.2\' r=\'2\'/>\r\n                        <path d=\'M0 2v16h20V2H0z M18 16H2V4h16V16z\'/>\r\n                        <polygon points=\'17 10.9 14 7.9 9 12.9 6 9.9 3 12.9 3 15 17 15\' />\r\n                     </g>\r\n                  </svg>`;\r\n               thumbBtn.addEventListener(\'click\', async () => {\r\n                  const\r\n                     videoId = movie_player.getVideoData().video_id || NOVA.queryURL.get(\'v\'),\r\n                     thumbsSizesTemplate = [\r\n                        \'maxres\',\r\n                        \'sd\',\r\n                        \'hq\',\r\n                        \'mq\',\r\n                        \'\'\r\n                     ];\r\n                  document.body.style.cursor = \'wait\';\r\n                  for (const resPrefix of thumbsSizesTemplate) {\r\n                     const\r\n                        imgUrl = `https://i.ytimg.com/vi/${videoId}/${resPrefix}default.jpg`,\r\n                        response = await fetch(imgUrl);\r\n                     if (response.status === 200) {\r\n                        document.body.style.cursor = \'default\';\r\n                        window.open(imgUrl);\r\n                        break;\r\n                     }\r\n                  }\r\n               });\r\n               container.prepend(thumbBtn);\r\n            }\r\n            if (user_settings.player_buttons_custom_items?.includes(\'rotate\')) {\r\n               const\r\n                  hotkey = user_settings.player_buttons_custom_hotkey_rotate || \'r\',\r\n                  rotateBtn = document.createElement(\'button\');\r\n               rotateBtn.className = `ytp-button ${SELECTOR_BTN_CLASS_NAME}`;\r\n               rotateBtn.setAttribute(\'tooltip\', `Rotate video (${hotkey})`);\r\n               Object.assign(rotateBtn.style, {\r\n                  padding: \'0 1.1em\',\r\n               });\r\n               rotateBtn.innerHTML =\r\n                  `<svg viewBox=\"0 0 1536 1536\" height=\"100%\" width=\"100%\">\r\n                     <g fill=\"currentColor\">\r\n                        <path\r\n                           d=\"M1536 128v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39 14-69l138-138Q969 256 768 256q-104 0-198.5 40.5T406 406 296.5 569.5 256 768t40.5 198.5T406 1130t163.5 109.5T768 1280q119 0 225-52t179-147q7-10 23-12 14 0 25 9l137 138q9 8 9.5 20.5t-7.5 22.5q-109 132-264 204.5T768 1536q-156 0-298-61t-245-164-164-245T0 768t61-298 164-245T470 61 768 0q147 0 284.5 55.5T1297 212l130-129q29-31 70-14 39 17 39 59z\"/>\r\n                        </path>\r\n                     </g>\r\n                  </svg>`;\r\n               rotateBtn.addEventListener(\'click\', rotateVideo);\r\n               document.addEventListener(\'keyup\', evt => {\r\n                  if ([\'input\', \'textarea\', \'select\'].includes(evt.target.localName) || evt.target.isContentEditable) return;\r\n                  if (evt.key === hotkey) {\r\n                     rotateVideo();\r\n                  }\r\n               });\r\n               function rotateVideo() {\r\n                  let angle = parseInt(NOVA.videoElement.style.transform.replace(/\\D+/, \'\')) || 0;\r\n                  const scale = (angle === 0 || angle === 180) ? movie_player.clientHeight / NOVA.videoElement.clientWidth : 1;\r\n                  angle += 90;\r\n                  NOVA.videoElement.style.transform = (angle === 360) ? \'\' : `rotate(${angle}deg) scale(${scale})`;\r\n               }\r\n               container.prepend(rotateBtn);\r\n            }\r\n            if (user_settings.player_buttons_custom_items?.includes(\'aspect-ratio\')) {\r\n               const\r\n                  aspectRatioBtn = document.createElement(\'a\'),\r\n                  aspectRatioList = [\r\n                     { \'16:9\': 1.335 },\r\n                     { \'4:3\': .75 },\r\n                     { \'9:16\': 1.777777778 },\r\n                     { \'auto\': 1 },\r\n                  ],\r\n                  genTooltip = (key = 0) => `Switch aspect ratio to ` + Object.keys(aspectRatioList[key]);\r\n               aspectRatioBtn.className = `ytp-button ${SELECTOR_BTN_CLASS_NAME}`;\r\n               aspectRatioBtn.style.textAlign = \'center\';\r\n               aspectRatioBtn.style.fontWeight = \'bold\';\r\n               aspectRatioBtn.setAttribute(\'tooltip\', genTooltip());\r\n               aspectRatioBtn.innerHTML = \'1:1\';\r\n               aspectRatioBtn.addEventListener(\'click\', () => {\r\n                  if (!NOVA.videoElement) return;\r\n                  const getNextIdx = () => (this.listIdx < aspectRatioList.length - 1) ? this.listIdx + 1 : 0;\r\n                  this.listIdx = getNextIdx();\r\n                  NOVA.videoElement.style.transform = `scaleX(${Object.values(aspectRatioList[this.listIdx])})`;\r\n                  aspectRatioBtn.setAttribute(\'tooltip\', genTooltip(getNextIdx()));\r\n                  aspectRatioBtn.textContent = Object.keys(aspectRatioList[this.listIdx]);\r\n               });\r\n               container.prepend(aspectRatioBtn);\r\n            }\r\n            if (user_settings.player_buttons_custom_items?.includes(\'watch-later\')) {\r\n               NOVA.waitSelector(\'.ytp-watch-later-button\')\r\n                  .then(watchLaterDefault => {\r\n                     NOVA.css.push(\r\n                        `.${SELECTOR_BTN_CLASS_NAME} .ytp-spinner-container {\r\n                           position: relative;\r\n                           top: 0;\r\n                           left: 0;\r\n                           scale: .5;\r\n                           margin: 0;\r\n                        }\r\n                        .${SELECTOR_BTN_CLASS_NAME}.watch-later-btn svg {\r\n                           scale: .85;\r\n                        }`);\r\n                     const watchLaterBtn = document.createElement(\'button\');\r\n                     watchLaterBtn.className = `ytp-button ${SELECTOR_BTN_CLASS_NAME} watch-later-btn`;\r\n                     watchLaterBtn.setAttribute(\'tooltip\', \'Watch later\');\r\n                     renderIcon();\r\n                     watchLaterBtn.addEventListener(\'click\', () => {\r\n                        watchLaterDefault.click();\r\n                        renderIcon();\r\n                        const waitStatus = setInterval(() => {\r\n                           if (watchLaterDefault.querySelector(\'svg\')) {\r\n                              clearInterval(waitStatus);\r\n                              renderIcon();\r\n                           }\r\n                        }, 100);\r\n                     });\r\n                     [...document.getElementsByClassName(SELECTOR_BTN_CLASS_NAME)].pop()\r\n                        ?.after(watchLaterBtn);\r\n                     function renderIcon() {\r\n                        watchLaterBtn.innerHTML = watchLaterDefault.querySelector(\'.ytp-watch-later-icon\')?.innerHTML;\r\n                     }\r\n                  });\r\n            }\r\n            if (user_settings.player_buttons_custom_items?.includes(\'card-switch\')\r\n               && !user_settings.player_hide_elements?.includes(\'videowall_endscreen\')\r\n               && !user_settings.player_hide_elements?.includes(\'card_endscreen\')\r\n            ) {\r\n               const\r\n                  cardAttrName = \'nova-hide-endscreen\',\r\n                  cardBtn = document.createElement(\'button\');\r\n               NOVA.css.push(\r\n                  `#movie_player[${cardAttrName}] .videowall-endscreen,\r\n                  #movie_player[${cardAttrName}] .ytp-pause-overlay,\r\n                  #movie_player[${cardAttrName}] [class^=\"ytp-ce-\"] {\r\n                     display: none !important;\r\n                  }`);\r\n               cardBtn.className = `ytp-button ${SELECTOR_BTN_CLASS_NAME}`;\r\n               cardBtn.innerHTML = createSVG();\r\n               if (user_settings.player_buttons_custom_card_switch) {\r\n                  switchState(movie_player.toggleAttribute(cardAttrName));\r\n               }\r\n               cardBtn.addEventListener(\'click\', () => switchState(movie_player.toggleAttribute(cardAttrName)));\r\n               function switchState(state = required()) {\r\n                  cardBtn.innerHTML = createSVG(state)\r\n                  cardBtn.setAttribute(\'tooltip\', `The cards are currently ${state ? \'hidden\' : \'showing\'}`);\r\n               }\r\n               function createSVG(alt) {\r\n                  const svg = document.createElement(\'svg\');\r\n                  svg.setAttribute(\'width\', \'100%\');\r\n                  svg.setAttribute(\'height\', \'100%\');\r\n                  svg.setAttribute(\'viewBox\', \'-200 0 912 512\');\r\n                  const g = document.createElement(\'g\');\r\n                  g.setAttribute(\'fill\', \'currentColor\');\r\n                  g.innerHTML = alt\r\n                     ? \'<path d=\"M 409 57.104 C 407.625 57.641, 390.907 73.653, 371.848 92.687 L 337.196 127.293 323.848 120.738 C 301.086 109.561, 283.832 103.994, 265.679 101.969 C 217.447 96.591, 148.112 134.037, 59.026 213.577 C 40.229 230.361, 4.759 265.510, 2.089 270 C -0.440 274.252, -0.674 281.777, 1.575 286.516 C 4.724 293.153, 67.054 352.112, 89.003 369.217 L 92.490 371.934 63.330 401.217 C 37.873 426.781, 34.079 430.988, 33.456 434.346 C 31.901 442.720, 38.176 452.474, 46.775 455.051 C 56.308 457.907, 41.359 471.974, 244.317 269.173 C 350.152 163.421, 429.960 82.914, 431.067 80.790 C 436.940 69.517, 428.155 55.840, 415.185 56.063 C 413.158 56.098, 410.375 56.566, 409 57.104 M 245.500 137.101 C 229.456 139.393, 201.143 151.606, 177.500 166.433 C 151.339 182.839, 120.778 206.171, 89.574 233.561 C 72.301 248.723, 42 277.649, 42 278.977 C 42 280.637, 88.281 323.114, 108.367 339.890 L 117.215 347.279 139.209 325.285 L 161.203 303.292 159.601 293.970 C 157.611 282.383, 157.570 272.724, 159.465 261.881 C 165.856 225.304, 193.011 195.349, 229.712 184.389 C 241.299 180.929, 261.648 179.996, 272.998 182.405 L 280.496 183.996 295.840 168.652 L 311.183 153.309 303.342 149.583 C 292.100 144.242, 277.007 139.186, 267.205 137.476 C 257.962 135.865, 254.565 135.806, 245.500 137.101 M 377.500 163.164 C 374.231 164.968, 369.928 169.297, 368.295 172.423 C 366.203 176.431, 366.351 184.093, 368.593 187.889 C 369.597 189.587, 375.944 195.270, 382.699 200.516 C 406.787 219.226, 444.129 252.203, 462.500 270.989 L 470.500 279.170 459 290.204 C 374.767 371.030, 302.827 418.200, 259.963 420.709 C 239.260 421.921, 213.738 412.918, 179.575 392.352 C 167.857 385.298, 166.164 384.571, 161.448 384.571 C 154.702 384.571, 149.091 388.115, 146.121 394.250 C 143.531 399.600, 143.472 403.260, 145.890 408.500 C 148.270 413.656, 150.468 415.571, 162 422.535 C 198.520 444.590, 230.555 455.992, 256 455.992 C 305.062 455.992, 376.663 414.097, 462 335.458 C 483.584 315.567, 509.652 289.051, 510.931 285.685 C 512.694 281.042, 512.218 273.876, 509.889 270 C 507.494 266.017, 484.252 242.741, 463.509 223.552 C 437.964 199.922, 398.967 167.566, 391.300 163.639 C 387.656 161.773, 380.470 161.526, 377.500 163.164 M 235.651 219.459 C 231.884 220.788, 226.369 223.351, 223.395 225.153 C 216.405 229.389, 206.759 239.019, 202.502 246.010 C 198.959 251.828, 193.677 266.197, 194.194 268.611 C 194.372 269.437, 205.637 258.890, 220.993 243.519 C 249.683 214.801, 249.910 214.427, 235.651 219.459 M 316.962 223.250 C 313.710 224.890, 311.876 226.720, 310.200 230 C 307.188 235.893, 307.781 240.006, 313.805 255 C 317.867 265.109, 318.470 267.589, 318.790 275.500 C 319.554 294.378, 313.786 309.236, 300.522 322.557 C 287.282 335.854, 274.164 341.408, 256 341.408 C 244.216 341.408, 238.392 340.027, 226.837 334.489 C 214.541 328.596, 204.996 330.563, 200.250 339.966 C 191.301 357.697, 210.339 372.220, 247.484 375.998 C 301.141 381.456, 350.063 339.760, 353.664 285.500 C 354.618 271.136, 351.039 249.928, 345.577 237.579 C 342.933 231.601, 337.061 224.600, 332.875 222.435 C 328.782 220.319, 322.095 220.661, 316.962 223.250\" fill-rule=\"evenodd\" />\'\r\n                     : `<path d=\"M 377.5 163.164 C 374.231 164.968 375.944 195.27 382.699 200.516 C 406.787 219.226 444.129 252.203 462.5 270.989 L 470.5 279.17 L 459 290.204 C 374.767 371.03 302.827 418.2 259.963 420.709 C 239.26 421.921 213.738 412.918 179.575 392.352 C 167.857 385.298 166.164 384.571 161.448 384.571 C 154.702 384.571 149.091 388.115 146.121 394.25 C 143.531 399.6 143.472 403.26 145.89 408.5 C 148.27 413.656 150.468 415.571 162 422.535 C 198.52 444.59 230.555 455.992 256 455.992 C 305.062 455.992 376.663 414.097 462 335.458 C 483.584 315.567 509.652 289.051 510.931 285.685 C 512.694 281.042 512.218 273.876 509.889 270 C 507.494 266.017 484.252 242.741 463.509 223.552 C 437.964 199.922 398.967 167.566 391.3 163.639 C 387.656 161.773 380.47 161.526 377.5 163.164 M 316.962 223.25 C 313.71 224.89 311.876 226.72 310.2 230 C 307.188 235.893 307.781 240.006 313.805 255 C 317.867 265.109 318.47 267.589 318.79 275.5 C 319.554 294.378 313.786 309.236 300.522 322.557 C 287.282 335.854 274.164 341.408 256 341.408 C 244.216 341.408 238.392 340.027 226.837 334.489 C 214.541 328.596 204.996 330.563 200.25 339.966 C 191.301 357.697 210.339 372.22 247.484 375.998 C 301.141 381.456 350.063 339.76 353.664 285.5 C 354.618 271.136 351.039 249.928 345.577 237.579 C 342.933 231.601 337.061 224.6 332.875 222.435 C 328.782 220.319 322.095 220.661 316.962 223.25\"></path>\r\n                     <path d=\"M 377.487 163.483 C 374.218 165.287 369.915 169.616 368.282 172.742 C 366.19 176.75 366.338 184.412 368.58 188.208 C 369.584 189.906 375.931 195.589 382.686 200.835 C 406.774 219.545 444.116 252.522 462.487 271.308 L 470.487 279.489 L 458.987 290.523 C 374.754 371.349 302.814 418.519 259.95 421.028 C 239.247 422.24 213.725 413.237 179.562 392.671 C 167.844 385.617 166.151 384.89 161.435 384.89 C 154.689 384.89 149.078 388.434 146.108 394.569 C 143.518 399.919 143.459 403.579 145.877 408.819 C 148.257 413.975 150.455 415.89 161.987 422.854 C 198.507 444.909 230.542 456.311 255.987 456.311 C 305.049 456.311 376.65 414.416 461.987 335.777 C 483.571 315.886 509.639 289.37 510.918 286.004 C 512.681 281.361 512.205 274.195 509.876 270.319 C 507.481 266.336 484.239 243.06 463.496 223.871 C 437.951 200.241 398.954 167.885 391.287 163.958 C 387.643 162.092 380.457 161.845 377.487 163.483 M 316.949 223.569 C 313.697 225.209 311.863 227.039 310.187 230.319 C 307.175 236.212 307.768 240.325 313.792 255.319 C 317.854 265.428 318.457 267.908 318.777 275.819 C 319.541 294.697 313.773 309.555 300.509 322.876 C 287.269 336.173 274.151 341.727 255.987 341.727 C 244.203 341.727 238.379 340.346 226.824 334.808 C 214.528 328.915 204.983 330.882 200.237 340.285 C 191.288 358.016 210.326 372.539 247.471 376.317 C 301.128 381.775 350.05 340.079 353.651 285.819 C 354.605 271.455 351.026 250.247 345.564 237.898 C 342.92 231.92 337.048 224.919 332.862 222.754 C 328.769 220.638 322.082 220.98 316.949 223.569\" transform=\"matrix(-1, 0, 0, -1, 512.000305, 558.092285)\"></path>`;\r\n                  svg.append(g);\r\n                  return svg.outerHTML;\r\n               }\r\n               container.prepend(cardBtn);\r\n            }\r\n            if (user_settings.player_buttons_custom_items?.includes(\'quick-quality\')) {\r\n               const\r\n                  SELECTOR_QUALITY_CLASS_NAME = \'nova-quick-quality\',\r\n                  SELECTOR_QUALITY = \'.\' + SELECTOR_QUALITY_CLASS_NAME,\r\n                  qualityContainerBtn = document.createElement(\'a\'),\r\n                  SELECTOR_QUALITY_LIST_ID = SELECTOR_QUALITY_CLASS_NAME + \'-list\',\r\n                  SELECTOR_QUALITY_LIST = \'#\' + SELECTOR_QUALITY_LIST_ID,\r\n                  listQuality = document.createElement(\'ul\'),\r\n                  SELECTOR_QUALITY_TITLE_ID = SELECTOR_QUALITY_CLASS_NAME + \'-title\',\r\n                  qualityBtn = document.createElement(\'span\'),\r\n                  qualityFormatList = {\r\n                     highres: { label: \'4320p\', badge: \'8K\' },\r\n                     hd2880: { label: \'2880p\', badge: \'5K\' },\r\n                     hd2160: { label: \'2160p\', badge: \'4K\' },\r\n                     hd1440: { label: \'1440p\', badge: \'QHD\' },\r\n                     hd1080: { label: \'1080p\', badge: \'FHD\' },\r\n                     hd720: { label: \'720p\', badge: \'ᴴᴰ\' },\r\n                     large: { label: \'480p\' },\r\n                     medium: { label: \'360p\' },\r\n                     small: { label: \'240p\' },\r\n                     tiny: { label: \'144p\' },\r\n                     auto: { label: \'auto\' },\r\n                  };\r\n               NOVA.css.push(\r\n                  SELECTOR_QUALITY + ` {\r\n                     overflow: visible !important;\r\n                     position: relative;\r\n                     text-align: center !important;\r\n                     vertical-align: top;\r\n                     font-weight: bold;\r\n                  }\r\n                  ${SELECTOR_QUALITY_LIST} {\r\n                     position: absolute;\r\n                     bottom: 2.5em !important;\r\n                     left: -2.2em;\r\n                     list-style: none;\r\n                     padding-bottom: 1.5em !important;\r\n                     z-index: ${1 + Math.max(NOVA.css.getValue(\'.ytp-progress-bar\', \'z-index\'), 31)};\r\n                  }\r\n                  \r\n                  html[data-cast-api-enabled] ${SELECTOR_QUALITY_LIST} {\r\n                     margin: 0;\r\n                     padding: 0;\r\n                     bottom: 3.3em;\r\n                     \r\n                  }\r\n                  ${SELECTOR_QUALITY}:not(:hover) ${SELECTOR_QUALITY_LIST} {\r\n                     display: none;\r\n                  }\r\n                  ${SELECTOR_QUALITY_LIST} li {\r\n                     cursor: pointer;\r\n                     white-space: nowrap;\r\n                     line-height: 1.4;\r\n                     background: rgba(28, 28, 28, 0.9);\r\n                     margin: .3em 0;\r\n                     padding: .5em 3em;\r\n                     border-radius: .3em;\r\n                     color: #fff;\r\n                  }\r\n                  ${SELECTOR_QUALITY_LIST} li .quality-menu-item-label-badge {\r\n                     position: absolute;\r\n                     right: 1em;\r\n                     width: 1.7em;\r\n                  }\r\n                  ${SELECTOR_QUALITY_LIST} li.active { background: #720000; }\r\n                  ${SELECTOR_QUALITY_LIST} li.disable { color: #666; }\r\n                  ${SELECTOR_QUALITY_LIST} li:hover:not(.active) { background: #c00; }`);\r\n               qualityContainerBtn.className = `ytp-button ${SELECTOR_BTN_CLASS_NAME} ${SELECTOR_QUALITY_CLASS_NAME}`;\r\n               qualityBtn.id = SELECTOR_QUALITY_TITLE_ID;\r\n               qualityBtn.textContent = qualityFormatList[movie_player.getPlaybackQuality()]?.label || \'[out of range]\';\r\n               listQuality.id = SELECTOR_QUALITY_LIST_ID;\r\n               movie_player.addEventListener(\'onPlaybackQualityChange\', quality => {\r\n                  document.getElementById(SELECTOR_QUALITY_TITLE_ID)\r\n                     .textContent = qualityFormatList[quality]?.label || \'[out of range]\';\r\n               });\r\n               qualityContainerBtn.prepend(qualityBtn);\r\n               qualityContainerBtn.append(listQuality);\r\n               container.prepend(qualityContainerBtn);\r\n               fillQualityMenu();\r\n               NOVA.videoElement?.addEventListener(\'canplay\', fillQualityMenu);\r\n               function fillQualityMenu() {\r\n                  if (qualityList = document.getElementById(SELECTOR_QUALITY_LIST_ID)) {\r\n                     qualityList.innerHTML = \'\';\r\n                     movie_player.getAvailableQualityLevels()\r\n                        .forEach(quality => {\r\n                           const qualityItem = document.createElement(\'li\');\r\n                           if (qualityData = qualityFormatList[quality]) {\r\n                              qualityItem.textContent = qualityData.label;\r\n                              if (badge = qualityData.badge) {\r\n                                 qualityItem.insertAdjacentHTML(\'beforeend\',\r\n                                    `<span class=\"quality-menu-item-label-badge\">${badge}</span>`);\r\n                              }\r\n                              if (movie_player.getPlaybackQuality() == quality) {\r\n                                 qualityItem.className = \'active\';\r\n                              } else {\r\n                                 const maxWidth = (NOVA.currentPage == \'watch\') ? window.screen.width : window.innerWidth;\r\n                                 if (+(qualityData.label.replace(/[^0-9]/g, \'\') || 0) <= (maxWidth * 1.3)) {\r\n                                    qualityItem.addEventListener(\'click\', () => {\r\n                                       movie_player.setPlaybackQualityRange(quality, quality);\r\n                                       if (quality == \'auto\') return;\r\n                                       qualityList.innerHTML = \'\';\r\n                                    });\r\n                                 }\r\n                                 else {\r\n                                    qualityItem.className = \'disable\';\r\n                                    qualityItem.title = \'Max (window viewport + 30%)\';\r\n                                 }\r\n                              }\r\n                              qualityList.append(qualityItem);\r\n                           }\r\n                        });\r\n                  }\r\n               }\r\n            }\r\n            if (user_settings.player_buttons_custom_items?.includes(\'clock\')) {\r\n               const clockEl = document.createElement(\'span\');\r\n               clockEl.className = \'ytp-time-display\';\r\n               clockEl.title = \'Now time\';\r\n               container.prepend(clockEl);\r\n               setInterval(() => {\r\n                  if (document.visibilityState == \'hidden\'\r\n                     || movie_player.classList.contains(\'ytp-autohide\')\r\n                  ) {\r\n                     return;\r\n                  }\r\n                  const time = new Date().toTimeString().slice(0, 8);\r\n                  clockEl.textContent = time;\r\n               }, 1000);\r\n            }\r\n            if (user_settings.player_buttons_custom_items?.includes(\'toggle-speed\')) {\r\n               const\r\n                  speedBtn = document.createElement(\'a\'),\r\n                  hotkey = user_settings.player_buttons_custom_hotkey_toggle_speed || \'a\',\r\n                  defaultRateText = \'1x\',\r\n                  genTooltip = () => `Switch to ${NOVA.videoElement.playbackRate}>${speedBtn.textContent} (${hotkey})`;\r\n               let rateOrig = {};\r\n               speedBtn.className = `ytp-button ${SELECTOR_BTN_CLASS_NAME}`;\r\n               speedBtn.style.textAlign = \'center\';\r\n               speedBtn.style.fontWeight = \'bold\';\r\n               speedBtn.innerHTML = defaultRateText;\r\n               speedBtn.setAttribute(\'tooltip\', genTooltip());\r\n               document.addEventListener(\'keyup\', evt => {\r\n                  if ([\'input\', \'textarea\', \'select\'].includes(evt.target.localName) || evt.target.isContentEditable) return;\r\n                  if (evt.key === hotkey) {\r\n                     switchRate();\r\n                  }\r\n               });\r\n               speedBtn.addEventListener(\'click\', switchRate);\r\n               function switchRate() {\r\n                  if (Object.keys(rateOrig).length) {\r\n                     playerRate.set(rateOrig);\r\n                     rateOrig = {};\r\n                     speedBtn.innerHTML = defaultRateText;\r\n                  }\r\n                  else {\r\n                     rateOrig = (movie_player && NOVA.videoElement.playbackRate % .25) === 0\r\n                        ? { \'default\': movie_player.getPlaybackRate() }\r\n                        : { \'html5\': NOVA.videoElement.playbackRate };\r\n                     let resetRate = Object.assign({}, rateOrig);\r\n                     resetRate[Object.keys(resetRate)[0]] = 1;\r\n                     playerRate.set(resetRate);\r\n                     speedBtn.textContent = rateOrig[Object.keys(rateOrig)[0]] + \'x\';\r\n                  }\r\n                  speedBtn.setAttribute(\'tooltip\', genTooltip());\r\n               }\r\n               const playerRate = {\r\n                  set(obj) {\r\n                     if (obj.hasOwnProperty(\'html5\') || !movie_player) {\r\n                        NOVA.videoElement.playbackRate = obj.html5;\r\n                     }\r\n                     else {\r\n                        movie_player.setPlaybackRate(obj.default);\r\n                     }\r\n                  },\r\n               };\r\n               container.prepend(speedBtn);\r\n               visibilitySwitch();\r\n               NOVA.videoElement?.addEventListener(\'ratechange\', visibilitySwitch);\r\n               NOVA.videoElement?.addEventListener(\'loadeddata\', () => {\r\n                  rateOrig = {};\r\n                  speedBtn.textContent = defaultRateText;\r\n                  visibilitySwitch();\r\n               });\r\n               function visibilitySwitch() {\r\n                  if (!Object.keys(rateOrig).length) {\r\n                     speedBtn.style.display = (NOVA.videoElement?.playbackRate === 1) ? \'none\' : \'\';\r\n                  }\r\n               }\r\n            }\r\n         });\r\n   },\r\n   options: {\r\n      player_buttons_custom_items: {\r\n         _tagName: \'select\',\r\n         label: \'Buttons\',\r\n         \'label:zh\': \'纽扣\',\r\n         \'label:ja\': \'ボタン\',\r\n         \'label:ko\': \'버튼\',\r\n         \'label:id\': \'Tombol\',\r\n         \'label:es\': \'Botones\',\r\n         \'label:pt\': \'Botões\',\r\n         \'label:fr\': \'Boutons\',\r\n         \'label:it\': \'Bottoni\',\r\n         \'label:de\': \'Tasten\',\r\n         \'label:pl\': \'Przyciski\',\r\n         \'label:ua\': \'Кнопки\',\r\n         title: \'[Ctrl+Click] to select several\',\r\n         \'title:zh\': \'[Ctrl+Click] 选择多个\',\r\n         \'title:ja\': \'「Ctrl+Click」して、いくつかを選択します\',\r\n         \'title:ko\': \'[Ctrl+Click] 여러 선택\',\r\n         \'title:id\': \'[Ctrl+Klik] untuk memilih beberapa\',\r\n         \'title:es\': \'[Ctrl+Click] para seleccionar varias\',\r\n         \'title:pt\': \'[Ctrl+Click] para selecionar vários\',\r\n         \'title:fr\': \'[Ctrl+Click] pour sélectionner plusieurs\',\r\n         \'title:it\': \'[Ctrl+Clic] per selezionarne diversi\',\r\n         \'title:de\': \'[Ctrl+Click] um mehrere auszuwählen\',\r\n         \'title:pl\': \'Ctrl+kliknięcie, aby zaznaczyć kilka\',\r\n         \'title:ua\': \'[Ctrl+Click] щоб обрати декілька\',\r\n         multiple: null,\r\n         required: true,\r\n         size: 7,\r\n         options: [\r\n            {\r\n               label: \'clock\', value: \'clock\',\r\n            },\r\n            {\r\n               label: \'quick quality\', value: \'quick-quality\',\r\n               \'label:zh\': \'质量\',\r\n               \'label:ja\': \'品質\',\r\n               \'label:ko\': \'품질\',\r\n               \'label:id\': \'kualitas\',\r\n               \'label:es\': \'calidad\',\r\n               \'label:pt\': \'qualidade\',\r\n               \'label:fr\': \'qualité\',\r\n               \'label:it\': \'qualità\',\r\n               \'label:de\': \'qualität\',\r\n               \'label:pl\': \'jakość\',\r\n               \'label:ua\': \'якість\',\r\n            },\r\n            {\r\n               label: \'toggle speed\', value: \'toggle-speed\',\r\n               \'label:zh\': \'切换速度\',\r\n               \'label:ja\': \'トグル速度\',\r\n               \'label:ko\': \'토글 속도\',\r\n               \'label:id\': \'beralih kecepatan\',\r\n               \'label:es\': \'alternar velocidad\',\r\n               \'label:pt\': \'velocidade de alternância\',\r\n               \'label:fr\': \'basculer la vitesse\',\r\n               \'label:it\': \'alternare la velocità\',\r\n               \'label:de\': \'geschwindigkeit umschalten\',\r\n               \'label:pl\': \'szybkość\',\r\n               \'label:ua\': \'швидкість\',\r\n            },\r\n            {\r\n               label: \'card-switch\', value: \'card-switch\',\r\n            },\r\n            {\r\n               label: \'screenshot\', value: \'screenshot\',\r\n               \'label:zh\': \'截屏\',\r\n               \'label:ja\': \'スクリーンショット\',\r\n               \'label:ko\': \'스크린샷\',\r\n               \'label:id\': \'tangkapan layar\',\r\n               \'label:es\': \'captura de pantalla\',\r\n               \'label:pt\': \'captura de tela\',\r\n               \'label:fr\': \"capture d\'écran\",\r\n               \'label:it\': \'immagine dello schermo\',\r\n               \'label:de\': \'bildschirmfoto\',\r\n               \'label:ua\': \'фото екрану\',\r\n            },\r\n            {\r\n               label: \'picture-in-picture\', value: \'picture-in-picture\',\r\n               \'label:pl\': \'obraz w obrazie\',\r\n               \'label:ua\': \'картинка в картинці\',\r\n            },\r\n            {\r\n               label: \'popup\', value: \'popup\',\r\n               \'label:zh\': \'弹出式播放器\',\r\n               \'label:ja\': \'ポップアッププレーヤー\',\r\n               \'label:ko\': \'썸네일\',\r\n               \'label:id\': \'muncul\',\r\n               \'label:pt\': \'jogador pop-up\',\r\n               \'label:fr\': \'lecteur contextuel\',\r\n               \'label:it\': \'apparire\',\r\n               \'label:de\': \'auftauchen\',\r\n               \'label:pl\': \'w okienku\',\r\n               \'label:ua\': \'спливаюче повідомлення\',\r\n            },\r\n            {\r\n               label: \'rotate\', value: \'rotate\',\r\n               \'label:zh\': \'旋转\',\r\n               \'label:ja\': \'回転する\',\r\n               \'label:ko\': \'회전\',\r\n               \'label:id\': \'memutar\',\r\n               \'label:es\': \'girar\',\r\n               \'label:pt\': \'girar\',\r\n               \'label:fr\': \'tourner\',\r\n               \'label:it\': \'ruotare\',\r\n               \'label:de\': \'drehen\',\r\n               \'label:pl\': \'obróć\',\r\n               \'label:ua\': \'повернути\',\r\n            },\r\n            {\r\n               label: \'aspect-ratio\', value: \'aspect-ratio\',\r\n               \'label:ua\': \'співвідношення сторін\',\r\n            },\r\n            {\r\n               label: \'watch later\', value: \'watch-later\',\r\n               \'label:ua\': \'переглянути пізніше\',\r\n            },\r\n            {\r\n               label: \'thumbnail\', value: \'thumbnail\',\r\n               \'label:zh\': \'缩略图\',\r\n               \'label:ja\': \'サムネイル\',\r\n               \'label:ko\': \'썸네일\',\r\n               \'label:es\': \'miniatura\',\r\n               \'label:pt\': \'captura de tela\',\r\n               \'label:fr\': \'la vignette\',\r\n               \'label:it\': \'miniatura\',\r\n               \'label:de\': \'bildschirmfoto\',\r\n               \'label:pl\': \'miniaturka\',\r\n               \'label:ua\': \'мініатюра\',\r\n            },\r\n         ],\r\n      },\r\n      player_buttons_custom_popup_width: {\r\n         _tagName: \'input\',\r\n         label: \'Player window size aspect ratio\',\r\n         \'label:zh\': \'播放器窗口大小纵横比\',\r\n         \'label:ja\': \'プレーヤーのウィンドウサイズのアスペクト比\',\r\n         \'label:ko\': \'플레이어 창 크기 종횡비\',\r\n         \'label:id\': \'Rasio aspek ukuran jendela pemutar\',\r\n         \'label:es\': \'Relación de aspecto del tamaño de la ventana del reproductor\',\r\n         \'label:pt\': \'Proporção do tamanho da janela do jogador\',\r\n         \'label:fr\': \"Rapport d\'aspect de la taille de la fenêtre du lecteur\",\r\n         \'label:it\': \'Proporzioni della dimensione della finestra del lettore\',\r\n         \'label:de\': \'Seitenverhältnis der Player-Fenstergröße\',\r\n         \'label:pl\': \'Rozmiar okna odtwarzacza\',\r\n         \'label:ua\': \'Співвідношення розміру вікна відтворювача\',\r\n         type: \'number\',\r\n         title: \'Less value - larger size\',\r\n         \'title:zh\': \'较小的值 - 较大的尺寸\',\r\n         \'title:ja\': \'小さい値-大きいサイズ\',\r\n         \'title:ko\': \'더 작은 값 - 더 큰 크기\',\r\n         \'title:id\': \'Nilai lebih kecil - ukuran lebih besar\',\r\n         \'title:es\': \'Valor más pequeño - tamaño más grande\',\r\n         \'title:pt\': \'Valor menor - tamanho maior\',\r\n         \'title:fr\': \'Plus petite valeur - plus grande taille\',\r\n         \'title:it\': \'Meno valore - dimensioni maggiori\',\r\n         \'title:de\': \'Kleiner Wert - größere Größe\',\r\n         \'title:pl\': \'Mniejsza wartość - większy rozmiar\',\r\n         \'title:ua\': \'Менше значення - більший розмір\',\r\n         placeholder: \'1.5-4\',\r\n         step: 0.1,\r\n         min: 1.5,\r\n         max: 4,\r\n         value: 2.5,\r\n         \'data-dependent\': { \'player_buttons_custom_items\': [\'popup\'] },\r\n      },\r\n      player_buttons_custom_hotkey_toggle_speed: {\r\n         _tagName: \'select\',\r\n         label: \'Hotkey toggle speed\',\r\n         \'label:zh\': \'热键切换速度\',\r\n         \'label:ja\': \'速度を切り替えるためのホットボタン\',\r\n         \'label:ko\': \'단축키 토글 속도\',\r\n         \'label:id\': \'Kecepatan beralih tombol pintas\',\r\n         \'label:es\': \'Velocidad de cambio de teclas de acceso rápido\',\r\n         \'label:pt\': \'Velocidade de alternância da tecla de atalho\',\r\n         \'label:fr\': \'Vitesse de basculement des raccourcis clavier\',\r\n         \'label:it\': \'Tasto di scelta rapida per attivare/disattivare la velocità\',\r\n         \'label:de\': \'Hotkey-Umschaltgeschwindigkeit\',\r\n         \'label:pl\': \'Skrót przełączania prędkości\',\r\n         \'label:ua\': \'Гаряча клавіша увімкнути швидкість\',\r\n         options: [\r\n            { label: \'A\', value: \'a\', selected: true },\r\n            \'b\', \'c\', \'d\', \'e\', \'f\', \'g\', \'h\', \'i\', \'j\', \'k\', \'l\', \'m\', \'n\', \'o\', \'p\', \'q\', \'r\', \'s\', \'t\', \'u\', \'v\', \'w\', \'x\', \'y\', \'z\', \']\', \'[\', \'+\', \'-\', \',\', \'.\', \'/\', \'<\', \';\', \'\\\\\'\r\n         ],\r\n         \'data-dependent\': { \'player_buttons_custom_items\': [\'toggle-speed\'] },\r\n      },\r\n      player_buttons_custom_hotkey_rotate: {\r\n         _tagName: \'select\',\r\n         label: \'Hotkey rotate\',\r\n         options: [\r\n            { label: \'R\', value: \'r\', selected: true },\r\n            \'a\', \'b\', \'c\', \'d\', \'e\', \'f\', \'g\', \'h\', \'i\', \'j\', \'k\', \'l\', \'m\', \'n\', \'o\', \'p\', \'q\', \'s\', \'t\', \'u\', \'v\', \'w\', \'x\', \'y\', \'z\', \']\', \'[\', \'+\', \'-\', \',\', \'.\', \'/\', \'<\', \';\', \'\\\\\'\r\n         ],\r\n         \'data-dependent\': { \'player_buttons_custom_items\': [\'rotate\'] },\r\n      },\r\n      player_buttons_custom_card_switch: {\r\n         _tagName: \'select\',\r\n         label: \'Default card state\',\r\n         options: [\r\n            {\r\n               label: \'show\', value: false, selected: true,\r\n            },\r\n            {\r\n               label: \'hide\', value: true,\r\n            },\r\n         ],\r\n         \'data-dependent\': { \'player_buttons_custom_items\': [\'card-switch\'] },\r\n      },\r\n      player_buttons_custom_screenshot: {\r\n         _tagName: \'select\',\r\n         label: \'Default screenshot format\',\r\n         options: [\r\n            {\r\n               label: \'png\', value: \'png\', selected: true,\r\n            },\r\n            {\r\n               label: \'jpg\', value: \'jpg\',\r\n            },\r\n         ],\r\n         \'data-dependent\': { \'player_buttons_custom_items\': [\'screenshot\'] },\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'video-unblock-region\',\r\n   title: \'Try unblock if video not available in your country\',\r\n   \'title:zh\': \'尝试解锁您所在地区的视频\',\r\n   \'title:ja\': \'お住まいの地域の動画のブロックを解除してみてください\',\r\n   \'title:ko\': \'해당 지역의 동영상 차단을 해제해 보세요\',\r\n   \'title:id\': \'Coba buka blokir jika video tidak tersedia di negara Anda\',\r\n   \'title:es\': \'Intenta desbloquear videos para tu región\',\r\n   \'title:pt\': \'Tente desbloquear vídeos para sua região\',\r\n   \'title:fr\': \'Débloquer la vidéo de la région\',\r\n   \'title:it\': \'Prova a sbloccare se il video non è disponibile nel tuo paese\',\r\n   \'title:de\': \'Versuchen Sie, Videos für Ihre Region zu entsperren\',\r\n   \'title:pl\': \'Spróbuj odblokować, jeśli film nie jest dostępny w Twoim kraju\',\r\n   \'title:ua\': \'Спробувати розблокувати якщо відео не доступне у країні\',\r\n   run_on_pages: \'watch, -mobile\',\r\n   section: \'player\',\r\n   desc: \'Attempt fix \"is not available in your country\"\',\r\n   \'desc:zh\': \'尝试修复“在您的国家不可用”\',\r\n   \'desc:ja\': \'「お住まいの国では利用できません」という修正を試みる\',\r\n   \'desc:ko\': \'수정 시도 \"해당 국가에서는 사용할 수 없습니다\"\',\r\n   \'desc:id\': \'Coba perbaiki \"tidak tersedia di negara Anda\"\',\r\n   \'desc:es\': \'Intento de corrección \"no está disponible en su país\"\',\r\n   \'desc:pt\': \'Tentativa de correção \"não está disponível em seu país\"\',\r\n   \'desc:fr\': \'Tentative de correction \"n\\\'est pas disponible dans votre pays\"\',\r\n   \'desc:it\': \'Tentativo di correzione \"non è disponibile nel tuo paese\"\',\r\n   \'desc:de\': \'Versuchen Sie, \"ist in Ihrem Land nicht verfügbar\" zu beheben\',\r\n   \'desc:pl\': \'Próba naprawienia nie jest dostępna w Twoim kraju\',\r\n   \'desc:ua\': \'Спроба розблокувати доступ до відео\',\r\n   _runtime: user_settings => {\r\n      NOVA.waitSelector(\'ytd-watch-flexy[player-unavailable]\', { stop_on_page_change: true })\r\n         .then(el => el.querySelector(\'yt-player-error-message-renderer #button.yt-player-error-message-renderer button\') || redirect());\r\n      function redirect(new_tab_url) {\r\n         if (new_tab_url) {\r\n            window.open(`${location.protocol}//${user_settings.video_unblock_region_domain || \'hooktube.com\'}${location.port ? \':\' + location.port : \'\'}/watch?v=` + movie_player.getVideoData().video_id);\r\n         }\r\n         else {\r\n            location.hostname = user_settings.video_unblock_region_domain || \'hooktube.com\';\r\n         }\r\n         if (user_settings.video_unblock_region_open_map) {\r\n            window.open(`https://watannetwork.com/tools/blocked/#url=${NOVA.queryURL.get(\'v\')}:~:text=Allowed%20countries`);\r\n         }\r\n      }\r\n   },\r\n   options: {\r\n      video_unblock_region_domain: {\r\n         _tagName: \'input\',\r\n         label: \'URL\',\r\n         type: \'text\',\r\n         list: \'video_unblock_region_domain_help_list\',\r\n         pattern: \"^[a-zA-Z0-9-]{2,20}\\.[a-zA-Z]{2,5}$\",\r\n         title: \'without \"https://\"\',\r\n         \'title:zh\': \'没有“https://”\',\r\n         \'title:ja\': \'「https://」なし\',\r\n         \'title:ko\': \'\"https://\" 없이\',\r\n         \'title:id\': \'tanpa \"https://\"\',\r\n         \'title:es\': \'sin \"https://\"\',\r\n         \'title:pt\': \'sem \"https://\"\',\r\n         \'title:fr\': \'sans \"https://\"\',\r\n         \'title:it\': \'senza \"https://\"\',\r\n         \'title:de\': \'ohne \"https://\"\',\r\n         \'title:pl\': \'bez „https://”\',\r\n         \'title:ua\': \'без \"https://\"\',\r\n         placeholder: \'hooktube.com\',\r\n         minlength: 5,\r\n         maxlength: 20,\r\n         required: true,\r\n      },\r\n      video_unblock_region_domain_help_list: {\r\n         _tagName: \'datalist\',\r\n         options: [\r\n            { label: \'hooktube.com\', value: \'hooktube.com\' },\r\n            { label: \'clipzag.com\', value: \'clipzag.com\' },\r\n            { label: \'piped.video\', value: \'piped.video\' },\r\n            { label: \'yewtu.be\', value: \'yewtu.be\' },\r\n         ],\r\n      },\r\n      video_unblock_region_open_map: {\r\n         _tagName: \'input\',\r\n         label: \'Open map with availability in regions\',\r\n         \'label:zh\': \'打开地图，显示区域可用性\',\r\n         \'label:ja\': \'地域で利用可能なマップを開く\',\r\n         \'label:ko\': \'지역에서 사용 가능한 지도 열기\',\r\n         \'label:id\': \'Buka peta dengan ketersediaan di wilayah\',\r\n         \'label:es\': \'Abrir mapa con disponibilidad en regiones\',\r\n         \'label:pt\': \'Abrir mapa com disponibilidade nas regiões\',\r\n         \'label:fr\': \'Carte ouverte avec disponibilité dans les régions\',\r\n         \'label:it\': \'Apri la mappa con la disponibilità nelle regioni\',\r\n         \'label:de\': \'Karte mit Verfügbarkeit in Regionen öffnen\',\r\n         \'label:pl\': \'Otwórz mapę z dostępnością w regionach\',\r\n         \'label:ua\': \'Відкрити карту з доступністю в регіонах\',\r\n         type: \'checkbox\',\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'subtitle-style\',\r\n   title: \'Subtitles (captions) style\',\r\n   \'title:zh\': \'字幕样式\',\r\n   \'title:ja\': \'字幕スタイル\',\r\n   \'title:ko\': \'자막 스타일\',\r\n   \'title:id\': \'Gaya subtitel\',\r\n   \'title:es\': \'Estilo de subtítulos\',\r\n   \'title:pt\': \'estilo de legenda\',\r\n   \'title:fr\': \'Style de sous-titre\',\r\n   \'title:it\': \'Stile dei sottotitoli\',\r\n   \'title:de\': \'Untertitelstil\',\r\n   \'title:pl\': \'Styl napisów\',\r\n   \'title:ua\': \'Стиль субтитрів\',\r\n   run_on_pages: \'watch, embed, -mobile\',\r\n   section: \'player\',\r\n   _runtime: user_settings => {\r\n      const SELECTOR = \'.ytp-caption-segment\';\r\n      let css = {}\r\n      if (user_settings.subtitle_transparent) {\r\n         css = {\r\n            \'background\': \'Transparent\',\r\n            \'text-shadow\':\r\n               `rgb(0, 0, 0) 0 0 .1em,\r\n               rgb(0, 0, 0) 0 0 .2em,\r\n               rgb(0, 0, 0) 0 0 .4em`,\r\n         };\r\n      }\r\n      if (user_settings.subtitle_bold) css[\'font-weight\'] = \'bold\';\r\n      if (user_settings.subtitle_fixed) {\r\n         NOVA.css.push(\r\n            `.caption-window {\r\n               margin-bottom: 1px !important;\r\n               bottom: 1% !important;\r\n            }`);\r\n      }\r\n      if (user_settings.subtitle_selectable) {\r\n         NOVA.watchElements({\r\n            selectors: [\r\n               SELECTOR,\r\n               \'#caption-window-1\',\r\n            ]\r\n               .map(i => i + \':not(:empty)\'),\r\n            callback: el => {\r\n               el.addEventListener(\'mousedown\', evt => evt.stopPropagation(), true);\r\n               el.setAttribute(\'draggable\', \'false\');\r\n               el.setAttribute(\'selectable\', \'true\');\r\n               el.style.userSelect = \'text\';\r\n               el.style.WebkitUserSelect = \'text\';\r\n               el.style.cursor = \'text\';\r\n            }\r\n         });\r\n      }\r\n      if (Object.keys(css).length) {\r\n         NOVA.css.push(css, SELECTOR, \'important\');\r\n      }\r\n   },\r\n   options: {\r\n      subtitle_transparent: {\r\n         _tagName: \'input\',\r\n         label: \'Transparent\',\r\n         \'label:zh\': \'透明的\',\r\n         \'label:ja\': \'透明\',\r\n         \'label:ko\': \'투명한\',\r\n         \'label:id\': \'Transparan\',\r\n         \'label:es\': \'Transparentes\',\r\n         \'label:pt\': \'Transparentes\',\r\n         \'label:fr\': \'Transparents\',\r\n         \'label:it\': \'Trasparenti\',\r\n         \'label:de\': \'Transparente\',\r\n         \'label:pl\': \'Przezroczyste\',\r\n         \'label:ua\': \'Прозорі\',\r\n         type: \'checkbox\',\r\n      },\r\n      subtitle_bold: {\r\n         _tagName: \'input\',\r\n         label: \'Bold text\',\r\n         \'label:zh\': \'粗体\',\r\n         \'label:ja\': \'太字\',\r\n         \'label:ko\': \'굵은 텍스트\',\r\n         \'label:id\': \'Teks tebal\',\r\n         \'label:es\': \'Texto en negrita\',\r\n         \'label:pt\': \'Texto em negrito\',\r\n         \'label:fr\': \'Texte en gras\',\r\n         \'label:it\': \'Testo grassetto\',\r\n         \'label:de\': \'Fetter Text\',\r\n         \'label:pl\': \'Tekst pogrubiony\',\r\n         \'label:ua\': \'Жирний текст\',\r\n         type: \'checkbox\',\r\n      },\r\n      subtitle_fixed: {\r\n         _tagName: \'input\',\r\n         label: \'Fixed from below\',\r\n         \'label:zh\': \'从下方固定\',\r\n         \'label:ja\': \'下から固定\',\r\n         \'label:ko\': \'아래에서 고정\',\r\n         \'label:id\': \'Diperbaiki dari bawah\',\r\n         \'label:es\': \'Fijado desde abajo\',\r\n         \'label:pt\': \'Fixo por baixo\',\r\n         \'label:fr\': \'Fixé par le bas\',\r\n         \'label:it\': \'Risolto dal basso\',\r\n         \'label:de\': \'Von unten befestigt\',\r\n         \'label:pl\': \'Przyklejone na dole\',\r\n         \'label:ua\': \'Фіксація знизу\',\r\n         type: \'checkbox\',\r\n         title: \'Preventing captions jumping up/down when pause/resume\',\r\n         \'title:zh\': \'暂停/恢复时防止字幕跳上/跳下\',\r\n         \'title:ja\': \'一時停止/再開時にキャプションが上下にジャンプしないようにする\',\r\n         \'title:ko\': \'일시 중지/다시 시작 시 캡션이 위/아래로 점프하는 것을 방지\',\r\n         \'title:id\': \'Mencegah teks melompat ke atas/bawah saat menjeda/melanjutkan\',\r\n         \'title:es\': \'Evitar que los subtítulos salten hacia arriba/abajo al pausar/reanudar\',\r\n         \'title:pt\': \'Evitando que as legendas subam/descem ao pausar/reiniciar\',\r\n         \'title:fr\': \"Empêcher les sous-titres de sauter vers le haut/bas lors d\'une pause/reprise\",\r\n         \'title:it\': \'Prevenire i sottotitoli che saltano su/giù durante la pausa/ripresa\',\r\n         \'title:de\': \'Verhindern, dass Untertitel beim Anhalten/Fortsetzen nach oben/unten springen\',\r\n         \'title:pl\': \'Zapobieganie przeskakiwaniu napisów w górę/w dół podczas pauzy/wznowienia\',\r\n         \'title:ua\': \'Запобігання стрибкам титрів вгору/вниз під час паузи/продовження\',\r\n      },\r\n      subtitle_selectable: {\r\n         _tagName: \'input\',\r\n         label: \'Make selectable\',\r\n         \'label:zh\': \'使字幕可选\',\r\n         \'label:ja\': \'字幕を選択可能にする\',\r\n         \'label:ko\': \'자막 선택 가능\',\r\n         \'label:id\': \'Jadikan subtitle dapat dipilih\',\r\n         \'label:es\': \'Hacer subtítulos seleccionables\',\r\n         \'label:pt\': \'Tornar as legendas selecionáveis\',\r\n         \'label:fr\': \'Rendre les sous-titres sélectionnables\',\r\n         \'label:it\': \'Rendi i sottotitoli selezionabili\',\r\n         \'label:de\': \'Untertitel auswählbar machen\',\r\n         \'label:pl\': \'Ustaw napisy do wyboru\',\r\n         \'label:ua\': \'Зробити субтитри доступними для виділення\',\r\n         type: \'checkbox\',\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'video-stop-preload\',\r\n   title: \'Stop video preload\',\r\n   \'title:zh\': \'停止视频预加载\',\r\n   \'title:ja\': \'ビデオのプリロードを停止します\',\r\n   \'title:ko\': \'비디오 미리 로드 중지\',\r\n   \'title:id\': \'Hentikan pramuat video\',\r\n   \'title:es\': \'Detener la precarga de video\',\r\n   \'title:pt\': \'Parar o pré-carregamento de vídeo\',\r\n   \'title:fr\': \'Arrêter le préchargement de la vidéo\',\r\n   \'title:it\': \'Interrompi il precaricamento del video\',\r\n   \'title:de\': \'Beenden Sie das Vorladen des Videos\',\r\n   \'title:pl\': \'Zatrzymaj ładowanie wideo\',\r\n   \'title:ua\': \'Зупинити передзавантаження відео\',\r\n   run_on_pages: \'watch, embed\',\r\n   section: \'player\',\r\n   desc: \'Prevent auto-buffering\',\r\n   _runtime: user_settings => {\r\n      if (user_settings.stop_preload_embed && NOVA.currentPage != \'embed\') return;\r\n      if (location.hostname == \'youtube.googleapis.com\') return;\r\n      if (NOVA.queryURL.has(\'popup\')) return;\r\n      if (NOVA.currentPage == \'embed\'\r\n         && window.self !== window.top\r\n         && [\'0\', \'false\'].includes(NOVA.queryURL.get(\'autoplay\'))\r\n      ) {\r\n         return;\r\n      }\r\n      NOVA.waitSelector(\'#movie_player\')\r\n         .then(async movie_player => {\r\n            let disableStop;\r\n            document.addEventListener(\'yt-navigate-start\', () => disableStop = false);\r\n            await NOVA.waitUntil(() => typeof movie_player === \'object\' && typeof movie_player.stopVideo === \'function\');\r\n            movie_player.stopVideo();\r\n            movie_player.addEventListener(\'onStateChange\', onPlayerStateChange.bind(this));\r\n            function onPlayerStateChange(state) {\r\n               if (user_settings.stop_preload_ignore_playlist && location.search.includes(\'list=\')) return;\r\n               if (user_settings.stop_preload_ignore_live && movie_player.getVideoData().isLive) return;\r\n               if (!disableStop && state > 0 && state < 5) {\r\n                  movie_player.stopVideo();\r\n               }\r\n            }\r\n            document.addEventListener(\'keyup\', ({ code }) => (code == \'Space\') && disableHoldStop());\r\n            document.addEventListener(\'click\', evt => {\r\n               if (//movie_player.contains(document.activeElement) ||\r\n                  evt.isTrusted\r\n                  && [\'button[class*=\"play-button\"]\', \'.ytp-cued-thumbnail-overlay-image\'].some(s => evt.srcElement.matches(s))\r\n               ) {\r\n                  disableHoldStop();\r\n               }\r\n            });\r\n            function disableHoldStop() {\r\n               if (!disableStop) {\r\n                  disableStop = true;\r\n                  movie_player.playVideo();\r\n               }\r\n            }\r\n         });\r\n   },\r\n   options: {\r\n      stop_preload_ignore_playlist: {\r\n         _tagName: \'input\',\r\n         label: \'Ignore playlist\',\r\n         \'label:zh\': \'忽略播放列表\',\r\n         \'label:ja\': \'プレイリストを無視する\',\r\n         \'label:ko\': \'재생목록 무시\',\r\n         \'label:id\': \'Abaikan daftar putar\',\r\n         \'label:es\': \'Ignorar lista de reproducción\',\r\n         \'label:pt\': \'Ignorar lista de reprodução\',\r\n         \'label:fr\': \'Ignorer la liste de lecture\',\r\n         \'label:it\': \'Ignora playlist\',\r\n         \'label:de\': \'Wiedergabeliste ignorieren\',\r\n         \'label:pl\': \'Zignoruj listę odtwarzania\',\r\n         \'label:ua\': \'Ігнорувати список відтворення\',\r\n         type: \'checkbox\',\r\n         \'data-dependent\': { \'stop_preload_embed\': false },\r\n      },\r\n      stop_preload_ignore_live: {\r\n         _tagName: \'input\',\r\n         label: \'Ignore live\',\r\n         \'label:ua\': \'Ігнорувати живі трансляції\',\r\n         type: \'checkbox\',\r\n         \'data-dependent\': { \'stop_preload_embed\': false },\r\n      },\r\n      stop_preload_embed: {\r\n         _tagName: \'select\',\r\n         label: \'Apply to video type\',\r\n         \'label:ua\': \'Застосувати до відео\',\r\n         options: [\r\n            {\r\n               label: \'all\', value: false, selected: true,\r\n               \'label:ua\': \'всіх\',\r\n            },\r\n            {\r\n               label: \'embed\', value: \'on\',\r\n               \'label:ua\': \'вбудованих\',\r\n            },\r\n         ],\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'player-resume-playback\',\r\n   title: \'Remember playback time\',\r\n   \'title:zh\': \'恢复播放时间状态\',\r\n   \'title:ja\': \'再生時間の位置を再開します\',\r\n   \'title:ko\': \'재생 시간 위치 재개\',\r\n   \'title:id\': \'Lanjutkan posisi waktu pemutaran\',\r\n   \'title:es\': \'Reanudar posición de tiempo de reproducción\',\r\n   \'title:pt\': \'Retomar a posição do tempo de reprodução\',\r\n   \'title:fr\': \'Reprendre la position de temps de lecture\',\r\n   \'title:it\': \'Riprende la posizione del tempo di riproduzione\',\r\n   \'title:de\': \'Wiedergabezeitposition fortsetzen\',\r\n   \'title:pl\': \'Powrót do pozycji czasowej odtwarzania\',\r\n   \'title:ua\': \'Запам`ятати час відтворення\',\r\n   run_on_pages: \'watch, embed\',\r\n   section: \'player\',\r\n   desc: \'On page reload - resume playback\',\r\n   \'desc:zh\': \'在页面重新加载 - 恢复播放\',\r\n   \'desc:ja\': \'ページがリロードされると、再生が復元されます\',\r\n   \'desc:ko\': \'페이지 새로고침 시 - 재생 재개\',\r\n   \'desc:id\': \'Muat ulang halaman - lanjutkan pemutaran\',\r\n   \'desc:es\': \'En la recarga de la página - reanudar la reproducción\',\r\n   \'desc:pt\': \'Recarregar na página - retomar a reprodução\',\r\n   \'desc:fr\': \'Lors du rechargement de la page - reprendre la lecture\',\r\n   \'desc:it\': \'Ricarica alla pagina: riprende la riproduzione\',\r\n   \'desc:de\': \'Auf Seite neu laden - Wiedergabe fortsetzen\',\r\n   \'desc:pl\': \'Przy ponownym załadowaniu strony - wznawiaj odtwarzanie\',\r\n   \'desc:ua\': \'Після завантаження - продовжити відтворення\',\r\n   _runtime: user_settings => {\r\n      if (!navigator.cookieEnabled && NOVA.currentPage == \'embed\') return;\r\n      const\r\n         CACHE_PREFIX = \'nova-resume-playback-time\',\r\n         getCacheName = () => CACHE_PREFIX + \':\' + (NOVA.queryURL.get(\'v\') || movie_player.getVideoData().video_id);\r\n      let cacheName;\r\n      NOVA.waitSelector(\'video\')\r\n         .then(video => {\r\n            cacheName = getCacheName();\r\n            resumePlayback.apply(video);\r\n            video.addEventListener(\'loadeddata\', resumePlayback.bind(video));\r\n            video.addEventListener(\'timeupdate\', savePlayback.bind(video));\r\n            video.addEventListener(\'ended\', () => sessionStorage.removeItem(cacheName));\r\n            if (user_settings.player_resume_playback_url_mark && NOVA.currentPage != \'embed\') {\r\n               if (NOVA.queryURL.has(\'t\')) {\r\n                  document.addEventListener(\'yt-navigate-finish\',\r\n                     connectSaveStateInURL.bind(video), { capture: true, once: true });\r\n               }\r\n               else {\r\n                  connectSaveStateInURL.apply(video);\r\n               }\r\n            }\r\n         });\r\n      function savePlayback() {\r\n         if (this.currentTime > 5 && this.duration > 30 && !movie_player.classList.contains(\'ad-showing\')) {\r\n            sessionStorage.setItem(cacheName, ~~this.currentTime);\r\n         }\r\n      }\r\n      async function resumePlayback() {\r\n         if (NOVA.queryURL.has(\'t\')\r\n            || (user_settings[\'save-channel-state\'] && await NOVA.storage_obj_manager.getParam(\'ignore-playback\'))\r\n         ) {\r\n            return;\r\n         }\r\n         cacheName = getCacheName();\r\n         if ((time = +sessionStorage.getItem(cacheName))\r\n            && (time < (this.duration - 1))\r\n         ) {\r\n            this.currentTime = time;\r\n         }\r\n      }\r\n      function connectSaveStateInURL() {\r\n         let delaySaveOnPauseURL;\r\n         this.addEventListener(\'pause\', () => {\r\n            if (this.currentTime < (this.duration - 1) && this.currentTime > 5 && this.duration > 10) {\r\n               delaySaveOnPauseURL = setTimeout(() => {\r\n                  NOVA.updateUrl(NOVA.queryURL.set({ \'t\': ~~this.currentTime + \'s\' }));\r\n               }, 100);\r\n            }\r\n         });\r\n         this.addEventListener(\'play\', () => {\r\n            if (typeof delaySaveOnPauseURL === \'number\') clearTimeout(delaySaveOnPauseURL);\r\n            if (NOVA.queryURL.has(\'t\')) NOVA.updateUrl(NOVA.queryURL.remove(\'t\'));\r\n         });\r\n      }\r\n   },\r\n   options: {\r\n      player_resume_playback_url_mark: {\r\n         _tagName: \'input\',\r\n         label: \'Mark time in URL when paused\',\r\n         \'label:zh\': \'暂停时在 URL 中节省时间\',\r\n         \'label:ja\': \'一時停止したときにURLで時間を節約する\',\r\n         \'label:ko\': \'일시 중지 시 URL에 시간 표시\',\r\n         \'label:id\': \'Tandai waktu di URL saat dijeda\',\r\n         \'label:es\': \'Marcar tiempo en URL cuando está en pausa\',\r\n         \'label:pt\': \'Marcar tempo no URL quando pausado\',\r\n         \'label:fr\': \"Marquer l\'heure dans l\'URL en pause\",\r\n         \'label:it\': \"Segna il tempo nell\'URL quando è in pausa\",\r\n         \'label:de\': \'Zeit in URL markieren, wenn pausiert\',\r\n         \'label:pl\': \'Zaznacz czas w adresie URL po wstrzymaniu\',\r\n         \'label:ua\': \'Маркувати час в URL-посиланні під час паузи\',\r\n         type: \'checkbox\',\r\n         title: \'Makes sense when saving bookmarks\',\r\n         \'title:zh\': \'保存书签时有意义\',\r\n         \'title:ja\': \'ブックマークを保存するときに意味があります\',\r\n         \'title:ko\': \'북마크를 저장할 때 의미가 있습니다.\',\r\n         \'title:id\': \'Masuk akal saat menyimpan bookmark\',\r\n         \'title:es\': \'Tiene sentido al guardar marcadores\',\r\n         \'title:pt\': \'Faz sentido ao salvar favoritos\',\r\n         \'title:fr\': \"Cela a du sens lors de l\'enregistrement de signets\",\r\n         \'title:it\': \'Ha senso quando si salvano i segnalibri\',\r\n         \'title:de\': \'Sinnvoll beim Speichern von Lesezeichen\',\r\n         \'title:pl\': \'Ma sens podczas zapisywania zakładek\',\r\n         \'title:ua\': \'Має сенс при збереженні закладок\',\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'video-quality\',\r\n   title: \'Video quality\',\r\n   \'title:zh\': \'视频质量\',\r\n   \'title:ja\': \'ビデオ品質\',\r\n   \'title:ko\': \'비디오 품질\',\r\n   \'title:id\': \'Kualitas video\',\r\n   \'title:es\': \'Calidad de video\',\r\n   \'title:pt\': \'Qualidade de vídeo\',\r\n   \'title:fr\': \'Qualité vidéo\',\r\n   \'title:it\': \'Qualità video\',\r\n   \'title:de\': \'Videoqualität\',\r\n   \'title:pl\': \'Jakość wideo\',\r\n   \'title:ua\': \'Якість відео\',\r\n   run_on_pages: \'watch, embed\',\r\n   section: \'player\',\r\n   _runtime: user_settings => {\r\n      const qualityFormatListWidth = {\r\n         highres: 4320,\r\n         hd2880: 2880,\r\n         hd2160: 2160,\r\n         hd1440: 1440,\r\n         hd1080: 1080,\r\n         hd720: 720,\r\n         large: 480,\r\n         medium: 360,\r\n         small: 240,\r\n         tiny: 144,\r\n      };\r\n      let selectedQuality = user_settings.video_quality;\r\n      NOVA.waitSelector(\'#movie_player\')\r\n         .then(movie_player => {\r\n            if (user_settings.video_quality_manual_save_in_tab\r\n               && NOVA.currentPage == \'watch\'\r\n            ) {\r\n               movie_player.addEventListener(\'onPlaybackQualityChange\', quality => {\r\n                  if (document.activeElement.getAttribute(\'role\') == \'menuitemradio\'\r\n                     && quality !== selectedQuality\r\n                  ) {\r\n                     console.info(`keep quality \"${quality}\" in the session`);\r\n                     selectedQuality = quality;\r\n                     user_settings.video_quality_in_music_playlist = false;\r\n                  }\r\n               });\r\n            }\r\n            if (user_settings[\'save-channel-state\']) {\r\n               NOVA.runOnPageInitOrTransition(async () => {\r\n                  if ((NOVA.currentPage == \'watch\' || NOVA.currentPage == \'embed\')\r\n                     && (userQuality = await NOVA.storage_obj_manager.getParam(\'quality\'))\r\n                  ) {\r\n                     selectedQuality = userQuality;\r\n                  }\r\n               });\r\n            }\r\n            setQuality();\r\n            movie_player.addEventListener(\'onStateChange\', setQuality);\r\n         });\r\n      function setQuality(state) {\r\n         if (!selectedQuality) return console.error(\'selectedQuality unavailable\', selectedQuality);\r\n         if (user_settings.video_quality_in_music_playlist\r\n            && location.search.includes(\'list=\')\r\n            && NOVA.isMusic()\r\n         ) {\r\n            selectedQuality = user_settings.video_quality_in_music_quality;\r\n         }\r\n         if ([\'PLAYING\', \'BUFFERING\'].includes(NOVA.getPlayerState(state)) && !setQuality.quality_busy) {\r\n            setQuality.quality_busy = true;\r\n            const waitQuality = setInterval(() => {\r\n               let availableQualityLevels = movie_player.getAvailableQualityLevels();\r\n               const maxWidth = (NOVA.currentPage == \'watch\') ? window.screen.width : window.innerWidth;\r\n               const maxQualityIdx = availableQualityLevels\r\n                  .findIndex(i => qualityFormatListWidth[i] <= (maxWidth * 1.3));\r\n               availableQualityLevels = availableQualityLevels.slice(maxQualityIdx);\r\n               if (availableQualityLevels?.length) {\r\n                  clearInterval(waitQuality);\r\n                  const maxAvailableQuality = Math.max(availableQualityLevels.indexOf(selectedQuality), 0);\r\n                  const newQuality = availableQualityLevels[maxAvailableQuality];\r\n                  if (movie_player.hasOwnProperty(\'setPlaybackQuality\')) {\r\n                     movie_player.setPlaybackQuality(newQuality);\r\n                  }\r\n                  if (movie_player.hasOwnProperty(\'setPlaybackQualityRange\')) {\r\n                     movie_player.setPlaybackQualityRange(newQuality, newQuality);\r\n                  }\r\n               }\r\n            }, 50);\r\n         }\r\n         else if (state <= 0) {\r\n            setQuality.quality_busy = false;\r\n         }\r\n      }\r\n      NOVA.waitSelector(\'.ytp-error [class*=\"reason\"]\', { stop_on_page_change: true })\r\n         .then(error_reason_el => {\r\n            if (alertText = error_reason_el.textContent) {\r\n               throw alertText;\r\n            }\r\n         });\r\n   },\r\n   options: {\r\n      video_quality: {\r\n         _tagName: \'select\',\r\n         label: \'Default quality\',\r\n         \'label:zh\': \'默认视频质量\',\r\n         \'label:ja\': \'デフォルトのビデオ品質\',\r\n         \'label:ko\': \'기본 비디오 품질\',\r\n         \'label:id\': \'Kualitas bawaan\',\r\n         \'label:es\': \'Calidad predeterminada\',\r\n         \'label:pt\': \'Qualidade padrão\',\r\n         \'label:fr\': \'Qualité par défaut\',\r\n         \'label:it\': \'Qualità predefinita\',\r\n         \'label:de\': \'Standardvideoqualität\',\r\n         \'label:pl\': \'Domyślna jakość\',\r\n         \'label:ua\': \'Звичайна якість\',\r\n         title: \'If unavailable, set max available quality\',\r\n         \'title:zh\': \'如果不可用，将选择可用的最高质量。\',\r\n         \'title:ja\': \'利用できない場合は、利用可能な最高の品質が選択されます。\',\r\n         \'title:ko\': \'사용할 수 없는 경우 사용 가능한 최대 품질을 설정합니다.\',\r\n         \'title:id\': \'Jika tidak tersedia, atur kualitas maksimal yang tersedia\',\r\n         \'title:es\': \'Si no está disponible, establezca la calidad máxima disponible\',\r\n         \'title:pt\': \'Se não estiver disponível, defina a qualidade máxima disponível\',\r\n         \'title:fr\': \'Si non disponible, définissez la qualité maximale disponible\',\r\n         \'title:it\': \'Se non disponibile, imposta la massima qualità disponibile\',\r\n         \'title:pl\': \'Jeśli nie dostępna, ustaw maksymalną dostępną jakość\',\r\n         \'title:ua\': \'Якщо недоступно, обрати максимальну доступну якість\',\r\n         options: [\r\n            { label: \'8K/4320p\', value: \'highres\' },\r\n            { label: \'4K/2160p\', value: \'hd2160\' },\r\n            { label: \'QHD/1440p\', value: \'hd1440\' },\r\n            { label: \'FHD/1080p\', value: \'hd1080\', selected: true },\r\n            { label: \'HD/720p\', value: \'hd720\' },\r\n            { label: \'SD/480p\', value: \'large\' },\r\n            { label: \'SD/360p\', value: \'medium\' },\r\n            { label: \'SD/240p\', value: \'small\' },\r\n            { label: \'SD/144p\', value: \'tiny\' },\r\n         ],\r\n      },\r\n      video_quality_manual_save_in_tab: {\r\n         _tagName: \'input\',\r\n         label: \'Save manually selected for the same tab\',\r\n         \'label:zh\': \'手动选择的质量保存在当前选项卡中\',\r\n         \'label:ja\': \'手動で選択した品質が現在のタブに保存されます\',\r\n         \'label:ko\': \'동일한 탭에 대해 수동으로 선택한 저장\',\r\n         \'label:id\': \'Simpan dipilih secara manual untuk tab yang sama\',\r\n         \'label:es\': \'Guardar seleccionado manualmente para la misma pestaña\',\r\n         \'label:pt\': \'Salvar selecionado manualmente para a mesma guia\',\r\n         \'label:fr\': \'Enregistrer sélectionné manuellement pour le même onglet\',\r\n         \'label:it\': \'Salva selezionato manualmente per la stessa scheda\',\r\n         \'label:de\': \'Manuell für dieselbe Registerkarte ausgewählt speichern\',\r\n         \'label:pl\': \'Właściwości dla obecnej karty\',\r\n         \'label:ua\': \'Зберігати власноруч обрану якість для вкладки\',\r\n         type: \'checkbox\',\r\n         title: \'Affects to next videos\',\r\n         \'title:zh\': \'对下一个视频的影响\',\r\n         \'title:ja\': \'次の動画への影響\',\r\n         \'title:ko\': \'다음 동영상에 영향\',\r\n         \'title:id\': \'Mempengaruhi video berikutnya\',\r\n         \'title:es\': \'Afecta a los siguientes videos\',\r\n         \'title:pt\': \'Afeta para os próximos vídeos\',\r\n         \'title:fr\': \'Affecte aux prochaines vidéos\',\r\n         \'title:it\': \'Influisce sui prossimi video\',\r\n         \'title:de\': \'Beeinflusst die nächsten Videos\',\r\n         \'title:pl\': \'Zmiany w następnych filmach\',\r\n         \'title:ua\': \'Впливає на наступні відео\',\r\n      },\r\n      video_quality_in_music_playlist: {\r\n         _tagName: \'input\',\r\n         label: \'Diff quality for music in playlists\',\r\n         \'label:ua\': \'Змінити якість музики у списках відтворення\',\r\n         type: \'checkbox\',\r\n         title: \'to save traffic / increase speed\',\r\n         \'title:zh\': \'节省流量/提高速度\',\r\n         \'title:ja\': \'トラフィックを節約/速度を上げる\',\r\n         \'title:ko\': \'트래픽 절약 / 속도 향상\',\r\n         \'title:id\': \'untuk menghemat lalu lintas / meningkatkan kecepatan\',\r\n         \'title:es\': \'para ahorrar tráfico / aumentar la velocidad\',\r\n         \'title:pt\': \'para economizar tráfego / aumentar a velocidade\',\r\n         \'title:fr\': \'économiser du trafic / augmenter la vitesse\',\r\n         \'title:it\': \'per risparmiare traffico / aumentare la velocità\',\r\n         \'title:de\': \'um Verkehr zu sparen / Geschwindigkeit zu erhöhen\',\r\n         \'title:pl\': \'aby zaoszczędzić ruch / zwiększyć prędkość\',\r\n         \'title:ua\': \'для економії трафіку / збільшення швидкості\',\r\n      },\r\n      video_quality_in_music_quality: {\r\n         _tagName: \'select\',\r\n         label: \'Quality for music\',\r\n         \'label:zh\': \'音乐品质\',\r\n         \'label:ja\': \'音楽の品質\',\r\n         \'label:ko\': \'음악 품질\',\r\n         \'label:id\': \'Kualitas untuk musik\',\r\n         \'label:es\': \'calidad para la musica\',\r\n         \'label:pt\': \'Qualidade para música\',\r\n         \'label:fr\': \'Qualité pour la musique\',\r\n         \'label:it\': \'Qualità per la musica\',\r\n         \'label:de\': \'Qualität für Musik\',\r\n         \'label:pl\': \'Jakość dla muzyki\',\r\n         \'label:ua\': \'Якість для музики\',\r\n         options: [\r\n            { label: \'8K/4320p\', value: \'highres\' },\r\n            { label: \'4K/2160p\', value: \'hd2160\' },\r\n            { label: \'QHD/1440p\', value: \'hd1440\' },\r\n            { label: \'FHD/1080p\', value: \'hd1080\' },\r\n            { label: \'HD/720p\', value: \'hd720\' },\r\n            { label: \'SD/480p\', value: \'large\', selected: true },\r\n            { label: \'SD/360p\', value: \'medium\' },\r\n            { label: \'SD/240p\', value: \'small\' },\r\n            { label: \'SD/144p\', value: \'tiny\' },\r\n         ],\r\n         \'data-dependent\': { \'video_quality_in_music_playlist\': true },\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'player-pin-scroll\',\r\n   title: \'Pin player while scrolling\',\r\n   \'title:zh\': \'滚动时固定播放器\',\r\n   \'title:ja\': \'スクロール中にプレイヤーを固定する\',\r\n   \'title:ko\': \'스크롤하는 동안 플레이어 고정\',\r\n   \'title:id\': \'Sematkan pemutar saat menggulir\',\r\n   \'title:es\': \'Fijar jugador mientras se desplaza\',\r\n   \'title:pt\': \'Fixar jogador enquanto rola\',\r\n   \'title:fr\': \'Épingler le lecteur pendant le défilement\',\r\n   \'title:it\': \'Blocca il lettore durante lo scorrimento\',\r\n   \'title:de\': \'Pin-Player beim Scrollen\',\r\n   \'title:pl\': \'Przypnij odtwarzacz podczas przewijania\',\r\n   \'title:ua\': \'Закріпити відтворювач коли гортаєш сторінку\',\r\n   run_on_pages: \'watch, -mobile\',\r\n   section: \'player\',\r\n   desc: \'Mini player\',\r\n   _runtime: user_settings => {\r\n      if (!(\'IntersectionObserver\' in window)) return alert(\'Nova\\n\\nPin player Error!\\nIntersectionObserver not supported.\');\r\n      const\r\n         CLASS_VALUE = \'nova-player-pin\',\r\n         PINNED_SELECTOR = \'.\' + CLASS_VALUE,\r\n         UNPIN_BTN_CLASS_VALUE = CLASS_VALUE + \'-unpin-btn\',\r\n         UNPIN_BTN_SELECTOR = \'.\' + UNPIN_BTN_CLASS_VALUE;\r\n      document.addEventListener(\'scroll\', () => {\r\n         NOVA.waitSelector(\'#ytd-player\')\r\n            .then(container => {\r\n               new IntersectionObserver(([entry]) => {\r\n                  if (entry.isIntersecting) {\r\n                     movie_player.classList.remove(CLASS_VALUE);\r\n                     drag.reset();\r\n                  }\r\n                  else if (!movie_player.isFullscreen()\r\n                     && document.documentElement.scrollTop\r\n                  ) {\r\n                     movie_player.classList.add(CLASS_VALUE);\r\n                     drag?.storePos?.X && drag.setTranslate(drag.storePos);\r\n                  }\r\n                  window.dispatchEvent(new Event(\'resize\'));\r\n               }, {\r\n                  threshold: .5,\r\n               })\r\n                  .observe(container);\r\n            });\r\n      }, { capture: true, once: true });\r\n      NOVA.waitSelector(PINNED_SELECTOR)\r\n         .then(async player => {\r\n            drag.init(player);\r\n            await NOVA.waitUntil(\r\n               () => (NOVA.videoElement?.videoWidth && !isNaN(NOVA.videoElement.videoWidth)\r\n                  && NOVA.videoElement?.videoHeight && !isNaN(NOVA.videoElement.videoHeight)\r\n               )\r\n               , 500)\r\n            initMiniStyles();\r\n            insertUnpinButton(player);\r\n            document.addEventListener(\'fullscreenchange\', () => NOVA.isFullscreen() && movie_player.classList.remove(CLASS_VALUE));\r\n            NOVA.waitSelector(\'#movie_player video\')\r\n               .then(video => {\r\n                  video.addEventListener(\'loadeddata\', () => {\r\n                     if (NOVA.currentPage != \'watch\') return;\r\n                     NOVA.waitSelector(PINNED_SELECTOR)\r\n                        .then(() => {\r\n                           const width = NOVA.aspectRatio.calculateWidth(\r\n                              movie_player.clientHeight,\r\n                              NOVA.aspectRatio.chooseAspectRatio({\r\n                                 \'width\': NOVA.videoElement.videoWidth,\r\n                                 \'height\': NOVA.videoElement.videoHeight,\r\n                                 \'layout\': \'landscape\',\r\n                              }),\r\n                           );\r\n                           player.style.setProperty(\'--width\', `${width}px !important;`);\r\n                        });\r\n                  });\r\n               });\r\n            if (user_settings.player_float_scroll_after_fullscreen_restore_srcoll_pos) {\r\n               let scrollPos = 0;\r\n               document.addEventListener(\'fullscreenchange\', () => {\r\n                  if (!NOVA.isFullscreen()\r\n                     && scrollPos\r\n                     && drag.storePos\r\n                  ) {\r\n                     window.scrollTo({\r\n                        top: scrollPos,\r\n                     });\r\n                  }\r\n               });\r\n               document.addEventListener(\'yt-action\', function (evt) {\r\n                  if (evt.detail?.actionName == \'yt-close-all-popups-action\') {\r\n                     scrollPos = document.documentElement.scrollTop;\r\n                  }\r\n               });\r\n               document.addEventListener(\'yt-navigate-start\', () => scrollPos = 0);\r\n            }\r\n         });\r\n      function initMiniStyles() {\r\n         const scrollbarWidth = (window.innerWidth - document.documentElement.clientWidth || 0) + \'px\';\r\n         const miniSize = NOVA.aspectRatio.sizeToFit({\r\n            \'srcWidth\': NOVA.videoElement.videoWidth,\r\n            \'srcHeight\': NOVA.videoElement.videoHeight,\r\n            \'maxWidth\': (window.innerWidth / user_settings.player_float_scroll_size_ratio),\r\n            \'maxHeight\': (window.innerHeight / user_settings.player_float_scroll_size_ratio),\r\n         });\r\n         let initcss = {\r\n            width: NOVA.aspectRatio.calculateWidth(\r\n               miniSize.height,\r\n               NOVA.aspectRatio.chooseAspectRatio({ \'width\': miniSize.width, \'height\': miniSize.height })\r\n            ) + \'px\',\r\n            height: miniSize.height + \'px\',\r\n            position: \'fixed\',\r\n            \'z-index\': \'var(--zIndex)\',\r\n            \'box-shadow\': \'0 16px 24px 2px rgba(0, 0, 0, 0.14),\' +\r\n               \'0 6px 30px 5px rgba(0, 0, 0, 0.12),\' +\r\n               \'0 8px 10px -5px rgba(0, 0, 0, 0.4)\',\r\n         };\r\n         switch (user_settings.player_float_scroll_position) {\r\n            case \'top-left\':\r\n               initcss.top = user_settings[\'header-unfixed\'] ? 0\r\n                  : (document.getElementById(\'masthead-container\')?.offsetHeight || 0) + \'px\';\r\n               initcss.left = 0;\r\n               break;\r\n            case \'top-right\':\r\n               initcss.top = user_settings[\'header-unfixed\'] ? 0\r\n                  : (document.getElementById(\'masthead-container\')?.offsetHeight || 0) + \'px\';\r\n               initcss.right = scrollbarWidth;\r\n               break;\r\n            case \'bottom-left\':\r\n               initcss.bottom = 0;\r\n               initcss.left = 0;\r\n               break;\r\n            case \'bottom-right\':\r\n               initcss.bottom = 0;\r\n               initcss.right = scrollbarWidth;\r\n               break;\r\n         }\r\n         NOVA.css.push(initcss, PINNED_SELECTOR, \'important\');\r\n         NOVA.css.push(\r\n            PINNED_SELECTOR + `{\r\n               --height: ${initcss.height} !important;\r\n               --width: ${initcss.width} !important;\r\n               width: var(--width) !important;\r\n               height: var(--height) !important;\r\n               background-color: var(--yt-spec-base-background);\r\n            }\r\n            ${PINNED_SELECTOR} video {\r\n               object-fit: contain !important;\r\n            }\r\n            \r\n            ${PINNED_SELECTOR} .ytp-chrome-controls .nova-right-custom-button,\r\n            ${PINNED_SELECTOR} .ytp-chrome-controls #nova-player-time-remaining,\r\n            ${PINNED_SELECTOR} .ytp-chrome-controls button.ytp-size-button,\r\n            ${PINNED_SELECTOR} .ytp-chrome-controls button.ytp-subtitles-button,\r\n            ${PINNED_SELECTOR} .ytp-chrome-controls button.ytp-settings-button,\r\n            ${PINNED_SELECTOR} .ytp-chrome-controls .ytp-chapter-container {\r\n               display: none !important;\r\n            }`);\r\n         NOVA.css.push(`\r\n            ${PINNED_SELECTOR} .ytp-preview,\r\n            ${PINNED_SELECTOR} .ytp-scrubber-container,\r\n            ${PINNED_SELECTOR} .ytp-hover-progress,\r\n            ${PINNED_SELECTOR} .ytp-gradient-bottom { display:none !important; }\r\n            \r\n            ${PINNED_SELECTOR} .ytp-chrome-bottom { width: 96% !important; }\r\n            ${PINNED_SELECTOR} .ytp-chapters-container { display: flex; }`);\r\n         NOVA.css.push(\r\n            `${PINNED_SELECTOR} video {\r\n               width: var(--width) !important;\r\n               height: var(--height) !important;\r\n               left: 0 !important;\r\n               top: 0 !important;\r\n            }\r\n            .ended-mode video {\r\n               visibility: hidden;\r\n            }`);\r\n      }\r\n      function insertUnpinButton(player = movie_player) {\r\n         NOVA.css.push(\r\n            PINNED_SELECTOR + ` {\r\n               --zIndex: ${1 + Math.max(\r\n               NOVA.css.getValue(\'#chat\', \'z-index\'),\r\n               NOVA.css.getValue(\'.ytp-chrome-top .ytp-cards-button\', \'z-index\'),\r\n               NOVA.css.getValue(\'#chat\', \'z-index\'),\r\n               601)};\r\n            }\r\n            ${UNPIN_BTN_SELECTOR} { display: none; }\r\n            ${PINNED_SELECTOR} ${UNPIN_BTN_SELECTOR} {\r\n               display: initial !important;\r\n               position: absolute;\r\n               cursor: pointer;\r\n               top: 10px;\r\n               left: 10px;\r\n               width: 28px;\r\n               height: 28px;\r\n               color: white;\r\n               border: none;\r\n               outline: none;\r\n               opacity: .1;\r\n               \r\n               z-index: var(--zIndex);\r\n               font-size: 24px;\r\n               font-weight: bold;\r\n               background-color: rgba(0, 0, 0, 0.8);\r\n               \r\n            }\r\n            ${PINNED_SELECTOR}:hover ${UNPIN_BTN_SELECTOR} { opacity: .7; }\r\n            ${UNPIN_BTN_SELECTOR}:hover { opacity: 1 !important; }`);\r\n         const btnUnpin = document.createElement(\'button\');\r\n         btnUnpin.className = UNPIN_BTN_CLASS_VALUE;\r\n         btnUnpin.title = \'Unpin player\';\r\n         btnUnpin.textContent = \'×\';\r\n         btnUnpin.addEventListener(\'click\', () => {\r\n            player.classList.remove(CLASS_VALUE);\r\n            drag.reset(\'clear storePos\');\r\n            window.dispatchEvent(new Event(\'resize\'));\r\n         });\r\n         player.append(btnUnpin);\r\n         document.addEventListener(\'yt-navigate-start\', () => {\r\n            if (player.classList.contains(CLASS_VALUE)) {\r\n               player.classList.remove(CLASS_VALUE);\r\n               drag.reset();\r\n            }\r\n         });\r\n      }\r\n      const drag = {\r\n         attrNametoLock: \'force-fix-preventDefault\',\r\n         reset(clear_storePos) {\r\n            this.dragTarget?.style.removeProperty(\'transform\');\r\n            if (clear_storePos) this.storePos = this.xOffset = this.yOffset = 0;\r\n            else this.storePos = { \'X\': this.xOffset, \'Y\': this.yOffset };\r\n         },\r\n         init(el_target = required()) {\r\n            this.log(\'drag init\', ...arguments);\r\n            if (!(el_target instanceof HTMLElement)) return console.error(\'el_target not HTMLElement:\', el_target);\r\n            this.dragTarget = el_target;\r\n            document.addEventListener(\'mousedown\', evt => {\r\n               if (!el_target.classList.contains(CLASS_VALUE)) return;\r\n               this.dragStart.apply(this, [evt]);\r\n            });\r\n            document.addEventListener(\'mouseup\', evt => {\r\n               if (this.active) this.dragTarget.removeAttribute(this.attrNametoLock);\r\n               this.dragEnd.apply(this, [evt]);\r\n            });\r\n            document.addEventListener(\'mousemove\', evt => {\r\n               if (this.active && !this.dragTarget.hasAttribute(this.attrNametoLock)) {\r\n                  this.dragTarget.setAttribute(this.attrNametoLock, true);\r\n               }\r\n               this.draging.apply(this, [evt]);\r\n            });\r\n            NOVA.css.push(\r\n               `[${this.attrNametoLock}]:active {\r\n                  pointer-events: none;\r\n               }`);\r\n         },\r\n         dragStart(evt) {\r\n            if (!this.dragTarget.contains(evt.target)) return;\r\n            this.log(\'dragStart\');\r\n            switch (evt.type) {\r\n               case \'touchstart\':\r\n                  this.initialX = evt.touches[0].clientX - (this.xOffset || 0);\r\n                  this.initialY = evt.touches[0].clientY - (this.yOffset || 0);\r\n                  break;\r\n               case \'mousedown\':\r\n                  this.initialX = evt.clientX - (this.xOffset || 0);\r\n                  this.initialY = evt.clientY - (this.yOffset || 0);\r\n                  break;\r\n            }\r\n            this.active = true;\r\n            document.body.style.cursor = \'move\';\r\n         },\r\n         dragEnd(evt) {\r\n            if (!this.active) return;\r\n            this.log(\'dragEnd\');\r\n            this.initialX = this.currentX;\r\n            this.initialY = this.currentY;\r\n            this.active = false;\r\n            document.body.style.cursor = \'default\';\r\n         },\r\n         draging(evt) {\r\n            if (!this.active) return;\r\n            evt.preventDefault();\r\n            evt.stopImmediatePropagation();\r\n            this.log(\'draging\');\r\n            switch (evt.type) {\r\n               case \'touchmove\':\r\n                  this.currentX = evt.touches[0].clientX - this.initialX;\r\n                  this.currentY = evt.touches[0].clientY - this.initialY;\r\n                  break;\r\n               case \'mousemove\':\r\n                  const\r\n                     rect = this.dragTarget.getBoundingClientRect();\r\n                  if (rect.left >= document.body.clientWidth - this.dragTarget.offsetWidth) {\r\n                     this.currentX = Math.min(\r\n                        evt.clientX - this.initialX,\r\n                        document.body.clientWidth - this.dragTarget.offsetWidth - this.dragTarget.offsetLeft\r\n                     );\r\n                  }\r\n                  else {\r\n                     this.currentX = Math.max(evt.clientX - this.initialX, 0 - this.dragTarget.offsetLeft);\r\n                  }\r\n                  if (rect.top >= window.innerHeight - this.dragTarget.offsetHeight) {\r\n                     this.currentY = Math.min(\r\n                        evt.clientY - this.initialY,\r\n                        window.innerHeight - this.dragTarget.offsetHeight - this.dragTarget.offsetTop\r\n                     );\r\n                  }\r\n                  else {\r\n                     this.currentY = Math.max(evt.clientY - this.initialY, 0 - this.dragTarget.offsetTop);\r\n                  }\r\n                  break;\r\n            }\r\n            this.xOffset = this.currentX;\r\n            this.yOffset = this.currentY;\r\n            this.setTranslate({ \'X\': this.currentX, \'Y\': this.currentY });\r\n         },\r\n         setTranslate({ X = required(), Y = required() }) {\r\n            this.log(\'setTranslate\', ...arguments);\r\n            this.dragTarget.style.transform = `translate3d(${X}px, ${Y}px, 0)`;\r\n         },\r\n         log() {\r\n            if (this.DEBUG && arguments.length) {\r\n               console.groupCollapsed(...arguments);\r\n               console.trace();\r\n               console.groupEnd();\r\n            }\r\n         },\r\n      };\r\n   },\r\n   options: {\r\n      player_float_scroll_size_ratio: {\r\n         _tagName: \'input\',\r\n         label: \'Player size\',\r\n         \'label:zh\': \'播放器尺寸\',\r\n         \'label:ja\': \'プレーヤーのサイズ\',\r\n         \'label:ko\': \'플레이어 크기\',\r\n         \'label:id\': \'Ukuran pemain\',\r\n         \'label:es\': \'Tamaño del jugador\',\r\n         \'label:pt\': \'Tamanho do jogador\',\r\n         \'label:fr\': \'Taille du joueur\',\r\n         \'label:it\': \'Dimensioni del giocatore\',\r\n         \'label:de\': \'Spielergröße\',\r\n         \'label:pl\': \'Rozmiar odtwarzacza\',\r\n         \'label:ua\': \'Розмір відтворювача\',\r\n         type: \'number\',\r\n         title: \'Less value - larger size\',\r\n         \'title:zh\': \'较小的值 - 较大的尺寸\',\r\n         \'title:ja\': \'小さい値-大きいサイズ\',\r\n         \'title:ko\': \'더 작은 값 - 더 큰 크기\',\r\n         \'title:id\': \'Nilai lebih kecil - ukuran lebih besar\',\r\n         \'title:es\': \'Valor más pequeño - tamaño más grande\',\r\n         \'title:pt\': \'Valor menor - tamanho maior\',\r\n         \'title:fr\': \'Plus petite valeur - plus grande taille\',\r\n         \'title:it\': \'Meno valore - dimensioni maggiori\',\r\n         \'title:de\': \'Kleiner Wert - größere Größe\',\r\n         \'title:pl\': \'Mniejsza wartość - większy rozmiar\',\r\n         \'title:ua\': \'Менше значення - більший розмір\',\r\n         placeholder: \'2-5\',\r\n         step: 0.1,\r\n         min: 1,\r\n         max: 5,\r\n         value: 2.5,\r\n      },\r\n      player_float_scroll_position: {\r\n         _tagName: \'select\',\r\n         label: \'Player position\',\r\n         \'label:zh\': \'球员位置\',\r\n         \'label:ja\': \'プレイヤーの位置\',\r\n         \'label:ko\': \'선수 위치\',\r\n         \'label:id\': \'Posisi pemain\',\r\n         \'label:es\': \'Posición de jugador\',\r\n         \'label:pt\': \'Posição do jogador\',\r\n         \'label:fr\': \'La position du joueur\',\r\n         \'label:it\': \'Posizione del giocatore\',\r\n         \'label:de\': \'Spielerposition\',\r\n         \'label:pl\': \'Pozycja odtwarzacza\',\r\n         \'label:ua\': \'Позиція відтворювача\',\r\n         options: [\r\n            {\r\n               label: \'Top left\', value: \'top-left\',\r\n            },\r\n            {\r\n               label: \'Top right\', value: \'top-right\', selected: true,\r\n            },\r\n            {\r\n               label: \'Bottom left\', value: \'bottom-left\',\r\n            },\r\n            {\r\n               label: \'Bottom right\', value: \'bottom-right\',\r\n            },\r\n         ],\r\n      },\r\n      player_float_scroll_after_fullscreen_restore_srcoll_pos: {\r\n         _tagName: \'input\',\r\n         label: \'Restore scrolling back there after exiting fullscreen\',\r\n         type: \'checkbox\',\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'video-autopause\',\r\n   title: \'Video autopause\',\r\n   \'title:zh\': \'视频自动暂停\',\r\n   \'title:ja\': \'ビデオの自動一時停止\',\r\n   \'title:ko\': \'비디오 자동 일시 중지\',\r\n   \'title:id\': \'Jeda otomatis video\',\r\n   \'title:es\': \'Pausa automática de video\',\r\n   \'title:pt\': \'Pausa automática de vídeo\',\r\n   \'title:fr\': \'Pause automatique de la vidéo\',\r\n   \'title:it\': \'Pausa automatica del video\',\r\n   \'title:de\': \'Automatische Pause des Videos\',\r\n   \'title:pl\': \'Automatyczne zatrzymanie wideo\',\r\n   \'title:ua\': \'Автопауза\',\r\n   run_on_pages: \'watch, embed\',\r\n   restart_on_location_change: true,\r\n   section: \'player\',\r\n   desc: \'Disable autoplay\',\r\n   \'desc:zh\': \'禁用自动播放\',\r\n   \'desc:ja\': \'自動再生を無効にする\',\r\n   \'desc:ko\': \'자동 재생 비활성화\',\r\n   \'desc:it\': \'Nonaktifkan putar otomatis\',\r\n   \'desc:es\': \'Deshabilitar reproducción automática\',\r\n   \'desc:pt\': \'Desativar reprodução automática\',\r\n   \'desc:fr\': \'Désactiver la lecture automatique\',\r\n   \'desc:it\': \'Disabilita la riproduzione automatica\',\r\n   \'desc:de\': \'Deaktiviere Autoplay\',\r\n   \'desc:pl\': \'Wyłącz autoodtwarzanie\',\r\n   \'desc:ua\': \'Вимкнути автовідтворення\',\r\n   _runtime: user_settings => {\r\n      if (user_settings[\'video-stop-preload\'] && !user_settings.stop_preload_embed) return;\r\n      if (user_settings.video_autopause_embed && NOVA.currentPage != \'embed\') return;\r\n      if (NOVA.currentPage == \'embed\'\r\n         && window.self !== window.top\r\n         && [\'0\', \'false\'].includes(NOVA.queryURL.get(\'autoplay\'))\r\n      ) {\r\n         return;\r\n      }\r\n      NOVA.waitSelector(\'#movie_player video\')\r\n         .then(video => {\r\n            if (user_settings.video_autopause_ignore_live && movie_player.getVideoData().isLive) return;\r\n            forceVideoPause.apply(video);\r\n         });\r\n      function forceVideoPause() {\r\n         if (user_settings.video_autopause_ignore_playlist && location.search.includes(\'list=\')) return;\r\n         this.pause();\r\n         const forceHoldPause = setInterval(() => this.paused || this.pause(), 200);\r\n         document.addEventListener(\'keyup\', ({ code }) => (code == \'Space\') && stopForceHoldPause());\r\n         document.addEventListener(\'click\', evt => {\r\n            if (//movie_player.contains(document.activeElement) ||\r\n               evt.isTrusted\r\n               && [\'button[class*=\"play-button\"]\', \'.ytp-cued-thumbnail-overlay-image\'].some(s => evt.srcElement.matches(s))\r\n            ) {\r\n               stopForceHoldPause();\r\n            }\r\n         });\r\n         function stopForceHoldPause() {\r\n            clearInterval(forceHoldPause);\r\n            movie_player.playVideo();\r\n         }\r\n      }\r\n   },\r\n   options: {\r\n      video_autopause_ignore_playlist: {\r\n         _tagName: \'input\',\r\n         label: \'Ignore playlist\',\r\n         \'label:zh\': \'忽略播放列表\',\r\n         \'label:ja\': \'プレイリストを無視する\',\r\n         \'label:ko\': \'재생목록 무시\',\r\n         \'label:id\': \'Abaikan daftar putar\',\r\n         \'label:es\': \'Ignorar lista de reproducción\',\r\n         \'label:pt\': \'Ignorar lista de reprodução\',\r\n         \'label:fr\': \'Ignorer la liste de lecture\',\r\n         \'label:it\': \'Ignora playlist\',\r\n         \'label:de\': \'Wiedergabeliste ignorieren\',\r\n         \'label:pl\': \'Zignoruj listę odtwarzania\',\r\n         \'label:ua\': \'Ігнорувати список відтворення\',\r\n         type: \'checkbox\',\r\n         \'data-dependent\': { \'video_autopause_embed\': false },\r\n      },\r\n      video_autopause_ignore_live: {\r\n         _tagName: \'input\',\r\n         label: \'Ignore live\',\r\n         \'label:ua\': \'Ігнорувти живі трансляції\',\r\n         type: \'checkbox\',\r\n         \'data-dependent\': { \'video_autopause_embed\': false },\r\n      },\r\n      video_autopause_embed: {\r\n         _tagName: \'select\',\r\n         label: \'Apply to video type\',\r\n         \'label:ua\': \'Застосувати до відео\',\r\n         options: [\r\n            {\r\n               label: \'all\', value: false, selected: true,\r\n               \'label:ua\': \'всіх\',\r\n            },\r\n            {\r\n               label: \'embed\', value: \'on\',\r\n               \'label:ua\': \'вбудованих\',\r\n            },\r\n         ],\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'volume-wheel\',\r\n   title: \'Volume\',\r\n   \'title:zh\': \'体积\',\r\n   \'title:ja\': \'音量\',\r\n   \'title:ko\': \'용량\',\r\n   \'title:es\': \'Volumen\',\r\n   \'title:fr\': \'Le volume\',\r\n   \'title:de\': \'Volumen\',\r\n   \'title:pl\': \'Głośność\',\r\n   \'title:ua\': \'Гучність\',\r\n   run_on_pages: \'watch, embed, -mobile\',\r\n   section: \'player\',\r\n   desc: \'With mouse wheel\',\r\n   \'desc:zh\': \'带鼠标滚轮\',\r\n   \'desc:ja\': \'マウスホイール付き\',\r\n   \'desc:ko\': \'마우스 휠로\',\r\n   \'desc:id\': \'Dengan roda mouse\',\r\n   \'desc:es\': \'Con rueda de ratón\',\r\n   \'desc:pt\': \'Com roda do mouse\',\r\n   \'desc:fr\': \'Avec molette de la souris\',\r\n   \'desc:it\': \'Con rotellina del mouse\',\r\n   \'desc:de\': \'Mit mausrad\',\r\n   \'desc:pl\': \'Za pomocą kółka myszy\',\r\n   \'desc:ua\': \'З допомогою колеса мишки\',\r\n   _runtime: user_settings => {\r\n      NOVA.waitSelector(\'video\')\r\n         .then(video => {\r\n            video.addEventListener(\'volumechange\', function () {\r\n               NOVA.bezelTrigger(movie_player.getVolume() + \'%\');\r\n               playerVolume.buildVolumeSlider();\r\n               if (user_settings.volume_mute_unsave) {\r\n                  playerVolume.saveInSession(movie_player.getVolume());\r\n               }\r\n            });\r\n            if (user_settings.volume_hotkey == \'keyboard\') {\r\n               document.addEventListener(\'keydown\', evt => {\r\n                  if ([\'input\', \'textarea\', \'select\'].includes(evt.target.localName) || evt.target.isContentEditable) return;\r\n                  if (evt.ctrlKey || evt.altKey || evt.shiftKey || evt.metaKey) return;\r\n                  let delta;\r\n                  switch (evt.key) {\r\n                     case user_settings.volume_hotkey_custom_up: delta = 1; break;\r\n                     case user_settings.volume_hotkey_custom_down: delta = -1; break;\r\n                  }\r\n                  if (delta) {\r\n                     const rate = playerVolume.adjust(+user_settings.volume_step * Math.sign(delta));\r\n                  }\r\n               });\r\n            }\r\n            else if (user_settings.volume_hotkey) {\r\n               document.body.querySelector(\'.html5-video-container\')\r\n                  .addEventListener(\'wheel\', evt => {\r\n                     evt.preventDefault();\r\n                     if (evt[user_settings.volume_hotkey] || (user_settings.volume_hotkey == \'none\' && !evt.ctrlKey && !evt.altKey && !evt.shiftKey && !evt.metaKey)) {\r\n                        if (step = +user_settings.volume_step * Math.sign(evt.wheelDelta)) {\r\n                           playerVolume.adjust(step);\r\n                        }\r\n                     }\r\n                  });\r\n            }\r\n            if (+user_settings.volume_level_default) {\r\n               playerVolume.set(+user_settings.volume_level_default);\r\n            }\r\n            if (user_settings[\'save-channel-state\']) {\r\n               NOVA.runOnPageInitOrTransition(async () => {\r\n                  if ((NOVA.currentPage == \'watch\' || NOVA.currentPage == \'embed\')\r\n                     && (userVolume = await NOVA.storage_obj_manager.getParam(\'volume\'))\r\n                  ) {\r\n                     video.addEventListener(\'canplay\', () => playerVolume.set(userVolume), { capture: true, once: true });\r\n                  }\r\n               });\r\n            }\r\n         });\r\n      const playerVolume = {\r\n         adjust(delta) {\r\n            const level = movie_player?.getVolume() + +delta;\r\n            return user_settings.volume_unlimit ? this.unlimit(level) : this.set(level);\r\n         },\r\n         set(level = 50) {\r\n            if (typeof movie_player === \'undefined\' || !movie_player.hasOwnProperty(\'getVolume\')) return console.error(\'Error getVolume\');\r\n            const newLevel = Math.max(0, Math.min(100, +level));\r\n            if (newLevel !== movie_player.getVolume()) {\r\n               movie_player.isMuted() && movie_player.unMute();\r\n               movie_player.setVolume(newLevel);\r\n               if (newLevel === movie_player.getVolume()) {\r\n                  this.saveInSession(newLevel);\r\n               }\r\n               else {\r\n                  console.error(\'setVolumeLevel error! Different: %s!=%s\', newLevel, movie_player.getVolume());\r\n               }\r\n            }\r\n            return newLevel === movie_player.getVolume() && newLevel;\r\n         },\r\n         saveInSession(level = required()) {\r\n            const storageData = {\r\n               creation: Date.now(),\r\n               data: { \'volume\': +level, \'muted\': (level ? \'false\' : \'true\') },\r\n            };\r\n            try {\r\n               localStorage[\'yt-player-volume\'] = JSON.stringify(\r\n                  Object.assign({ expiration: Date.now() + 2592e6 }, storageData)\r\n               );\r\n               sessionStorage[\'yt-player-volume\'] = JSON.stringify(storageData);\r\n            } catch (err) {\r\n               console.warn(`${err.name}: save \"volume\" in sessionStorage failed. It seems that \"Block third-party cookies\" is enabled`, err.message);\r\n            }\r\n         },\r\n         unlimit(level = 300) {\r\n            if (level > 100) {\r\n               if (!this.audioCtx) {\r\n                  this.audioCtx = new AudioContext();\r\n                  const source = this.audioCtx.createMediaElementSource(NOVA.videoElement);\r\n                  this.node = this.audioCtx.createGain();\r\n                  this.node.gain.value = 1;\r\n                  source.connect(this.node);\r\n                  this.node.connect(this.audioCtx.destination);\r\n               }\r\n               if (this.node.gain.value < 7) this.node.gain.value += 1;\r\n               NOVA.bezelTrigger(movie_player.getVolume() * this.node.gain.value + \'%\');\r\n            }\r\n            else {\r\n               if (this.audioCtx && this.node.gain.value !== 1) {\r\n                  this.node.gain.value = 1;\r\n               }\r\n               this.set(level);\r\n            }\r\n         },\r\n         buildVolumeSlider(timeout_ms = 800) {\r\n            if (volumeArea = movie_player?.querySelector(\'.ytp-volume-area\')) {\r\n               if (typeof this.showTimeout === \'number\') clearTimeout(this.showTimeout);\r\n               volumeArea.dispatchEvent(new Event(\'mouseover\', { bubbles: true }));\r\n               this.showTimeout = setTimeout(() =>\r\n                  volumeArea.dispatchEvent(new Event(\'mouseout\', { bubbles: true }))\r\n                  , timeout_ms);\r\n               insertToHTML({\r\n                  \'text\': Math.round(movie_player.getVolume()),\r\n                  \'container\': volumeArea,\r\n               });\r\n            }\r\n            function insertToHTML({ text = \'\', container = required() }) {\r\n               if (!(container instanceof HTMLElement)) return console.error(\'container not HTMLElement:\', container);\r\n               const SELECTOR_ID = \'nova-volume-text\';\r\n               (document.getElementById(SELECTOR_ID) || (function () {\r\n                  const SELECTOR = \'#\' + SELECTOR_ID;\r\n                  NOVA.css.push(`\r\n                     ${SELECTOR} {\r\n                        display: none;\r\n                        text-indent: 2px;\r\n                        font-size: 110%;\r\n                        text-shadow: 0 0 2px rgba(0, 0, 0, 0.5);\r\n                        cursor: default;\r\n                     }\r\n                     ${SELECTOR}:after { content: \'%\'; }\r\n                     .ytp-volume-control-hover:not([aria-valuenow=\"0\"])+${SELECTOR} {\r\n                        display: block;\r\n                     }`)\r\n                  const el = document.createElement(\'span\');\r\n                  el.id = SELECTOR_ID;\r\n                  container.insertAdjacentElement(\'beforeend\', el);\r\n                  return el;\r\n               })())\r\n                  .textContent = text;\r\n               container.title = `${text} %`;\r\n            }\r\n         }\r\n      };\r\n   },\r\n   options: {\r\n      volume_level_default: {\r\n         _tagName: \'input\',\r\n         label: \'Default level\',\r\n         \'label:zh\': \'默认音量\',\r\n         \'label:ja\': \'デフォルトのボリューム\',\r\n         \'label:ko\': \'기본 볼륨\',\r\n         \'label:id\': \'Tingkat default\',\r\n         \'label:es\': \'Volumen predeterminado\',\r\n         \'label:pt\': \'Volume padrão\',\r\n         \'label:fr\': \'Volume par défaut\',\r\n         \'label:it\': \'Livello predefinito\',\r\n         \'label:de\': \'Standardlautstärke\',\r\n         \'label:pl\': \'Poziom domyślny\',\r\n         \'label:ua\': \'Базовий рівень\',\r\n         type: \'number\',\r\n         title: \'0 - auto\',\r\n         placeholder: \'%\',\r\n         step: 1,\r\n         min: 0,\r\n         max: 100,\r\n         value: 100,\r\n      },\r\n      volume_step: {\r\n         _tagName: \'input\',\r\n         label: \'Step\',\r\n         \'label:zh\': \'步\',\r\n         \'label:ja\': \'ステップ\',\r\n         \'label:ko\': \'단계\',\r\n         \'label:id\': \'Melangkah\',\r\n         \'label:es\': \'Paso\',\r\n         \'label:pt\': \'Degrau\',\r\n         \'label:fr\': \'Étape\',\r\n         \'label:it\': \'Fare un passo\',\r\n         \'label:de\': \'Schritt\',\r\n         \'label:pl\': \'Krok\',\r\n         \'label:ua\': \'Крок\',\r\n         type: \'number\',\r\n         title: \'in %\',\r\n         placeholder: \'%\',\r\n         step: 5,\r\n         min: 5,\r\n         max: 30,\r\n         value: 10,\r\n      },\r\n      volume_hotkey: {\r\n         _tagName: \'select\',\r\n         label: \'Hotkey\',\r\n         \'label:zh\': \'热键\',\r\n         \'label:ja\': \'ホットキー\',\r\n         \'label:ko\': \'단축키\',\r\n         \'label:id\': \'Tombol pintas\',\r\n         \'label:es\': \'Tecla de acceso rápido\',\r\n         \'label:pt\': \'Tecla de atalho\',\r\n         \'label:fr\': \'Raccourci\',\r\n         \'label:it\': \'Tasto di scelta rapida\',\r\n         \'label:de\': \'Schnelltaste\',\r\n         \'label:pl\': \'Klawisz skrótu\',\r\n         \'label:ua\': \'Гаряча клавіша\',\r\n         options: [\r\n            { label: \'wheel\', value: \'none\', selected: true },\r\n            { label: \'shift+wheel\', value: \'shiftKey\' },\r\n            { label: \'ctrl+wheel\', value: \'ctrlKey\' },\r\n            { label: \'alt+wheel\', value: \'altKey\' },\r\n            { label: \'keyboard\', value: \'keyboard\' },\r\n            { label: \'disable\', value: false },\r\n         ],\r\n      },\r\n      volume_hotkey_custom_up: {\r\n         _tagName: \'select\',\r\n         label: \'Hotkey up\',\r\n         options: [\r\n            { label: \']\', value: \']\', selected: true },\r\n            \'a\', \'b\', \'c\', \'d\', \'e\', \'f\', \'g\', \'h\', \'i\', \'j\', \'k\', \'l\', \'m\', \'n\', \'o\', \'p\', \'q\', \'s\', \'t\', \'u\', \'v\', \'w\', \'x\', \'y\', \'z\', \'[\', \'+\', \'-\', \',\', \'.\', \'/\', \'<\', \';\', \'\\\\\'\r\n         ],\r\n         \'data-dependent\': { \'volume_hotkey\': [\'keyboard\'] },\r\n      },\r\n      volume_hotkey_custom_down: {\r\n         _tagName: \'select\',\r\n         label: \'Hotkey down\',\r\n         options: [\r\n            { label: \'[\', value: \'[\', selected: true },\r\n            \'a\', \'b\', \'c\', \'d\', \'e\', \'f\', \'g\', \'h\', \'i\', \'j\', \'k\', \'l\', \'m\', \'n\', \'o\', \'p\', \'q\', \'s\', \'t\', \'u\', \'v\', \'w\', \'x\', \'y\', \'z\', \']\', \'+\', \'-\', \',\', \'.\', \'/\', \'<\', \';\', \'\\\\\'\r\n         ],\r\n         \'data-dependent\': { \'volume_hotkey\': [\'keyboard\'] },\r\n      },\r\n      volume_unlimit: {\r\n         _tagName: \'input\',\r\n         label: \'Allow above 100%\',\r\n         \'label:zh\': \'允许超过 100%\',\r\n         \'label:ja\': \'100％以上を許可する\',\r\n         \'label:ko\': \'100% 이상 허용\',\r\n         \'label:id\': \'Izinkan di atas 100%\',\r\n         \'label:es\': \'Permitir por encima del 100%\',\r\n         \'label:pt\': \'Permitir acima de 100%\',\r\n         \'label:fr\': \'Autoriser au-dessus de 100 %\',\r\n         \'label:it\': \'Consenti oltre il 100%\',\r\n         \'label:de\': \'Über 100 % zulassen\',\r\n         \'label:pl\': \'Zezwól powyżej 100%\',\r\n         \'label:ua\': \'Дозволити більше 100%\',\r\n         type: \'checkbox\',\r\n      },\r\n      volume_mute_unsave: {\r\n         _tagName: \'input\',\r\n         label: \'Not keep muted state\',\r\n         \'label:zh\': \'不保存静音模式\',\r\n         \'label:ja\': \'マナーモードを保存しない\',\r\n         \'label:ko\': \'무음 모드를 저장하지 않음\',\r\n         \'label:id\': \'Jangan simpan mode senyap\',\r\n         \'label:es\': \'No guarde el modo silencioso\',\r\n         \'label:pt\': \'Não salve o modo silencioso\',\r\n         \'label:fr\': \'Ne pas enregistrer le mode silencieux\',\r\n         \'label:it\': \'Non salvare la modalità silenziosa\',\r\n         \'label:de\': \'Silent-Modus nicht speichern\',\r\n         \'label:pl\': \'Nie zachowuj wyciszonego stanu\',\r\n         \'label:ua\': \'Не зберігати беззвучний режим\',\r\n         type: \'checkbox\',\r\n         title: \'Only affects new tabs\',\r\n         \'title:zh\': \'只影响新标签\',\r\n         \'title:ja\': \'新しいタブにのみ影響します\',\r\n         \'title:ko\': \'새 탭에만 영향\',\r\n         \'title:id\': \'Hanya memengaruhi tab baru\',\r\n         \'title:es\': \'Solo afecta a las pestañas nuevas\',\r\n         \'title:pt\': \'Afeta apenas novas guias\',\r\n         \'title:fr\': \"N\'affecte que les nouveaux onglets\",\r\n         \'title:it\': \'Riguarda solo le nuove schede\',\r\n         \'title:de\': \'Wirkt sich nur auf neue Registerkarten aus\',\r\n         \'title:pl\': \'Dotyczy tylko nowych kart\',\r\n         \'title:ua\': \'Діє лише на нові вкладки\',\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'rate-wheel\',\r\n   title: \'Playback speed control\',\r\n   \'title:zh\': \'播放速度控制\',\r\n   \'title:ja\': \'再生速度制御\',\r\n   \'title:ko\': \'재생 속도 제어\',\r\n   \'title:id\': \'Kontrol kecepatan pemutaran\',\r\n   \'title:es\': \'Controle de velocidade de reprodução\',\r\n   \'title:pt\': \'Controle de velocidade de reprodução\',\r\n   \'title:fr\': \'Contrôle de la vitesse de lecture\',\r\n   \'title:it\': \'Controllo della velocità di riproduzione\',\r\n   \'title:de\': \'Steuerung der Wiedergabegeschwindigkeit\',\r\n   \'title:pl\': \'Kontrola prędkości odtwarzania\',\r\n   \'title:ua\': \'Контроль швидкості відтворення\',\r\n   run_on_pages: \'watch, embed\',\r\n   section: \'player\',\r\n   desc: \'With mouse wheel\',\r\n   \'desc:zh\': \'带鼠标滚轮\',\r\n   \'desc:ja\': \'マウスホイール付き\',\r\n   \'desc:ko\': \'마우스 휠로\',\r\n   \'desc:id\': \'Dengan roda mouse\',\r\n   \'desc:es\': \'Con rueda de ratón\',\r\n   \'desc:pt\': \'Com roda do mouse\',\r\n   \'desc:fr\': \'Avec molette de la souris\',\r\n   \'desc:it\': \'Con rotellina del mouse\',\r\n   \'desc:de\': \'Mit mausrad\',\r\n   \'desc:pl\': \'Za pomocą kółka myszy\',\r\n   \'desc:ua\': \'За допомогою колеса мишки\',\r\n   _runtime: user_settings => {\r\n      NOVA.waitSelector(\'#movie_player video\')\r\n         .then(video => {\r\n            const sliderContainer = insertSlider.apply(video);\r\n            video.addEventListener(\'ratechange\', function () {\r\n               NOVA.bezelTrigger(this.playbackRate + \'x\');\r\n               if (Object.keys(sliderContainer).length) {\r\n                  sliderContainer.slider.value = this.playbackRate;\r\n                  sliderContainer.sliderLabel.textContent = `Speed (${this.playbackRate})`;\r\n                  sliderContainer.sliderCheckbox.checked = (this.playbackRate === 1) ? false : true;\r\n               }\r\n            });\r\n            setDefaultRate.apply(video);\r\n            video.addEventListener(\'loadeddata\', setDefaultRate);\r\n            if (Object.keys(sliderContainer).length) {\r\n               sliderContainer.slider.addEventListener(\'input\', ({ target }) => playerRate.set(target.value));\r\n               sliderContainer.slider.addEventListener(\'change\', ({ target }) => playerRate.set(target.value));\r\n               sliderContainer.slider.addEventListener(\'wheel\', evt => {\r\n                  evt.preventDefault();\r\n                  const rate = playerRate.adjust(+user_settings.rate_step * Math.sign(evt.wheelDelta));\r\n               });\r\n               sliderContainer.sliderCheckbox.addEventListener(\'change\', ({ target }) => {\r\n                  target.checked || playerRate.set(1)\r\n               });\r\n            }\r\n            NOVA.runOnPageInitOrTransition(async () => {\r\n               if (NOVA.currentPage == \'watch\' || NOVA.currentPage == \'embed\') {\r\n                  if (user_settings[\'save-channel-state\']) {\r\n                     if (userRate = await NOVA.storage_obj_manager.getParam(\'speed\')) {\r\n                        video.addEventListener(\'canplay\', () => playerRate.set(userRate), { capture: true, once: true });\r\n                     }\r\n                  }\r\n                  expandAvailableRatesMenu();\r\n               }\r\n            });\r\n         });\r\n      if (user_settings.rate_hotkey == \'keyboard\') {\r\n         document.addEventListener(\'keydown\', evt => {\r\n            if ([\'input\', \'textarea\', \'select\'].includes(evt.target.localName) || evt.target.isContentEditable) return;\r\n            if (evt.ctrlKey || evt.altKey || evt.shiftKey || evt.metaKey) return;\r\n            let delta;\r\n            switch (evt.key) {\r\n               case user_settings.rate_hotkey_custom_up: delta = 1; break;\r\n               case user_settings.rate_hotkey_custom_down: delta = -1; break;\r\n            }\r\n            if (delta) {\r\n               const rate = playerRate.adjust(+user_settings.rate_step * Math.sign(delta));\r\n            }\r\n         });\r\n      }\r\n      else if (user_settings.rate_hotkey) {\r\n         NOVA.waitSelector(\'.html5-video-container\')\r\n            .then(container => {\r\n               container.addEventListener(\'wheel\', evt => {\r\n                  evt.preventDefault();\r\n                  if (evt[user_settings.rate_hotkey]\r\n                     || (user_settings.rate_hotkey == \'none\' && !evt.ctrlKey && !evt.altKey && !evt.shiftKey && !evt.metaKey)) {\r\n                     const rate = playerRate.adjust(+user_settings.rate_step * Math.sign(evt.wheelDelta));\r\n                  }\r\n               });\r\n            });\r\n      }\r\n      if (+user_settings.rate_default !== 1 && user_settings.rate_default_apply_music) {\r\n         NOVA.waitSelector(\'#upload-info #channel-name .badge-style-type-verified-artist\')\r\n            .then(icon => playerRate.set(1));\r\n         NOVA.waitSelector(\'#upload-info #channel-name a[href]\', { stop_on_page_change: true })\r\n            .then(channelName => {\r\n               if (/(VEVO|Topic|Records|AMV)$/.test(channelName.textContent)\r\n                  || channelName.textContent.toUpperCase().includes(\'MUSIC\')\r\n               ) {\r\n                  playerRate.set(1);\r\n               }\r\n            });\r\n      }\r\n      const playerRate = {\r\n         testDefault: rate => (+rate % .25) === 0\r\n            && +rate <= 2\r\n            && +user_settings.rate_default <= 2\r\n            && (typeof movie_player !== \'undefined\' && movie_player.hasOwnProperty(\'getPlaybackRate\')),\r\n         async set(level = 1) {\r\n            this.log(\'set\', ...arguments);\r\n            if (this.testDefault(level)) {\r\n               this.log(\'set:default\');\r\n               movie_player.setPlaybackRate(+level) && this.saveInSession(level);\r\n            }\r\n            else {\r\n               this.log(\'set:html5\');\r\n               if (NOVA.videoElement) {\r\n                  NOVA.videoElement.playbackRate = +level;\r\n                  this.clearInSession();\r\n               }\r\n            }\r\n         },\r\n         adjust(rate_step = required()) {\r\n            this.log(\'adjust\', ...arguments);\r\n            return this.testDefault(rate_step) ? this.default(+rate_step) : this.html5(+rate_step);\r\n         },\r\n         default(playback_rate = required()) {\r\n            this.log(\'default\', ...arguments);\r\n            const playbackRate = movie_player.getPlaybackRate();\r\n            const inRange = step => {\r\n               const setRateStep = playbackRate + step;\r\n               return (.1 <= setRateStep && setRateStep <= 2) && +setRateStep.toFixed(2);\r\n            };\r\n            const newRate = inRange(+playback_rate);\r\n            if (newRate && newRate != playbackRate) {\r\n               movie_player.setPlaybackRate(newRate);\r\n               if (newRate === movie_player.getPlaybackRate()) {\r\n                  this.saveInSession(newRate);\r\n               }\r\n               else {\r\n                  console.error(\'playerRate:default different: %s!=%s\', newRate, movie_player.getPlaybackRate());\r\n               }\r\n            }\r\n            this.log(\'default return\', newRate);\r\n            return newRate === movie_player.getPlaybackRate() && newRate;\r\n         },\r\n         html5(playback_rate = required()) {\r\n            this.log(\'html5\', ...arguments);\r\n            if (!NOVA.videoElement) return console.error(\'playerRate > videoElement empty:\', NOVA.videoElement);\r\n            const playbackRate = NOVA.videoElement.playbackRate;\r\n            const inRange = step => {\r\n               const setRateStep = playbackRate + step;\r\n               return (.1 <= setRateStep && setRateStep <= 3) && +setRateStep.toFixed(2);\r\n            };\r\n            const newRate = inRange(+playback_rate);\r\n            if (newRate && newRate != playbackRate) {\r\n               NOVA.videoElement.playbackRate = newRate;\r\n               if (newRate === NOVA.videoElement.playbackRate) {\r\n                  this.clearInSession();\r\n               }\r\n               else {\r\n                  console.error(\'playerRate:html5 different: %s!=%s\', newRate, NOVA.videoElement.playbackRate);\r\n               }\r\n            }\r\n            this.log(\'html5 return\', newRate);\r\n            return newRate === NOVA.videoElement.playbackRate && newRate;\r\n         },\r\n         saveInSession(level = required()) {\r\n            try {\r\n               sessionStorage[\'yt-player-playback-rate\'] = JSON.stringify({\r\n                  creation: Date.now(), data: level.toString(),\r\n               })\r\n               this.log(\'playbackRate save in session:\', ...arguments);\r\n            } catch (err) {\r\n               console.warn(`${err.name}: save \"rate\" in sessionStorage failed. It seems that \"Block third-party cookies\" is enabled`, err.message);\r\n            }\r\n         },\r\n         clearInSession() {\r\n            const keyName = \'yt-player-playback-rate\';\r\n            try {\r\n               sessionStorage.hasOwnProperty(keyName) && sessionStorage.removeItem(keyName);\r\n               this.log(\'playbackRate save in session:\', ...arguments);\r\n            } catch (err) {\r\n               console.warn(`${err.name}: save \"rate\" in sessionStorage failed. It seems that \"Block third-party cookies\" is enabled`, err.message);\r\n            }\r\n         },\r\n         log() {\r\n            if (this.DEBUG && arguments.length) {\r\n               console.groupCollapsed(...arguments);\r\n               console.trace();\r\n               console.groupEnd();\r\n            }\r\n         },\r\n      };\r\n      function setDefaultRate() {\r\n         if (+user_settings.rate_default !== 1) {\r\n            const is_music = NOVA.isMusic();\r\n            if (this.playbackRate !== +user_settings.rate_default\r\n               && (!user_settings.rate_default_apply_music || !is_music)\r\n               && (!isNaN(this.duration) && this.duration > 25)\r\n            ) {\r\n               playerRate.set(user_settings.rate_default);\r\n            }\r\n            else if (this.playbackRate !== 1 && is_music) {\r\n               playerRate.set(1);\r\n            }\r\n         }\r\n      }\r\n      function insertSlider() {\r\n         const\r\n            SELECTOR_ID = \'nova-rate-slider-menu\',\r\n            SELECTOR = \'#\' + SELECTOR_ID;\r\n         NOVA.css.push(\r\n            `${SELECTOR} [type=\"range\"] {\r\n               vertical-align: text-bottom;\r\n               margin: \'0 5px\',\r\n            }\r\n            ${SELECTOR} [type=\"checkbox\"] {\r\n               appearance: none;\r\n               outline: none;\r\n               cursor: pointer;\r\n            }\r\n            ${SELECTOR} [type=\"checkbox\"]:checked {\r\n               background: #f00;\r\n            }\r\n            ${SELECTOR} [type=\"checkbox\"]:checked:after {\r\n               left: 20px;\r\n               background-color: #fff;\r\n            }`);\r\n         const slider = document.createElement(\'input\');\r\n         slider.className = \'ytp-menuitem-slider\';\r\n         slider.type = \'range\';\r\n         slider.min = +user_settings.rate_step;\r\n         slider.max = Math.max(2, +user_settings.rate_default);\r\n         slider.step = +user_settings.rate_step;\r\n         slider.value = this.playbackRate;\r\n         const sliderIcon = document.createElement(\'div\');\r\n         sliderIcon.className = \'ytp-menuitem-icon\';\r\n         const sliderLabel = document.createElement(\'div\');\r\n         sliderLabel.className = \'ytp-menuitem-label\';\r\n         sliderLabel.textContent = `Speed (${this.playbackRate})`;\r\n         const sliderCheckbox = document.createElement(\'input\');\r\n         sliderCheckbox.className = \'ytp-menuitem-toggle-checkbox\';\r\n         sliderCheckbox.type = \'checkbox\';\r\n         sliderCheckbox.title = \'Remember speed\';\r\n         const out = {};\r\n         const right = document.createElement(\'div\');\r\n         right.className = \'ytp-menuitem-content\';\r\n         out.sliderCheckbox = right.appendChild(sliderCheckbox);\r\n         out.slider = right.appendChild(slider);\r\n         const speedMenu = document.createElement(\'div\');\r\n         speedMenu.className = \'ytp-menuitem\';\r\n         speedMenu.id = SELECTOR_ID;\r\n         speedMenu.append(sliderIcon);\r\n         out.sliderLabel = speedMenu.appendChild(sliderLabel);\r\n         speedMenu.append(right);\r\n         document.body.querySelector(\'.ytp-panel-menu\')\r\n            ?.append(speedMenu);\r\n         return out;\r\n      }\r\n      function expandAvailableRatesMenu() {\r\n         if (typeof _yt_player !== \'object\') {\r\n            return console.error(\'expandAvailableRatesMenu > _yt_player is empty\', _yt_player);\r\n         }\r\n         if (path = findPathInObj({ \'obj\': _yt_player, \'keys\': \'getAvailablePlaybackRates\' })) {\r\n            setAvailableRates(_yt_player, 0, path.split(\'.\'));\r\n         }\r\n         function findPathInObj({ obj = required(), keys = required(), path }) {\r\n            const setPath = d => (path ? path + \'.\' : \'\') + d;\r\n            for (const prop in obj) {\r\n               if (obj.hasOwnProperty(prop) && obj[prop]) {\r\n                  if (keys === prop) {\r\n                     return this.path = setPath(prop)\r\n                  }\r\n                  if (obj[prop].constructor.name == \'Function\' && Object.keys(obj[prop]).length) {\r\n                     for (const j in obj[prop]) {\r\n                        if (typeof obj[prop] !== \'undefined\') {\r\n                           findPathInObj({\r\n                              \'obj\': obj[prop][j],\r\n                              \'keys\': keys,\r\n                              \'path\': setPath(prop) + \'.\' + j,\r\n                           });\r\n                        }\r\n                        if (this.path) return this.path;\r\n                     }\r\n                  }\r\n               }\r\n            }\r\n         }\r\n         function setAvailableRates(path, idx, arr) {\r\n            if (arr.length - 1 == idx) {\r\n               path[arr[idx]] = () => [.25, .5, .75, 1, 1.25, 1.5, 1.75, 2, 2.25, 2.5, 2.75, 3, 3.25, 3.5, 3.75, 4, 10];\r\n            }\r\n            else {\r\n               setAvailableRates(path[arr[idx]], idx + 1, arr);\r\n            }\r\n         }\r\n      }\r\n   },\r\n   options: {\r\n      rate_default: {\r\n         _tagName: \'input\',\r\n         label: \'Speed at startup\',\r\n         \'label:zh\': \'启动速度\',\r\n         \'label:ja\': \'起動時の速度\',\r\n         \'label:ko\': \'시작 시 속도\',\r\n         \'label:id\': \'Kecepatan saat startup\',\r\n         \'label:es\': \'Velocidad al inicio\',\r\n         \'label:pt\': \'Velocidade na inicialização\',\r\n         \'label:fr\': \'Rapidité au démarrage\',\r\n         \'label:it\': \"Velocità all\'avvio\",\r\n         \'label:de\': \'Geschwindigkeit beim Start\',\r\n         \'label:pl\': \'Prędkość przy uruchamianiu\',\r\n         \'label:ua\': \'Звичайна швидкість\',\r\n         type: \'number\',\r\n         title: \'1 - default\',\r\n         step: 0.05,\r\n         min: 1,\r\n         value: 1,\r\n      },\r\n      rate_default_apply_music: {\r\n         _tagName: \'select\',\r\n         label: \'For music genre\',\r\n         title: \'Extended detection - may trigger falsely\',\r\n         \'title:zh\': \'扩展检测 - 可能会错误触发\',\r\n         \'title:ja\': \'拡張検出-誤ってトリガーされる可能性があります\',\r\n         \'title:ko\': \'확장 감지 - 잘못 트리거될 수 있음\',\r\n         \'title:id\': \'Deteksi diperpanjang - dapat memicu salah\',\r\n         \'title:pt\': \'Detecção estendida - pode disparar falsamente\',\r\n         \'title:fr\': \'Détection étendue - peut se déclencher par erreur\',\r\n         \'title:it\': \'Rilevamento esteso - potrebbe attivarsi in modo errato\',\r\n         \'title:de\': \'Erweiterte Erkennung - kann fälschlicherweise auslösen\',\r\n         \'title:pl\': \'Rozszerzona detekcja - może działać błędnie\',\r\n         \'title:ua\': \'Розширене виявлення - може спрацювати помилково\',\r\n         options: [\r\n            {\r\n               label: \'skip\', value: true, selected: true,\r\n               \'label:zh\': \'跳过\',\r\n               \'label:ja\': \'スキップ\',\r\n               \'label:ko\': \'건너 뛰기\',\r\n               \'label:id\': \'merindukan\',\r\n               \'label:es\': \'saltar\',\r\n               \'label:pt\': \'pular\',\r\n               \'label:fr\': \'sauter\',\r\n               \'label:it\': \'Perdere\',\r\n               \'label:de\': \'überspringen\',\r\n               \'label:pl\': \'tęsknić\',\r\n               \'label:ua\': \'пропустити\',\r\n            },\r\n            {\r\n               label: \'force apply\', value: false,\r\n               \'label:zh\': \'施力\',\r\n               \'label:ja\': \'力を加える\',\r\n               \'label:ko\': \'강제 적용\',\r\n               \'label:id\': \'berlaku paksa\',\r\n               \'label:es\': \'aplicar fuerza\',\r\n               \'label:pt\': \'aplicar força\',\r\n               \'label:fr\': \'appliquer la force\',\r\n               \'label:it\': \'applicare la forza\',\r\n               \'label:de\': \'kraft anwenden\',\r\n               \'label:pl\': \'zastosować siłę\',\r\n               \'label:ua\': \'примусово активувати\',\r\n            },\r\n         ],\r\n         \'data-dependent\': { \'rate_default\': \'!1\' },\r\n      },\r\n      rate_step: {\r\n         _tagName: \'input\',\r\n         label: \'Step\',\r\n         \'label:zh\': \'步\',\r\n         \'label:ja\': \'ステップ\',\r\n         \'label:ko\': \'단계\',\r\n         \'label:id\': \'Melangkah\',\r\n         \'label:es\': \'Paso\',\r\n         \'label:pt\': \'Degrau\',\r\n         \'label:fr\': \'Étape\',\r\n         \'label:it\': \'Fare un passo\',\r\n         \'label:de\': \'Schritt\',\r\n         \'label:pl\': \'Krok\',\r\n         \'label:ua\': \'Крок\',\r\n         type: \'number\',\r\n         title: \'0.25 - default\',\r\n         placeholder: \'0.1-1\',\r\n         step: 0.05,\r\n         min: 0.1,\r\n         max: 0.5,\r\n         value: 0.25,\r\n      },\r\n      rate_hotkey: {\r\n         _tagName: \'select\',\r\n         label: \'Hotkey\',\r\n         \'label:zh\': \'热键\',\r\n         \'label:ja\': \'ホットキー\',\r\n         \'label:ko\': \'단축키\',\r\n         \'label:id\': \'Tombol pintas\',\r\n         \'label:es\': \'Tecla de acceso rápido\',\r\n         \'label:pt\': \'Tecla de atalho\',\r\n         \'label:fr\': \'Raccourci\',\r\n         \'label:it\': \'Tasto di scelta rapida\',\r\n         \'label:de\': \'Schnelltaste\',\r\n         \'label:pl\': \'Klawisz skrótu\',\r\n         \'label:ua\': \'Гаряча клавіша\',\r\n         options: [\r\n            { label: \'alt+wheel\', value: \'altKey\', selected: true },\r\n            { label: \'shift+wheel\', value: \'shiftKey\' },\r\n            { label: \'ctrl+wheel\', value: \'ctrlKey\' },\r\n            { label: \'wheel\', value: \'none\' },\r\n            { label: \'keyboard\', value: \'keyboard\' },\r\n            { label: \'disable\', value: false },\r\n         ],\r\n      },\r\n      rate_hotkey_custom_up: {\r\n         _tagName: \'select\',\r\n         label: \'Hotkey up\',\r\n         options: [\r\n            { label: \']\', value: \']\', selected: true },\r\n            \'a\', \'b\', \'c\', \'d\', \'e\', \'f\', \'g\', \'h\', \'i\', \'j\', \'k\', \'l\', \'m\', \'n\', \'o\', \'p\', \'q\', \'s\', \'t\', \'u\', \'v\', \'w\', \'x\', \'y\', \'z\', \'[\', \'+\', \'-\', \',\', \'.\', \'/\', \'<\', \';\', \'\\\\\'\r\n         ],\r\n         \'data-dependent\': { \'rate_hotkey\': [\'keyboard\'] },\r\n      },\r\n      rate_hotkey_custom_down: {\r\n         _tagName: \'select\',\r\n         label: \'Hotkey down\',\r\n         options: [\r\n            { label: \'[\', value: \'[\', selected: true },\r\n            \'a\', \'b\', \'c\', \'d\', \'e\', \'f\', \'g\', \'h\', \'i\', \'j\', \'k\', \'l\', \'m\', \'n\', \'o\', \'p\', \'q\', \'s\', \'t\', \'u\', \'v\', \'w\', \'x\', \'y\', \'z\', \']\', \'+\', \'-\', \',\', \'.\', \'/\', \'<\', \';\', \'\\\\\'\r\n         ],\r\n         \'data-dependent\': { \'rate_hotkey\': [\'keyboard\'] },\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'pause-background-tab\',\r\n   title: \'Autopause when switching tabs\',\r\n   \'title:zh\': \'自动暂停除活动选项卡以外的所有选项卡\',\r\n   \'title:ja\': \'アクティブなタブを除くすべてのタブを自動一時停止\',\r\n   \'title:ko\': \'활성 탭을 제외한 모든 탭 자동 일시 중지\',\r\n   \'title:id\': \'Jeda otomatis semua tab latar belakang kecuali yang aktif\',\r\n   \'title:es\': \'Pausar automáticamente todas las pestañas excepto la activa\',\r\n   \'title:pt\': \'Pausar automaticamente todas as guias, exceto a ativa\',\r\n   \'title:fr\': \"Interrompt la lecture des vidéos dans d\'autres onglets\",\r\n   \'title:it\': \'Metti automaticamente in pausa tutte le schede in background tranne quella attiva\',\r\n   \'title:de\': \'Alle Tabs außer dem aktiven automatisch pausieren\',\r\n   \'title:pl\': \'Zatrzymanie kart w tle oprócz aktywnej\',\r\n   \'title:ua\': \'Автопауза усіх фонових вкладок окрім активної\',\r\n   run_on_pages: \'watch, embed\',\r\n   section: \'player\',\r\n   desc: \'Autopause all background tabs except the active one\',\r\n   \'desc:ua\': \'Автоматично призупинити всі фонові вкладки, крім активної. Підтримує iframe та інші вікна\',\r\n   _runtime: user_settings => {\r\n      if (location.hostname.includes(\'youtube-nocookie.com\')) location.hostname = \'youtube.com\';\r\n      if (typeof window === \'undefined\') return;\r\n      const\r\n         storeName = \'nova-playing-instanceIDTab\',\r\n         instanceID = String(Math.random()),\r\n         removeStorage = () => localStorage.removeItem(storeName);\r\n      NOVA.waitSelector(\'video\')\r\n         .then(video => {\r\n            video.addEventListener(\'play\', checkInstance);\r\n            video.addEventListener(\'playing\', checkInstance);\r\n            [\'pause\', \'ended\'].forEach(evt => video.addEventListener(evt, removeStorage));\r\n            window.addEventListener(\'beforeunload\', removeStorage);\r\n            window.addEventListener(\'storage\', store => {\r\n               if ((!document.hasFocus() || NOVA.currentPage == \'embed\')\r\n                  && store.key === storeName && store.storageArea === localStorage\r\n                  && localStorage.hasOwnProperty(storeName) && localStorage.getItem(storeName) !== instanceID\r\n                  && \'PLAYING\' == NOVA.getPlayerState()\r\n               ) {\r\n                  video.pause();\r\n               }\r\n            });\r\n            if (user_settings.pause_background_tab_autoplay_onfocus) {\r\n               window.addEventListener(\'focus\', () => {\r\n                  if (!localStorage.hasOwnProperty(storeName) && localStorage.getItem(storeName) !== instanceID\r\n                     && [\'UNSTARTED\', \'PAUSED\'].includes(NOVA.getPlayerState())\r\n                  ) {\r\n                     video.play();\r\n                  }\r\n               }, user_settings.pause_background_tab_autoplay_onfocus == \'force\' ? false : { capture: true, once: true });\r\n            }\r\n            if (user_settings.pause_background_tab_autopause_unfocus) {\r\n               window.addEventListener(\'blur\', () => {\r\n                  if (document.visibilityState == \'hidden\' && \'PLAYING\' == NOVA.getPlayerState()) {\r\n                     video.pause();\r\n                  }\r\n               });\r\n            }\r\n            function checkInstance() {\r\n               if (user_settings.pause_background_tab_autoplay_onfocus !== true\r\n                  && localStorage.hasOwnProperty(storeName) && localStorage.getItem(storeName) !== instanceID\r\n               ) {\r\n                  video.pause();\r\n               }\r\n               else {\r\n                  localStorage.setItem(storeName, instanceID);\r\n               }\r\n            }\r\n         });\r\n   },\r\n   options: {\r\n      pause_background_tab_autoplay_onfocus: {\r\n         _tagName: \'select\',\r\n         label: \'Autoplay on tab focus\',\r\n         \'label:zh\': \'在标签焦点上自动播放\',\r\n         \'label:ja\': \'タブフォーカスでの自動再生\',\r\n         \'label:ko\': \'탭 포커스에서 자동 재생\',\r\n         \'label:id\': \'Putar otomatis pada fokus tab\',\r\n         \'label:es\': \'Reproducción automática en el enfoque de la pestaña\',\r\n         \'label:pt\': \'Reprodução automática no foco da guia\',\r\n         \'label:fr\': \"Lecture automatique sur le focus de l\'onglet\",\r\n         \'label:it\': \'Riproduzione automatica su tab focus\',\r\n         \'label:de\': \'Autoplay bei Tab-Fokus\',\r\n         \'label:pl\': \'Autoodtwarzanie po wybraniu karty\',\r\n         \'label:ua\': \'Автовідтворення при виборі вкладки\',\r\n         options: [\r\n            {\r\n               label: \'disable\', selected: true,\r\n            },\r\n            {\r\n               label: \'once for new tab\', value: true,\r\n            },\r\n            {\r\n               label: \'always for not started\', value: \'force\',\r\n            },\r\n         ],\r\n      },\r\n      pause_background_tab_autopause_unfocus: {\r\n         _tagName: \'input\',\r\n         label: \'Autopause if tab loses focus\',\r\n         \'label:zh\': \'如果选项卡失去焦点，则自动暂停视频\',\r\n         \'label:ja\': \'タブがフォーカスを失った場合にビデオを自動一時停止\',\r\n         \'label:ko\': \'탭이 초점을 잃으면 비디오 자동 일시 중지\',\r\n         \'label:id\': \'Jeda otomatis video jika tab kehilangan fokus\',\r\n         \'label:es\': \'Pausa automática del video si la pestaña pierde el foco\',\r\n         \'label:pt\': \'Pausar automaticamente o vídeo se a guia perder o foco\',\r\n         \'label:fr\': \"Pause automatique de la vidéo si l\'onglet perd le focus\",\r\n         \'label:it\': \'Metti automaticamente in pausa il video se la scheda perde la messa a fuoco\',\r\n         \'label:de\': \'Video automatisch pausieren, wenn der Tab den Fokus verliert\',\r\n         \'label:pl\': \'Automatycznie wstrzymaj wideo, jeśli karta straci ostrość\',\r\n         \'label:ua\': \'Автопауза при зміні вкладки\',\r\n         type: \'checkbox\',\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'sidebar-channel-links-patch\',\r\n   title: \'Fix channel links in sidebar\',\r\n   \'title:zh\': \'修复侧边栏中的频道链接\',\r\n   \'title:ja\': \'サイドバーのチャネルリンクを修正\',\r\n   \'title:ko\': \'사이드바에서 채널 링크 수정\',\r\n   \'title:id\': \'Perbaiki tautan saluran di bilah sisi\',\r\n   \'title:es\': \'Arreglar enlaces de canales en la barra lateral\',\r\n   \'title:pt\': \'Corrigir links de canais na barra lateral\',\r\n   \'title:fr\': \'Correction des liens de chaîne dans la barre latérale\',\r\n   \'title:it\': \'Correggi i collegamenti ai canali nella barra laterale\',\r\n   \'title:de\': \'Korrigieren Sie die Kanallinks in der Seitenleiste\',\r\n   \'title:pl\': \'Napraw linki do kanałów na pasku bocznym\',\r\n   \'title:ua\': \'Виправити посилання на канали на бічній панелі\',\r\n   run_on_pages: \'watch, -mobile\',\r\n   section: \'sidebar\',\r\n   _runtime: user_settings => {\r\n      document.addEventListener(\'mouseover\', ({ target }) => {\r\n         //console.debug(\'>\', target);\r\n         if (!target.matches(\'.ytd-channel-name\')) return;\r\n         if ((link = target.closest(\'a\'))\r\n            && target.__data?.text?.runs.length\r\n            && target.__data?.text?.runs[0].navigationEndpoint?.commandMetadata?.webCommandMetadata?.webPageType == \'WEB_PAGE_TYPE_CHANNEL\'\r\n         ) {\r\n            //const urlOrig = \'/watch?v=\' + link.data.watchEndpoint.videoId;\r\n            const urlOrig = link.href;\r\n            const url = target.__data.text.runs[0].navigationEndpoint.commandMetadata.webCommandMetadata.url + \'/videos\';\r\n            link.href = url;\r\n            link.data.commandMetadata.webCommandMetadata.url = url;\r\n            link.data.commandMetadata.webCommandMetadata.webPageType = \'WEB_PAGE_TYPE_CHANNEL\';\r\n            link.data.browseEndpoint = target.__data.text.runs[0].navigationEndpoint.browseEndpoint;\r\n            link.data.browseEndpoint.params = encodeURIComponent(btoa(String.fromCharCode(0x12, 0x06) + \'videos\'));\r\n            //console.debug(\'patch link:\', 1);\r\n            target.addEventListener(\'mouseout\', ({ target }) => {\r\n               link.href = urlOrig;\r\n               link.data.commandMetadata.webCommandMetadata.url = urlOrig;\r\n               link.data.commandMetadata.webCommandMetadata.webPageType = \'WEB_PAGE_TYPE_WATCH\';\r\n               //console.debug(\'restore link:\', 2);\r\n            }, { capture: true, once: true });\r\n         }\r\n      })\r\n   },\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'livechat-visibility\',\r\n   title: \'Collapse live chat\',\r\n   \'title:zh\': \'隐藏实时聊天\',\r\n   \'title:ja\': \'ライブチャットを非表示\',\r\n   \'title:ko\': \'실시간 채팅 숨기기\',\r\n   \'title:id\': \'Sembunyikan obrolan langsung\',\r\n   \'title:es\': \'Ocultar chat en vivo\',\r\n   \'title:pt\': \'Ocultar livechat\',\r\n   \'title:fr\': \'Masquer le chat en direct\',\r\n   \'title:it\': \'Nascondi chat dal vivo\',\r\n   \'title:de\': \'Livechat ausblenden\',\r\n   \'title:pl\': \'Ukryj czat na żywo\',\r\n   \'title:ua\': \'Приховати чат\',\r\n   run_on_pages: \'watch, -mobile\',\r\n   restart_on_location_change: true,\r\n   section: \'sidebar\',\r\n   _runtime: user_settings => {\r\n      if (user_settings.livechat_visibility_mode == \'disable\') {\r\n         NOVA.waitSelector(\'#chat\', { stop_on_page_change: true })\r\n            .then(chat => {\r\n               chat.remove();\r\n            });\r\n      }\r\n      else {\r\n         NOVA.waitSelector(\'#chat:not([collapsed]) #show-hide-button button\', { stop_on_page_change: true })\r\n            .then(btn => {\r\n               btn.click();\r\n            });\r\n      }\r\n   },\r\n   options: {\r\n      livechat_visibility_mode: {\r\n         _tagName: \'select\',\r\n         label: \'Mode\',\r\n         \'label:zh\': \'模式\',\r\n         \'label:ja\': \'モード\',\r\n         \'label:ko\': \'방법\',\r\n         \'label:es\': \'Modo\',\r\n         \'label:pt\': \'Modo\',\r\n         \'label:it\': \'Mode\',\r\n         \'label:de\': \'Modus\',\r\n         \'label:pl\': \'Tryb\',\r\n         \'label:ua\': \'Режим\',\r\n         options: [\r\n            {\r\n               label: \'collapse\', value: \'hide\', selected: true,\r\n               \'label:pl\': \'zwiń\',\r\n               \'label:ua\': \'приховати\',\r\n            },\r\n            {\r\n               label: \'remove\', value: \'disable\',\r\n               \'label:zh\': \'消除\',\r\n               \'label:ja\': \'削除\',\r\n               \'label:ko\': \'제거하다\',\r\n               \'label:id\': \'menghapus\',\r\n               \'label:es\': \'eliminar\',\r\n               \'label:pt\': \'remover\',\r\n               \'label:fr\': \'retirer\',\r\n               \'label:it\': \'rimuovere\',\r\n               \'label:de\': \'entfernen\',\r\n               \'label:pl\': \'usunąć\',\r\n               \'label:ua\': \'видалити\',\r\n            },\r\n         ],\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'playlist-collapse\',\r\n   title: \'Collapse playlist\',\r\n   \'title:zh\': \'播放列表自动折叠\',\r\n   \'title:ja\': \'プレイリストの自動折りたたみ\',\r\n   \'title:ko\': \'재생목록 자동 축소\',\r\n   \'title:id\': \'Penciutan otomatis daftar putar\',\r\n   \'title:es\': \'Contraer automáticamente la lista de reproducción\',\r\n   \'title:pt\': \'Recolhimento automático da lista de reprodução\',\r\n   \'title:fr\': \'Réduction automatique de la liste de lecture\',\r\n   \'title:it\': \'Comprimi automaticamente la playlist\',\r\n   \'title:de\': \'Automatische Minimierung der Wiedergabeliste\',\r\n   \'title:pl\': \'Automatyczne zwijanie listy odtwarzania\',\r\n   \'title:ua\': \'Автоматичне згортання списку відтворення\',\r\n   run_on_pages: \'watch, -mobile\',\r\n   section: \'sidebar\',\r\n   _runtime: user_settings => {\r\n      if (!location.search.includes(\'list=\')) return;\r\n      NOVA.waitSelector(\'#secondary #playlist:not([collapsed]) #expand-button button\')\r\n         .then(btn => {\r\n            if (user_settings.playlist_collapse_ignore_theater && document.body.querySelector(\'ytd-watch-flexy[theater]\')) return;\r\n            if (user_settings.playlist_collapse_ignore_music && NOVA.isMusic()) return;\r\n            btn.click();\r\n         });\r\n   },\r\n   options: {\r\n      playlist_collapse_ignore_theater: {\r\n         _tagName: \'input\',\r\n         label: \'Ignore in theater mode\',\r\n         \'label:zh\': \'在影院模式下忽略\',\r\n         \'label:ja\': \'シアターモードでは無視\',\r\n         \'label:ko\': \'극장 모드에서 무시\',\r\n         \'label:id\': \'Abaikan dalam mode teater\',\r\n         \'label:es\': \'Ignorar en modo teatro\',\r\n         \'label:pt\': \'Ignorar no modo teatro\',\r\n         \'label:fr\': \'Ignorer en mode théâtre\',\r\n         \'label:it\': \'Ignora in modalità teatro\',\r\n         \'label:de\': \'Im Kinomodus ignorieren\',\r\n         \'label:pl\': \'Ignoruj w trybie kinowym\',\r\n         \'label:ua\': \'Ігнорувати в режимі театру\',\r\n         type: \'checkbox\',\r\n      },\r\n      playlist_collapse_ignore_music: {\r\n         _tagName: \'input\',\r\n         label: \'Ignore music\',\r\n         \'label:zh\': \'忽略音乐\',\r\n         \'label:ja\': \'音楽を無視\',\r\n         \'label:ko\': \'음악 무시\',\r\n         \'label:id\': \'Abaikan musik\',\r\n         \'label:es\': \'ignorar la musica\',\r\n         \'label:pt\': \'Ignorar música\',\r\n         \'label:fr\': \'Ignorer la musique\',\r\n         \'label:it\': \'Ignora la musica\',\r\n         \'label:de\': \'Musik ignorieren\',\r\n         \'label:pl\': \'Ignoruj ​​muzykę\',\r\n         \'label:ua\': \'Ігноруйте музику\',\r\n         type: \'checkbox\',\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'playlist-extended\',\r\n   title: \'Extended playlist length\',\r\n   \'title:ua\': \'Розширена довжина списку відтворення\',\r\n   run_on_pages: \'watch, -mobile\',\r\n   section: \'sidebar\',\r\n   _runtime: user_settings => {\r\n      NOVA.css.push(\r\n         `ytd-watch-flexy:not([theater]) #secondary #playlist {\r\n            --ytd-watch-flexy-panel-max-height: 90vh !important;\r\n         }`);\r\n   },\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'playlist-toggle-autoplay\',\r\n   title: \'Add playlist autoplay control button\',\r\n   \'title:zh\': \'播放列表自动播放控制\',\r\n   \'title:ja\': \'プレイリストの自動再生コントロール\',\r\n   \'title:ko\': \'재생 목록 자동 재생 제어\',\r\n   \'title:id\': \'Tombol kontrol putar otomatis daftar putar\',\r\n   \'title:es\': \'Control de reproducción automática de listas de reproducción\',\r\n   \'title:pt\': \'Controle de reprodução automática da lista de reprodução\',\r\n   \'title:fr\': \'Contrôle de lecture automatique de la liste de lecture\',\r\n   \'title:it\': \'Pulsante di controllo della riproduzione automatica della playlist\',\r\n   \'title:de\': \'Steuerung der automatischen Wiedergabe von Wiedergabelisten\',\r\n   \'title:pl\': \'Kontrola autoodtwarzania listy odtwarzania\',\r\n   \'title:ua\': \'Кнопка керування автовідтворенням\',\r\n   run_on_pages: \'watch, -mobile\',\r\n   section: \'sidebar\',\r\n   _runtime: user_settings => {\r\n      const\r\n         SELECTOR_ID = \'nova-playlist-autoplay-btn\',\r\n         SELECTOR = \'#\' + SELECTOR_ID;\r\n      let sesionAutoplayState = user_settings.playlist_autoplay;\r\n      NOVA.css.push(\r\n         `#playlist-action-menu .top-level-buttons {\r\n            align-items: center;\r\n         }\r\n         ${SELECTOR}[type=checkbox] {\r\n            --height: 1em;\r\n            width: 2.2em;\r\n         }\r\n         ${SELECTOR}[type=checkbox]:after {\r\n            transform: scale(1.5);\r\n         }\r\n         ${SELECTOR}[type=checkbox] {\r\n            --opacity: .7;\r\n            --color: #fff;\r\n            height: var(--height);\r\n            line-height: 1.6em;\r\n            border-radius: 3em;\r\n            background-color: var(--paper-toggle-button-unchecked-bar-color, #000000);\r\n            appearance: none;\r\n            -webkit-appearance: none;\r\n            position: relative;\r\n            cursor: pointer;\r\n            outline: 0;\r\n            border: none;\r\n         }\r\n         ${SELECTOR}[type=checkbox]:after {\r\n            position: absolute;\r\n            top: 0;\r\n            left: 0;\r\n            content: \'\';\r\n            width: var(--height);\r\n            height: var(--height);\r\n            border-radius: 50%;\r\n            background-color: var(--color);\r\n            box-shadow: 0 0 .25em rgba(0, 0, 0, .3);\r\n            \r\n         }\r\n         ${SELECTOR}[type=checkbox]:checked:after {\r\n            left: calc(100% - var(--height));\r\n            --color: var(--paper-toggle-button-checked-button-color, var(--primary-color));\r\n         }\r\n         ${SELECTOR}[type=checkbox]:focus, input[type=checkbox]:focus:after {\r\n            transition: all 200ms ease-in-out;\r\n         }\r\n         ${SELECTOR}[type=checkbox]:disabled {\r\n            opacity: .3;\r\n         }`);\r\n      NOVA.runOnPageInitOrTransition(() => {\r\n         if (location.search.includes(\'list=\') && NOVA.currentPage == \'watch\') {\r\n            insertButton();\r\n         }\r\n      });\r\n      function insertButton() {\r\n         NOVA.waitSelector(\'ytd-watch-flexy.ytd-page-manager:not([hidden]) ytd-playlist-panel-renderer:not([collapsed]) #playlist-action-menu .top-level-buttons:not([hidden]), #secondary #playlist #playlist-action-menu #top-level-buttons-computed\', { stop_on_page_change: true })\r\n            .then(el => renderCheckbox(el));\r\n         function renderCheckbox(container = required()) {\r\n            if (!(container instanceof HTMLElement)) return console.error(\'container not HTMLElement:\', container);\r\n            document.getElementById(SELECTOR_ID)?.remove();\r\n            const checkboxBtn = document.createElement(\'input\');\r\n            checkboxBtn.id = SELECTOR_ID;\r\n            checkboxBtn.type = \'checkbox\';\r\n            checkboxBtn.title = \'Playlist toggle autoplay\';\r\n            checkboxBtn.addEventListener(\'change\', ({ target }) => {\r\n               sesionAutoplayState = target.checked;\r\n               setAssociatedAutoplay();\r\n            });\r\n            container.append(checkboxBtn);\r\n            checkboxBtn.checked = sesionAutoplayState;\r\n            setAssociatedAutoplay();\r\n            function setAssociatedAutoplay() {\r\n               if (manager = document.body.querySelector(\'yt-playlist-manager\')) {\r\n                  manager.interceptedForAutoplay = true;\r\n                  manager.canAutoAdvance_ = checkboxBtn.checked;\r\n                  checkboxBtn.checked = manager?.canAutoAdvance_;\r\n                  checkboxBtn.title = `Playlist Autoplay is ${manager?.canAutoAdvance_ ? \'ON\' : \'OFF\'}`;\r\n                  if (checkboxBtn.checked) checkHiddenVideo();\r\n               }\r\n               else console.error(\'Error playlist-autoplay. Playlist manager is\', manager);\r\n               async function checkHiddenVideo() {\r\n                  const ytdWatch = document.body.querySelector(\'ytd-watch-flexy\');\r\n                  let vids_list;\r\n                  await NOVA.waitUntil(() => {\r\n                     if ((vids_list =\r\n                        ytdWatch?.data?.contents?.twoColumnWatchNextResults?.playlist?.playlist?.contents\r\n                        || ytdWatch?.data?.playlist?.playlist?.contents\r\n                     )\r\n                        && vids_list.length) return true;\r\n                  }, 1000);\r\n                  const\r\n                     currentIndex = movie_player.getPlaylistIndex(),\r\n                     lastAvailableIdx = vids_list.findIndex(i => i.hasOwnProperty(\'messageRenderer\')) - 1;\r\n                  if (currentIndex === lastAvailableIdx) {\r\n                     manager.canAutoAdvance_ = false;\r\n                     alert(\'Nova [playlist-toggle-autoplay]:\\nPlaylist has hide video. Playlist autoplay disabled\');\r\n                     checkboxBtn.checked = false;\r\n                  }\r\n               }\r\n            }\r\n         }\r\n      }\r\n   },\r\n   options: {\r\n      playlist_autoplay: {\r\n         _tagName: \'select\',\r\n         label: \'Default state\',\r\n         \'label:zh\': \'默认状态\',\r\n         \'label:ja\': \'デフォルト状態\',\r\n         \'label:ko\': \'기본 상태\',\r\n         \'label:es\': \'Estado predeterminado\',\r\n         \'label:pt\': \'Estado padrão\',\r\n         \'label:fr\': \'État par défaut\',\r\n         \'label:it\': \'Stato predefinito\',\r\n         \'label:de\': \'Standardzustand\',\r\n         \'label:pl\': \'Stan domyślny\',\r\n         \'label:ua\': \'Cтан за замовчуваням\',\r\n         options: [\r\n            {\r\n               label: \'play\', value: true, selected: true,\r\n               \'label:ua\': \'грати\',\r\n            },\r\n            {\r\n               label: \'stop\', value: false,\r\n               \'label:ua\': \'зупинити\',\r\n            },\r\n         ],\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'playlist-reverse\',\r\n   title: \'Add playlist reverse order button\',\r\n   \'title:zh\': \'添加按钮反向播放列表顺序\',\r\n   \'title:ja\': \'ボタンの逆プレイリストの順序を追加\',\r\n   \'title:ko\': \'버튼 역 재생 목록 순서 추가\',\r\n   \'title:id\': \'Tambahkan tombol urutan terbalik daftar putar\',\r\n   \'title:es\': \'Agregar orden de lista de reproducción inverso\',\r\n   \'title:pt\': \'Adicionar ordem inversa da lista de reprodução\',\r\n   \'title:fr\': \'Ajouter un ordre de lecture inversé\',\r\n   \'title:it\': \"Aggiungi il pulsante dell\'ordine inverso della playlist\",\r\n   \'title:de\': \'Umgekehrte Playlist-Reihenfolge hinzufügen\',\r\n   \'title:pl\': \'Dodaj przycisk odtwarzania w odwrotnej kolejności\',\r\n   \'title:ua\': \'Кнопка додавання списку відтворення у зворотному порядку\',\r\n   run_on_pages: \'watch, -mobile\',\r\n   section: \'sidebar\',\r\n   _runtime: user_settings => {\r\n      const\r\n         SELECTOR_ID = \'nova-playlist-reverse-btn\',\r\n         SELECTOR = \'#\' + SELECTOR_ID,\r\n         CLASS_NAME_ACTIVE = \'nova-playlist-reverse-on\';\r\n      window.nova_playlistReversed;\r\n      NOVA.css.push(\r\n         SELECTOR + ` {\r\n            background: none;\r\n            border: 0;\r\n         }\r\n         yt-icon-button {\r\n            width: 40px;\r\n            height: 40px;\r\n            padding: 10px;\r\n         }\r\n         ${SELECTOR} svg {\r\n            fill: white;\r\n            fill: var(--yt-spec-text-secondary);\r\n         }\r\n         ${SELECTOR}:hover svg { fill: #66afe9; }\r\n         ${SELECTOR}:active svg,\r\n         ${SELECTOR}.${CLASS_NAME_ACTIVE} svg { fill: #2196f3; }`);\r\n      NOVA.runOnPageInitOrTransition(() => {\r\n         if (location.search.includes(\'list=\') && NOVA.currentPage == \'watch\') {\r\n            insertButton();\r\n            reverseControl();\r\n         }\r\n      });\r\n      function insertButton() {\r\n         NOVA.waitSelector(\'ytd-watch-flexy.ytd-page-manager:not([hidden]) ytd-playlist-panel-renderer:not([collapsed]) #playlist-action-menu .top-level-buttons:not([hidden]), #secondary #playlist #playlist-action-menu #top-level-buttons-computed\', { stop_on_page_change: true })\r\n            .then(el => createButton(el));\r\n         function createButton(container = required()) {\r\n            if (!(container instanceof HTMLElement)) return console.error(\'container not HTMLElement:\', container);\r\n            document.getElementById(SELECTOR_ID)?.remove();\r\n            const\r\n               reverseBtn = document.createElement(\'div\'),\r\n               renderTitle = () => reverseBtn.title = `Reverse playlist order is ${window.nova_playlistReversed ? \'ON\' : \'OFF\'}`;\r\n            if (window.nova_playlistReversed) reverseBtn.className = CLASS_NAME_ACTIVE;\r\n            reverseBtn.id = SELECTOR_ID;\r\n            renderTitle();\r\n            reverseBtn.innerHTML =\r\n               `<yt-icon-button>\r\n                  <svg viewBox=\"0 0 381.399 381.399\" height=\"100%\" width=\"100%\">\r\n                     <g>\r\n                        <path d=\"M233.757,134.901l-63.649-25.147v266.551c0,2.816-2.286,5.094-5.104,5.094h-51.013c-2.82,0-5.099-2.277-5.099-5.094 V109.754l-63.658,25.147c-2.138,0.834-4.564,0.15-5.946-1.669c-1.389-1.839-1.379-4.36,0.028-6.187L135.452,1.991 C136.417,0.736,137.91,0,139.502,0c1.576,0,3.075,0.741,4.041,1.991l96.137,125.061c0.71,0.919,1.061,2.017,1.061,3.109 c0,1.063-0.346,2.158-1.035,3.078C238.333,135.052,235.891,135.735,233.757,134.901z M197.689,378.887h145.456v-33.62H197.689 V378.887z M197.689,314.444h145.456v-33.622H197.689V314.444z M197.689,218.251v33.619h145.456v-33.619H197.689z\"/>\r\n                     </g>\r\n                  </svg>\r\n               </yt-icon-button>`;\r\n            reverseBtn.addEventListener(\'click\', () => {\r\n               reverseBtn.classList.toggle(CLASS_NAME_ACTIVE);\r\n               window.nova_playlistReversed = !window.nova_playlistReversed;\r\n               if (window.nova_playlistReversed) {\r\n                  reverseControl();\r\n                  renderTitle();\r\n                  fixConflictPlugins();\r\n               }\r\n               else location.reload();\r\n            });\r\n            container.append(reverseBtn);\r\n         }\r\n      }\r\n      function fixConflictPlugins() {\r\n         document.getElementById(\'nova-playlist-duration\').innerHTML = \'&nbsp; [out of reach] &nbsp;\';\r\n         if (autoplayBtn = document.getElementById(\'nova-playlist-autoplay-btn\')) {\r\n            autoplayBtn.disabled = true;\r\n            autoplayBtn.title = \'out of reach\';\r\n         }\r\n      }\r\n      async function reverseControl() {\r\n         if (!window.nova_playlistReversed) return;\r\n         if ((ytdWatch = await NOVA.waitSelector(\'ytd-watch-flexy\', { stop_on_page_change: true }))\r\n            && (data = await NOVA.waitUntil(() => ytdWatch?.data.contents?.twoColumnWatchNextResults))\r\n            && (playlist = data.playlist.playlist)\r\n            && (autoplay = data.autoplay.autoplay)\r\n         ) {\r\n            playlist.contents.reverse();\r\n            playlist.currentIndex = (playlist.totalVideos - playlist.currentIndex) - 1;\r\n            playlist.localCurrentIndex = (playlist.contents.length - playlist.localCurrentIndex) - 1;\r\n            for (const i of autoplay.sets) {\r\n               i.autoplayVideo = i.previousButtonVideo;\r\n               i.previousButtonVideo = i.nextButtonVideo;\r\n               i.nextButtonVideo = i.autoplayVideo;\r\n            }\r\n            ytdWatch.updatePageData_(data);\r\n            if ((manager = document.body.querySelector(\'yt-playlist-manager\'))\r\n               && (ytdPlayer = document.getElementById(\'ytd-player\'))\r\n            ) {\r\n               ytdPlayer.updatePlayerComponents(null, autoplay, null, playlist);\r\n               manager.autoplayData = autoplay;\r\n               manager.setPlaylistData(playlist);\r\n               ytdPlayer.updatePlayerPlaylist_(playlist);\r\n            }\r\n         }\r\n         scrollToElement(document.body.querySelector(\'#secondary #playlist-items[selected], ytm-playlist .item[selected=true]\'));\r\n      }\r\n      function scrollToElement(targetEl = required()) {\r\n         if (!(targetEl instanceof HTMLElement)) return console.error(\'targetEl not HTMLElement:\', targetEl);\r\n         const container = targetEl.parentElement;\r\n         container.scrollTop = targetEl.offsetTop - container.offsetTop;\r\n      }\r\n   },\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'playlist-duration\',\r\n   title: \'Show playlist duration\',\r\n   \'title:zh\': \'显示播放列表持续时间\',\r\n   \'title:ja\': \'プレイリストの期間を表示\',\r\n   \'title:ko\': \'재생목록 재생시간 표시\',\r\n   \'title:id\': \'Tampilkan durasi daftar putar\',\r\n   \'title:es\': \'Mostrar duración de la lista de reproducción\',\r\n   \'title:pt\': \'Mostrar duração da lista de reprodução\',\r\n   \'title:fr\': \'Afficher la durée de la liste de lecture\',\r\n   \'title:it\': \'Mostra la durata della playlist\',\r\n   \'title:de\': \'Wiedergabelistendauer anzeigen\',\r\n   \'title:pl\': \'Pokaż czas trwania playlisty\',\r\n   \'title:ua\': \'Показувати тривалість списку відтворення\',\r\n   run_on_pages: \'watch, playlist, -mobile\',\r\n   restart_on_location_change: true,\r\n   section: \'sidebar\',\r\n   _runtime: user_settings => {\r\n      const\r\n         SELECTOR_ID = \'nova-playlist-duration\',\r\n         playlistId = NOVA.queryURL.get(\'list\');\r\n      if (!playlistId) return;\r\n      switch (NOVA.currentPage) {\r\n         case \'playlist\':\r\n            NOVA.waitSelector(\'#owner-text a\')\r\n               .then(el => {\r\n                  if (duration = getPlaylistDuration()) {\r\n                     insertToHTML({ \'container\': el, \'text\': duration });\r\n                  }\r\n                  else {\r\n                     getPlaylistDurationFromThumbnails({\r\n                        \'items_selector\': \'#primary .ytd-thumbnail-overlay-time-status-renderer:not(:empty)\',\r\n                     })\r\n                        .then(duration => insertToHTML({ \'container\': el, \'text\': duration }));\r\n                  }\r\n                  function getPlaylistDuration() {\r\n                     const vids_list = (document.body.querySelector(\'ytd-app\')?.data?.response || window.ytInitialData)\r\n                        .contents.twoColumnBrowseResultsRenderer\r\n                        ?.tabs[0].tabRenderer?.content?.sectionListRenderer\r\n                        ?.contents[0].itemSectionRenderer\r\n                        ?.contents[0].playlistVideoListRenderer?.contents\r\n                        || document.body.querySelector(\'ytd-watch-flexy\')?.__data.playlistData?.contents\r\n                        || document.body.querySelector(\'ytd-watch-flexy\')?.data?.playlist?.playlist?.contents\r\n                        ;\r\n                     const duration = vids_list?.reduce((acc, vid) => acc + (isNaN(vid.playlistVideoRenderer?.lengthSeconds) ? 0 : parseInt(vid.playlistVideoRenderer.lengthSeconds)), 0);\r\n                     if (duration) {\r\n                        return outFormat(duration);\r\n                     }\r\n                  }\r\n               });\r\n            break;\r\n         case \'watch\':\r\n            NOVA.waitSelector(\'#secondary .index-message-wrapper\', { stop_on_page_change: true })\r\n               .then(el => {\r\n                  const waitPlaylist = setInterval(() => {\r\n                     const\r\n                        playlistLength = movie_player.getPlaylist()?.length,\r\n                        playlistList = document.body.querySelector(\'yt-playlist-manager\')?.currentPlaylistData_?.contents\r\n                           .filter(e => e.playlistPanelVideoRenderer?.lengthText?.simpleText)\r\n                           .map(e => NOVA.timeFormatTo.hmsToSec(e.playlistPanelVideoRenderer.lengthText.simpleText));\r\n                     console.assert(playlistList?.length === playlistLength, \'playlist loading:\', playlistList?.length + \'/\' + playlistLength);\r\n                     if (playlistList?.length === playlistLength) {\r\n                        clearInterval(waitPlaylist);\r\n                        if (duration = getPlaylistDuration(playlistList)) {\r\n                           insertToHTML({ \'container\': el, \'text\': duration });\r\n                        }\r\n                        else if (!user_settings.playlist_duration_progress_type) {\r\n                           getPlaylistDurationFromThumbnails({\r\n                              \'container\': document.body.querySelector(\'#secondary #playlist\'),\r\n                              \'items_selector\': \'#playlist-items #unplayableText[hidden]\',\r\n                           })\r\n                              .then(duration => insertToHTML({ \'container\': el, \'text\': duration }));\r\n                        }\r\n                     }\r\n                  }, 2000);\r\n                  function getPlaylistDuration(total_list) {\r\n                     const currentIndex = movie_player.getPlaylistIndex();\r\n                     let elapsedList = [...total_list];\r\n                     switch (user_settings.playlist_duration_progress_type) {\r\n                        case \'done\':\r\n                           elapsedList.splice(currentIndex);\r\n                           break;\r\n                        case \'left\':\r\n                           elapsedList.splice(0, currentIndex);\r\n                           break;\r\n                     }\r\n                     const sumArr = arr => arr.reduce((acc, time) => acc + +time, 0);\r\n                     return outFormat(\r\n                        sumArr(elapsedList),\r\n                        user_settings.playlist_duration_percentage ? sumArr(total_list) : false\r\n                     );\r\n                  }\r\n               });\r\n            break;\r\n      }\r\n      function getPlaylistDurationFromThumbnails({ items_selector = required(), container }) {\r\n         if (container && !(container instanceof HTMLElement)) {\r\n            return console.error(\'container not HTMLElement:\', container);\r\n         }\r\n         return new Promise(resolve => {\r\n            let forcePlaylistRun = false;\r\n            const waitThumbnails = setInterval(() => {\r\n               const\r\n                  playlistLength = movie_player.getPlaylist()?.length\r\n                     || document.body.querySelector(\'ytd-player\')?.player_?.getPlaylist()?.length\r\n                     || document.body.querySelectorAll(items_selector)?.length,\r\n                  timeStampList = (container || document.body)\r\n                     .querySelectorAll(\'.ytd-thumbnail-overlay-time-status-renderer:not(:empty)\'),\r\n                  duration = getTotalTime(timeStampList);\r\n               console.assert(timeStampList.length === playlistLength, \'playlist loading:\', timeStampList.length + \'/\' + playlistLength);\r\n               if (+duration && timeStampList.length\r\n                  && (timeStampList.length === playlistLength || forcePlaylistRun)\r\n               ) {\r\n                  clearInterval(waitThumbnails);\r\n                  resolve(outFormat(duration));\r\n               }\r\n               else if (!forcePlaylistRun) {\r\n                  setTimeout(() => forcePlaylistRun = true, 1000 * 3);\r\n               }\r\n            }, 500);\r\n         });\r\n         function getTotalTime(nodes) {\r\n            const arr = [...nodes]\r\n               .map(e => NOVA.timeFormatTo.hmsToSec(e.textContent))\r\n               .filter(Number);\r\n            return arr.length && arr.reduce((acc, time) => acc + +time, 0);\r\n         }\r\n      }\r\n      function outFormat(duration = 0, total) {\r\n         let outArr = [\r\n            NOVA.timeFormatTo.HMS.digit(\r\n               (NOVA.currentPage == \'watch\' && NOVA.videoElement?.playbackRate)\r\n                  ? (duration / NOVA.videoElement.playbackRate) : duration\r\n            )\r\n         ];\r\n         if (total) {\r\n            outArr.push(`(${~~(duration * 100 / total) + \'%\'})`);\r\n            if (user_settings.playlist_duration_progress_type) {\r\n               outArr.push(user_settings.playlist_duration_progress_type);\r\n            }\r\n         }\r\n         return \' - \' + outArr.join(\' \');\r\n      }\r\n      function insertToHTML({ text = \'\', container = required() }) {\r\n         if (!(container instanceof HTMLElement)) return console.error(\'container not HTMLElement:\', container);\r\n         (container.querySelector(`#${SELECTOR_ID}`) || (function () {\r\n            const el = document.createElement(\'span\');\r\n            el.id = SELECTOR_ID;\r\n            return container.appendChild(el);\r\n         })())\r\n            .textContent = \' \' + text;\r\n      }\r\n   },\r\n   options: {\r\n      playlist_duration_progress_type: {\r\n         _tagName: \'select\',\r\n         label: \'Time display mode\',\r\n         \'label:zh\': \'时间显示方式\',\r\n         \'label:ja\': \'時間表示モード\',\r\n         \'label:ko\': \'시간 표시 모드\',\r\n         \'label:id\': \'Mode tampilan waktu\',\r\n         \'label:es\': \'Modo de visualización de la hora\',\r\n         \'label:pt\': \'Modo de exibição de tempo\',\r\n         \'label:fr\': \"Mode d\'affichage de l\'heure\",\r\n         \'label:it\': \"Modalità di visualizzazione dell\'ora\",\r\n         \'label:de\': \'Zeitanzeigemodus\',\r\n         \'label:pl\': \'Tryb wyświetlania czasu\',\r\n         \'label:ua\': \'Режим відображення часу\',\r\n         options: [\r\n            {\r\n               label: \'done\', value: \'done\',\r\n               \'label:zh\': \'结束\',\r\n               \'label:ja\': \'終わり\',\r\n               \'label:ko\': \'보았다\',\r\n               \'label:es\': \'hecho\',\r\n               \'label:pt\': \'feito\',\r\n               \'label:fr\': \'regardé\',\r\n               \'label:de\': \'fertig\',\r\n               \'label:pl\': \'zakończone\',\r\n               \'label:ua\': \'завершено\',\r\n            },\r\n            {\r\n               label: \'left\', value: \'left\',\r\n               \'label:zh\': \'剩下\',\r\n               \'label:ja\': \'残り\',\r\n               \'label:ko\': \'왼쪽\',\r\n               \'label:es\': \'izquierda\',\r\n               \'label:pt\': \'deixou\',\r\n               \'label:fr\': \'à gauche\',\r\n               \'label:de\': \'links\',\r\n               \'label:pl\': \'pozostało\',\r\n               \'label:ua\': \'залишилось\',\r\n            },\r\n            {\r\n               label: \'total\', value: false, selected: true,\r\n               \'label:zh\': \'全部的\',\r\n               \'label:ja\': \'全て\',\r\n               \'label:ko\': \'총\',\r\n               \'label:fr\': \'le total\',\r\n               \'label:de\': \'gesamt\',\r\n               \'label:pl\': \'w sumie\',\r\n               \'label:ua\': \'загалом\',\r\n            },\r\n         ],\r\n      },\r\n      playlist_duration_percentage: {\r\n         _tagName: \'input\',\r\n         label: \'Add percentage\',\r\n         \'label:zh\': \'显示百分比\',\r\n         \'label:ja\': \'パーセンテージを表示\',\r\n         \'label:ko\': \'백분율 추가\',\r\n         \'label:id\': \'Tambahkan persentase\',\r\n         \'label:es\': \'Agregar porcentaje\',\r\n         \'label:pt\': \'Adicionar porcentagem\',\r\n         \'label:fr\': \'Ajouter un pourcentage\',\r\n         \'label:it\': \'Aggiungi percentuale\',\r\n         \'label:de\': \'Prozent hinzufügen\',\r\n         \'label:pl\': \'Pokaż procenty\',\r\n         \'label:ua\': \'Показати %\',\r\n         type: \'checkbox\',\r\n         \'data-dependent\': { \'playlist_duration_progress_type\': [\'done\', \'left\'] },\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'related-visibility\',\r\n   title: \'Collapse related section\',\r\n   \'title:zh\': \'收起相关栏目\',\r\n   \'title:ja\': \'関連セクションを折りたたむ\',\r\n   \'title:ko\': \'관련 섹션 축소\',\r\n   \'title:id\': \'Ciutkan bagian terkait\',\r\n   \'title:es\': \'Ocultar sección relacionada\',\r\n   \'title:pt\': \'Recolher seção relacionada\',\r\n   \'title:fr\': \'Réduire la section associée\',\r\n   \'title:it\': \'Comprimi la sezione relativa\',\r\n   \'title:de\': \'Zugehörigen Abschnitt minimieren\',\r\n   \'title:pl\': \'Zwiń powiązaną sekcję\',\r\n   \'title:ua\': \'Згорнути розділ \"пов`язано\"\',\r\n   run_on_pages: \'watch, -mobile\',\r\n   section: \'sidebar\',\r\n   _runtime: user_settings => {\r\n      NOVA.collapseElement({\r\n         selector: \'#secondary #related\',\r\n         title: \'related\',\r\n         remove: (user_settings.related_visibility_mode == \'disable\') ? true : false,\r\n      });\r\n   },\r\n   options: {\r\n      related_visibility_mode: {\r\n         _tagName: \'select\',\r\n         label: \'Mode\',\r\n         \'label:zh\': \'模式\',\r\n         \'label:ja\': \'モード\',\r\n         \'label:ko\': \'방법\',\r\n         \'label:es\': \'Modo\',\r\n         \'label:pt\': \'Modo\',\r\n         \'label:it\': \'Mode\',\r\n         \'label:de\': \'Modus\',\r\n         \'label:pl\': \'Tryb\',\r\n         \'label:ua\': \'Режим\',\r\n         options: [\r\n            {\r\n               label: \'collapse\', value: \'hide\', selected: true,\r\n               \'label:pl\': \'zwiń\',\r\n               \'label:ua\': \'приховати\',\r\n            },\r\n            {\r\n               label: \'remove\', value: \'disable\',\r\n               \'label:zh\': \'消除\',\r\n               \'label:ja\': \'削除\',\r\n               \'label:ko\': \'제거하다\',\r\n               \'label:id\': \'menghapus\',\r\n               \'label:es\': \'eliminar\',\r\n               \'label:pt\': \'remover\',\r\n               \'label:fr\': \'retirer\',\r\n               \'label:it\': \'rimuovere\',\r\n               \'label:de\': \'entfernen\',\r\n               \'label:pl\': \'usunąć\',\r\n               \'label:ua\': \'видалити\',\r\n            },\r\n         ],\r\n      },\r\n   }\r\n});\r\nwindow.nova_plugins.push({\r\n   id: \'comments-sidebar-position-exchange\',\r\n   title: \'Exchange comments/sidebar position\',\r\n   run_on_pages: \'watch, -mobile\',\r\n   restart_on_location_change: true,\r\n   section: \'sidebar\',\r\n   _runtime: user_settings => {\r\n      if (user_settings.comments_visibility_mode == \'disable\'\r\n         || user_settings[\'comments-popup\']\r\n      ) {\r\n         return;\r\n      }\r\n      NOVA.waitSelector(\'ytd-watch-flexy:not([theater]) #below #comments\', { stop_on_page_change: true })\r\n         .then(comments => {\r\n            document.querySelector(\'#secondary\')?.appendChild(comments);\r\n            Object.assign(comments.style, {\r\n               height: \'100vh\',\r\n               overflow: \'auto\',\r\n            });\r\n         });\r\n      NOVA.waitSelector(\'ytd-watch-flexy:not([theater]) #secondary #related\', { stop_on_page_change: true })\r\n         .then(related => {\r\n            document.querySelector(\'#below\')?.appendChild(related);\r\n         });\r\n   },\r\n});\r\nconst Plugins = {\r\n   run: ({ user_settings, app_ver }) => {\r\n      if (!window.nova_plugins?.length) return console.error(\'nova_plugins empty\', window.nova_plugins);\r\n      if (!user_settings) return console.error(\'user_settings empty\', user_settings);\r\n      NOVA.currentPage = (function () {\r\n         const pathnameArray = location.pathname.split(\'/\').filter(Boolean);\r\n         const [page, channelTab] = [pathnameArray[0], pathnameArray.pop()];\r\n         NOVA.channelTab = [\'featured\', \'videos\', \'shorts\', \'streams\', \'playlists\', \'community\', \'channels\', \'about\'].includes(channelTab) ? channelTab : false;\r\n         return (page != \'live_chat\')\r\n            && ([\'channel\', \'c\', \'user\'].includes(page)\r\n               || page?.startsWith(\'@\')\r\n               || /[A-Z\\d_]/.test(page)\r\n               || NOVA.channelTab\r\n            ) ? \'channel\' : (page == \'clip\') ? \'watch\' : page || \'home\';\r\n      })();\r\n      NOVA.isMobile = location.host == \'m.youtube.com\';\r\n      let logTableArray = [],\r\n         logTableStatus,\r\n         logTableTime;\r\n      window.nova_plugins?.forEach(plugin => {\r\n         const pagesAllowList = plugin?.run_on_pages?.split(\',\').map(p => p.trim().toLowerCase()).filter(Boolean);\r\n         logTableTime = 0;\r\n         logTableStatus = false;\r\n         if (!pluginChecker(plugin)) {\r\n            console.error(\'Plugin invalid\\n\', plugin);\r\n            alert(\'Plugin invalid: \' + plugin?.id);\r\n            logTableStatus = \'INVALID\';\r\n         }\r\n         else if (plugin.was_init && !plugin.restart_on_location_change) {\r\n            logTableStatus = \'skiped\';\r\n         }\r\n         else if (!user_settings.hasOwnProperty(plugin.id)) {\r\n            logTableStatus = \'off\';\r\n         }\r\n         else if (\r\n            (\r\n               pagesAllowList?.includes(NOVA.currentPage)\r\n               || (pagesAllowList?.includes(\'*\') && !pagesAllowList?.includes(\'-\' + NOVA.currentPage))\r\n            )\r\n            && (!NOVA.isMobile || (NOVA.isMobile && !pagesAllowList?.includes(\'-mobile\')))\r\n         ) {\r\n            try {\r\n               const startTableTime = performance.now();\r\n               plugin.was_init = true;\r\n               plugin._runtime(user_settings);\r\n               logTableTime = (performance.now() - startTableTime).toFixed(2);\r\n               logTableStatus = true;\r\n            } catch (err) {\r\n               console.groupEnd(\'plugins status\');\r\n               console.error(`[ERROR PLUGIN] ${plugin.id}\\n${err.stack}\\n\\nPlease report the bug: https://github.com/raingart/Nova-YouTube-extension/issues/new?body=` + encodeURIComponent(app_ver + \' | \' + navigator.userAgent));\r\n               if (user_settings.report_issues && _pluginsCaptureException) {\r\n                  _pluginsCaptureException({\r\n                     \'trace_name\': plugin.id,\r\n                     \'err_stack\': err.stack,\r\n                     \'app_ver\': app_ver,\r\n                     \'confirm_msg\': `ERROR in Nova YouTube™\\n\\nCrash plugin: \"${plugin.title || plugin.id}\"\\nPlease report the bug or disable the plugin\\n\\nSend the bug raport to developer?`,\r\n                  });\r\n               }\r\n               console.groupCollapsed(\'plugins status\');\r\n               logTableStatus = \'ERROR\';\r\n            }\r\n         }\r\n         logTableArray.push({\r\n            \'launched\': logTableStatus,\r\n            \'name\': plugin?.id,\r\n            \'time init (ms)\': logTableTime,\r\n         });\r\n      });\r\n      console.table(logTableArray);\r\n      console.groupEnd(\'plugins status\');\r\n      function pluginChecker(plugin) {\r\n         const result = plugin?.id && plugin.run_on_pages && \'function\' === typeof plugin._runtime;\r\n         if (!result) {\r\n            console.error(\'plugin invalid:\\n\', {\r\n               \'id\': plugin?.id,\r\n               \'run_on_pages\': plugin?.run_on_pages,\r\n               \'_runtime\': \'function\' === typeof plugin?._runtime,\r\n            });\r\n         }\r\n         return result;\r\n      }\r\n   },\r\n}\r\nconst\r\n   configPage = \'https://raingart.github.io/options.html\',\r\n   configStoreName = \'user_settings\',\r\n   user_settings = Android.GM_getValue(configStoreName, null);\r\nif (user_settings?.exclude_iframe && (window.frameElement || window.self !== window.top)) {\r\n   return console.warn(\': processed in the iframe disable\');\r\n}\r\nconsole.debug(`current ${configStoreName}:`, user_settings);\r\nconst keyRenameTemplate = {\r\n   \'shorts_thumbnails_time\': \'shorts-thumbnails-time\',\r\n}\r\nfor (const oldKey in user_settings) {\r\n   if (newKey = keyRenameTemplate[oldKey]) {\r\n      console.log(oldKey, \'=>\', newKey);\r\n      delete Object.assign(user_settings, { [newKey]: user_settings[oldKey] })[oldKey];\r\n   }\r\n   Android.GM_setValue(configStoreName, user_settings);\r\n}\r\nregisterMenuCommand();\r\nif (location.hostname === new URL(configPage).hostname) setupConfigPage();\r\nelse {\r\n   if (!user_settings?.disable_setting_button) insertSettingButton();\r\n   if (!user_settings || !Object.keys(user_settings).length) {\r\n      if (confirm(\'Active plugins undetected. Open the settings page now?\')) Android.GM_openInWindow(configPage);\r\n      user_settings[\'report_issues\'] = \'on\';\r\n      Android.GM_setValue(configStoreName, user_settings);\r\n   }\r\n   else landerPlugins();\r\n}\r\nfunction setupConfigPage() {\r\n   document.addEventListener(\'submit\', event => {\r\n      event.preventDefault();\r\n      let obj = {};\r\n      for (const [key, value] of new FormData(event.target)) {\r\n         if (obj.hasOwnProperty(key)) {\r\n            obj[key] += \',\' + value;\r\n            obj[key] = obj[key].split(\',\');\r\n         }\r\n         else {\r\n            switch (value) {\r\n               case \'true\': obj[key] = true; break;\r\n               case \'false\': obj[key] = false; break;\r\n               case \'undefined\': delete obj[key]; break;\r\n               default: obj[key] = value;\r\n            }\r\n         };\r\n      }\r\n      console.debug(`update ${configStoreName}:`, obj);\r\n      Android.GM_setValue(configStoreName, obj);\r\n   });\r\n   window.addEventListener(\'DOMContentLoaded\', () => {\r\n      localizePage(user_settings?.lang_code);\r\n      storeData = user_settings;\r\n      //unsafeWindow.window.nova_plugins = window.nova_plugins;\r\n   });\r\n   window.addEventListener(\'load\', () => {\r\n      document.body?.classList?.remove(\'preload\');\r\n      document.body.querySelector(\'a[href$=\"issues/new\"]\')\r\n         .addEventListener(\'click\', ({ target }) => {\r\n            target.href += \'?body=\' + encodeURIComponent(\'0.43.0\' + \' | \' + navigator.userAgent);\r\n         });\r\n   });\r\n}\r\nfunction landerPlugins() {\r\n   processLander();\r\n   function processLander() {\r\n      const plugins_lander = setInterval(() => {\r\n         const domLoaded = document?.readyState != \'loading\';\r\n         if (!domLoaded) return console.debug(\'waiting, page loading..\');\r\n         clearInterval(plugins_lander);\r\n         console.groupCollapsed(\'plugins status\');\r\n         Plugins.run({\r\n            \'user_settings\': user_settings,\r\n            \'app_ver\': \'0.43.0\',\r\n         });\r\n      }, 500);\r\n   }\r\n   let prevURL = location.href;\r\n   const isURLChanged = () => prevURL == location.href ? false : prevURL = location.href;\r\n   if (isMobile = (location.host == \'m.youtube.com\')) {\r\n      window.addEventListener(\'transitionend\', ({ target }) => target.id == \'progress\' && isURLChange() && processLander());\r\n   }\r\n   else {\r\n      document.addEventListener(\'yt-navigate-start\', () => isURLChanged() && processLander());\r\n   }\r\n}\r\nfunction registerMenuCommand() {\r\n   Android.GM_registerMenuCommand(\'Settings\', configPage);\r\n}\r\nfunction insertSettingButton() {\r\n   NOVA.waitSelector(\'#masthead #end\')\r\n      .then(menu => {\r\n         const\r\n            titleMsg = \'Nova Settings\',\r\n            a = document.createElement(\'a\'),\r\n            SETTING_BTN_ID = \'nova_settings_button\';\r\n         a.id = SETTING_BTN_ID;\r\n         a.href = configPage + \'?tabs=tab-plugins\';\r\n         a.target = \'_blank\';\r\n         a.innerHTML =\r\n            `<yt-icon-button class=\"style-scope ytd-button-renderer style-default size-default\">\r\n               <svg viewBox=\"-4 0 20 16\">\r\n                  <radialGradient id=\"nova-gradient\" gradientUnits=\"userSpaceOnUse\" cx=\"6\" cy=\"22\" r=\"18.5\">\r\n                     <stop class=\"nova-gradient-start\" offset=\"0\"/>\r\n                     <stop class=\"nova-gradient-stop\" offset=\"1\"/>\r\n                  </radialGradient>\r\n                  <g fill=\"deepskyblue\">\r\n                     <polygon points=\"0,16 14,8 0,0\"/>\r\n                  </g>\r\n               </svg>\r\n            </yt-icon-button>`;\r\n         a.addEventListener(\'click\', () => {\r\n            setTimeout(() => document.body.click(), 200);\r\n         });\r\n         a.title = titleMsg;\r\n         const tooltip = document.createElement(\'tp-yt-paper-tooltip\');\r\n         tooltip.className = \'style-scope ytd-topbar-menu-button-renderer\';\r\n         tooltip.textContent = titleMsg;\r\n         a.appendChild(tooltip);\r\n         menu.prepend(a);\r\n         NOVA.css.push(\r\n            `#${SETTING_BTN_ID}[tooltip]:hover:after {\r\n               position: absolute;\r\n               top: 50px;\r\n               transform: translateX(-50%);\r\n               content: attr(tooltip);\r\n               text-align: center;\r\n               min-width: 3em;\r\n               max-width: 21em;\r\n               white-space: nowrap;\r\n               overflow: hidden;\r\n               text-overflow: ellipsis;\r\n               padding: 1.8ch 1.2ch;\r\n               border-radius: 0.6ch;\r\n               background-color: #616161;\r\n               box-shadow: 0 1em 2em -0.5em rgb(0 0 0 / 35%);\r\n               color: #fff;\r\n               z-index: 1000;\r\n            }\r\n            #${SETTING_BTN_ID} {\r\n               position: relative;\r\n               opacity: .3;\r\n               transition: opacity .3s ease-out;\r\n            }\r\n            #${SETTING_BTN_ID}:hover {\r\n               opacity: 1 !important;\r\n            }\r\n            #${SETTING_BTN_ID} path,\r\n            #${SETTING_BTN_ID} polygon {\r\n               fill: url(#nova-gradient);\r\n            }\r\n            #${SETTING_BTN_ID} .nova-gradient-start,\r\n            #${SETTING_BTN_ID} .nova-gradient-stop {\r\n               transition: .6s;\r\n               stop-color: #7a7cbd;\r\n            }\r\n            #${SETTING_BTN_ID}:hover .nova-gradient-start {\r\n               stop-color: #0ff;\r\n            }\r\n            #${SETTING_BTN_ID}:hover .nova-gradient-stop {\r\n               stop-color: #0095ff;\r\n               \r\n            }`);\r\n      });\r\n}\r\nfunction _pluginsCaptureException({ trace_name, err_stack, confirm_msg, app_ver }) {\r\n}\r\n"
                    view.loadUrl("javascript:" + script);
                    //mWebView.evaluateJavascript(script, null);
                    
                }
            }
        });
        mWebView.addJavascriptInterface(new JavaScriptInterface(), "Android");
        sharedPreferences = getSharedPreferences("GMPrefs", Context.MODE_PRIVATE);

        
        // REMOTE RESOURCE
        mWebView.loadUrl("https://www.google.com/");
        
//        String javascriptCode = ""function e(){function e(){var e=document.getElementsByTagName(\"video\");if(e.length>0){e[0].outerHTML;window.location.href.match(/^https:\\/\\/m\\.youtube\\.com\\/watch\\?v=/)?function(){var e=document.querySelector(\"video\"),t=function(e){let t=\"\";try{if(e.includes(\"youtu.be/\"))return e.substring(e.lastIndexOf(\"/\")+1);var n=new URL(e).search;if(!n)return\"\";t=new URLSearchParams(n).get(\"v\")}catch(e){console.error(e)}return t}(window.location.href),n=Math.min(window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,window.screen.width||window.screen.availWidth||document.documentElement.offsetWidth),i=Math.min(window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight,window.screen.height||window.screen.availHeight||document.documentElement.offsetHeight),o=Math.max(n,i);let d=\"\";d=o<320?`https://i.ytimg.com/vi_webp/${t}/default.webp`:o<480?`https://i.ytimg.com/vi_webp/${t}/mqdefault.webp`:o<640?`https://i.ytimg.com/vi_webp/${t}/hqdefault.webp`:o<1280?`https://i.ytimg.com/vi_webp/${t}/sddefault.webp`:`https://i.ytimg.com/vi_webp/${t}/maxresdefault.webp`;e.setAttribute(\"poster\",d),console.log(\"poster has been set with: \"+d+\"\\n\\nbaseDimension :\\n\\n\"+o)}():window.location.href.match(/^https:\\/\\/www\\.youtube\\.com\\/watch\\?v=/)||e.hasAttribute(\"poster\")}}e(),window.addEventListener(\"hashchange\",e)}window.location.href.match(/^https:\\/\\/m\\.youtube\\.com\\//)?window.addEventListener(\"state-navigateend\",e):window.addEventListener(\"DOMContentLoaded\",e);";
//        mWebView.loadUrl("javascript:" + javascriptCode);
//webView.evaluateJavascript(javascriptCode, null);
        
        
        // LOCAL RESOURCE
        // mWebView.loadUrl("file:///android_asset/index.html");
    }

    private class JavaScriptInterface {
        @JavascriptInterface
        public void GM_setValue(String key, String value) {
            SharedPreferences.Editor editor = sharedPreferences.edit();
            editor.putString(key, value);
            editor.apply();
        }

        @JavascriptInterface
        public String GM_getValue(String key, String defaultValue) {
            return sharedPreferences.getString(key, defaultValue);
        }

        @JavascriptInterface
        public void GM_registerMenuCommand(String caption, String configPage) {
            webView.loadUrl(configPage);
        }

        @JavascriptInterface
        public void GM_openInWindow(String url) {
            webView.loadUrl(url);
        }
    }
    @Override
    public void onBackPressed() {
        if(mWebView.canGoBack()) {
            mWebView.goBack();
        } else {
            super.onBackPressed();
        }
    }
}
